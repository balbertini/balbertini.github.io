
<!DOCTYPE html>
<html lang="pt_br">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://balbertini.github.io/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://balbertini.github.io/theme/pygments/github.min.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css">


    <link href="https://balbertini.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="B.Albertini's site Atom">



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-125173293-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="Bruno Albertini" />
<meta name="description" content="Como fazer simplificação de estados em máquinas de estados finitas." />
<meta name="keywords" content="sistemas digitais, fsm, simplificação, otimização">

<meta property="og:site_name" content="B.Albertini's site"/>
<meta property="og:title" content="Simplificação de FSM"/>
<meta property="og:description" content="Como fazer simplificação de estados em máquinas de estados finitas."/>
<meta property="og:locale" content="pt_BR"/>
<meta property="og:url" content="https://balbertini.github.io/fsmstatereduction-pt_BR.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-09-25 14:22:00-03:00"/>
<meta property="article:modified_time" content="2018-09-26 18:02:00-03:00"/>
<meta property="article:author" content="https://balbertini.github.io/author/bruno-albertini.html">
<meta property="article:section" content="sistemas digitais"/>
<meta property="article:tag" content="sistemas digitais"/>
<meta property="article:tag" content="fsm"/>
<meta property="article:tag" content="simplificação"/>
<meta property="article:tag" content="otimização"/>
<meta property="og:image" content="">

  <title>B.Albertini's site &ndash; Simplificação de FSM</title>

</head>
<body>
  <aside>
    <div>
      <a href="https://balbertini.github.io">
        <img src="https://balbertini.github.io/theme/img/profile.png" alt="" title="">
      </a>
      <h1><a href="https://balbertini.github.io"></a></h1>


      <nav>
        <ul class="list">
          <li><a href="https://balbertini.github.io/pages/research-pt_BR.html#research">Pesquisa</a></li>
          <li><a href="https://balbertini.github.io/pages/sobre-pt_BR.html#sobre">Sobre</a></li>
          <li><a href="https://balbertini.github.io/pages/vhdl-pt_BR.html#vhdl">VHDL</a></li>

        </ul>
      </nav>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="fsmstatereduction">Simplificação de FSM</h1>
    <p>
      Publicado em 25/09/2018 (Ter) na categoria <a href="https://balbertini.github.io/category/sistemas-digitais.html">sistemas digitais</a>
    </p>
  </header>


  <div>
    <p>A máquina de estados finita em sistemas digitais, quando realizada na forma de um circuito digital, utiliza recursos computacionais (e.g. <em>flip-flops</em>, memórias, portas lógicas, etc.) que são caros do ponto de vista de área e consumo de energia, principalmente se a máquina possuir muitos estados. Por este motivo, é importante minimizar o número de estados da máquina para que, na implementação, utilizemos somente os recursos mínimos necessários para aquela máquina. Além disso, quando estamos projetando uma máquina de estados para resolver um problema, é mais confortável não pensar em otimizações mas sim na funcionalidade da máquina, para só depois pensar na otimização. De fato, a maioria dos projetistas comerciais não pensa na otimização quando estão modelando o problema pois isso nem sempre é possível (i.e. o projetista não tem visão da máquina toda mas sim da parte cabível a ele, a máquina é muito grande tornando impossível pensar em tudo, a máquina é particionada, etc).</p>
<p>Na prática, com os sintetizadores modernos, você pode especificar sua máquina usando a linguagem de descrição de hardware de sua preferência e deixar o sintetizador otimizá-la para você. Os resultados da otimização automática são bons quando comparados aos métodos manuais [1,2]. Contudo, é necessário conhecer o mínimo do funcionamento dos algoritmos de minimização pois, quando for descrever sua máquina, você conhecerá ao menos o básico do que acontecerá quando sintetizá-la. Neste artigo, explicarei os métodos de minimização por identificação direta na tabela de transição de estados e por tabela de implicação. Em ambos os casos, o objetivo principal é encontrar estados equivalentes, ou seja, que <strong>para a mesma entrada, produzem a mesma saída e transicionam para os mesmos estados.</strong></p>
<h2>Minimização através da tabela de transição</h2>
<p>Em muitos casos, é fácil identificar os estados equivalentes na tabela de transição de estados, por isso este método também é chamado de <strong>observação direta</strong> ou <strong>casamento de linhas</strong>. O algoritmo é simples:</p>
<ol>
<li>Elimine todos os estados inalcançáveis (estados onde não chega nenhuma aresta partindo de outro estado alcançável).</li>
<li>Identifique dois estados A e B que, para a mesma entrada, produzam exatamente a mesma saída e realizem a mesma transição (transicionem para o mesmo estado).</li>
<li>Elimine um dos estados (e.g. B) apagando a linha correspondente a este estado e substitua todas as ocorrências de B por A (i.e. todos as transições para B agora devem apontar para A).</li>
<li>Repita até que nenhum par de estados atenda (2).</li>
</ol>
<h3>Exemplo</h3>
<p>Uma forma muito comum de projetar máquinas de estados é modelando-a como árvore, onde cada ramificação é uma tomada de decisão. Tomemos a máquina abstrata a seguir que foi montada partindo de uma árvore binária canônica e modificada para reconhecer as sequencias 0011 e 1001:</p>
<p><img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"></p>
<p>Em vermelho está destacado o caminho que esta máquina irá seguir para reconhecer as duas sequencias. Note que esta é uma máquina de Mealy e não leva em consideração nenhuma sobreposição entre as sequencias detectadas, ou seja, ela só funciona para entradas de 4 bits agrupados a partir do <em>reset</em> (e.g. detecta duas vezes se a entrada for 0011 1001 mas não detecta a segunda vez se a entrada for 0011 001).</p>
<p>A tabela de transição de estados fica como na Tabela 1 a seguir.</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0px;margin-right:10px;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-3r9o{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-4m7p{background-color:#9aff99;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-uuae{background-color:#67fd9a;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-fcno{background-color:#fcff2f;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-bolj{background-color:#ffccc9;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-mfhl{background-color:#ffffc7;border-color:inherit;text-align:center;vertical-align:top}
</style>

<!-- ------------------------------------------------------- -->

<table class="tg" align="left">
  <tr>
    <th class="tg-baqh" colspan="3">Tabela 1</th>
  </tr>
  <tr>
    <td class="tg-zlqz" rowspan="2">E.A.</td>
    <td class="tg-zlqz" colspan="2">P.E.</td>
  </tr>
  <tr>
    <td class="tg-zlqz">0</td>
    <td class="tg-zlqz">1</td>
  </tr>
  <tr>
    <td class="tg-baqh">S0</td>
    <td class="tg-baqh">S1/0</td>
    <td class="tg-baqh">S2/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S3/0</td>
    <td class="tg-baqh">S4/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S2</td>
    <td class="tg-baqh">S5/0</td>
    <td class="tg-baqh">S6/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S3</td>
    <td class="tg-baqh">S7/0</td>
    <td class="tg-baqh">S8/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S4</td>
    <td class="tg-baqh">S9/0</td>
    <td class="tg-baqh">S10/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S5</td>
    <td class="tg-baqh">S11/0</td>
    <td class="tg-baqh">S12/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S6</td>
    <td class="tg-baqh">S13/0</td>
    <td class="tg-baqh">S14/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S7</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S8</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/1</td>
  </tr>
  <tr>
    <td class="tg-baqh">S9</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S10</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S11</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/1</td>
  </tr>
  <tr>
    <td class="tg-baqh">S12</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S13</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/0</td>
  </tr>
  <tr>
    <td class="tg-baqh">S14</td>
    <td class="tg-baqh">S0/0</td>
    <td class="tg-baqh">S0/0</td>
  </tr>
</table>

<!-- ------------------------------------------------------- -->

<table class="tg" align="left">
  <tr>
    <th class="tg-c3ow" colspan="3">Tabela 2</th>
  </tr>
  <tr>
    <td class="tg-3r9o" rowspan="2">E.A.</td>
    <td class="tg-zlqz" colspan="2">P.E.</td>
  </tr>
  <tr>
    <td class="tg-zlqz">0</td>
    <td class="tg-zlqz">1</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S0</td>
    <td class="tg-c3ow">S1/0</td>
    <td class="tg-c3ow">S2/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S1</td>
    <td class="tg-c3ow">S3/0</td>
    <td class="tg-c3ow">S4/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S2</td>
    <td class="tg-c3ow">S5/0</td>
    <td class="tg-c3ow">S6/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S3</td>
    <td class="tg-4m7p">Sa/0</td>
    <td class="tg-c3ow">S8/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S4</td>
    <td class="tg-4m7p">Sa/0</td>
    <td class="tg-4m7p">Sa/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S5</td>
    <td class="tg-c3ow">S11/0</td>
    <td class="tg-4m7p">Sa/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S6</td>
    <td class="tg-4m7p">Sa/0</td>
    <td class="tg-4m7p">Sa/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S8</td>
    <td class="tg-c3ow">S0/0</td>
    <td class="tg-c3ow">S0/1</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S11</td>
    <td class="tg-c3ow">S0/0</td>
    <td class="tg-c3ow">S0/1</td>
  </tr>
  <tr>
    <td class="tg-uuae">Sa</td>
    <td class="tg-c3ow">S0/0</td>
    <td class="tg-c3ow">S0/0</td>
  </tr>
</table>

<!-- ------------------------------------------------------- -->

<table class="tg" align="left">
  <tr>
    <th class="tg-c3ow" colspan="3">Tabela 3</th>
  </tr>
  <tr>
    <td class="tg-3r9o" rowspan="2">E.A.</td>
    <td class="tg-zlqz" colspan="2">P.E.</td>
  </tr>
  <tr>
    <td class="tg-zlqz">0</td>
    <td class="tg-zlqz">1</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S0</td>
    <td class="tg-c3ow">S1/0</td>
    <td class="tg-c3ow">S2/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S1</td>
    <td class="tg-c3ow">S3/0</td>
    <td class="tg-bolj">Sb/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S2</td>
    <td class="tg-c3ow">S5/0</td>
    <td class="tg-bolj">Sb/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S3</td>
    <td class="tg-4m7p">Sa/0</td>
    <td class="tg-mfhl">Sc/0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">S5</td>
    <td class="tg-mfhl">Sc/0</td>
    <td class="tg-4m7p">Sa/0</td>
  </tr>
  <tr>
    <td class="tg-vswx">Sb</td>
    <td class="tg-4m7p">Sa/0</td>
    <td class="tg-4m7p">Sa/0</td>
  </tr>
  <tr>
    <td class="tg-fcno">Sc</td>
    <td class="tg-c3ow">S0/0</td>
    <td class="tg-c3ow">S0/1</td>
  </tr>
  <tr>
    <td class="tg-uuae">Sa</td>
    <td class="tg-c3ow">S0/0</td>
    <td class="tg-c3ow">S0/0</td>
  </tr>
</table>

<p>A coluna <strong>E.A.</strong> mostra o estado atual, e a coluna <strong>P.E.</strong> o próximo estado. Esta última é bipartida para as entradas igual a <strong>0</strong> e igual a <strong>1</strong>.</p>
<p>A Tabela 1 possui todas as transições da árvore como vista na figura. Esta máquina não tem nenhum estado inalcançável, então não há o que eliminar no passo 1.</p>
<p>No passo 2, devemos procurar as equivalências. É fácil perceber que há estados que produzem exatamente o mesmo resultado (transição e saída) para determinada entrada. Tomemos por exemplo os estados S7, S9, S10, S12, S13 e S14: todos transicionam para S0 e produzem saída 0 para qualquer entrada, portanto são equivalentes. Podemos reduzir a tabela substituindo todos estes estados por um estado Sa, o que podemos ver na Tabela 2, destacado em verde.</p>
<p>Se fizermos a busca novamente, os estados S4 e S6 agora são equivalentes pois ambos transicionam para Sa e produzem saída 0, independententemente da entrada. Criamos o estado Sb, em vermelho, para substituir estes estados. Similarmente os estados S8 e S11 são equivalentes, mas note que eles tem saídas diferentes para entradas diferentes. Para este conjunto de estados, criamos Sc, em amarelo. Não há mais estados equivalentes e o resultado final pode ser visto na Tabela 3.</p>
<p><img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="35%" align="right" style="padding-left:5%" />
<br/>
O diagrama de transição de estados minimizado pode ser visto na figura ao lado. Os estados S7, S9, S10, S12, S13 e S14 são representados pelo Sa, S4 e S6 pelo Sb e S8 e S11 pelo Sc.</p>
<p>O método de análise da tabela de transição de estados se baseia na busca exaustiva por estados equivalentes. É fácil perceber que, conforme a tabela cresce, ficará mais difícil visualizar os estados equivalentes.</p>
<div style="border: 0px; overflow: auto;width: 100%;"></div>

<h2>O método de minimização por tabela de implicação</h2>
<p>Nem sempre é tão fácil perceber a equivalência de estados através da tabela de transição de estados, especialmente para máquinas grandes ou com muitas entradas. No entanto, os projetistas desenvolveram um método chamado de tabela de implicação. Este método é equivalente à análise através da tabela de transição de estados, porém é algorítmico e está organizado em forma de uma matriz, o que minimiza erros por parte do projetista. Além disso, apesar de ambos os métodos serem exaustivos, há uma diferença primordial: enquanto o método de análise da tabela de transição de estados procura exaustivamente estados equivalentes, o método da tabela de implicação procura exaustivamente os estados que <strong>não são equivalentes</strong>. Parte-se da premissa de que todos os estados são equivalentes entre si e, a cada iteração, elimina-se os estados que não podem ser equivalentes. Os estados que sobrarem são equivalentes.</p>
<p>Há dois momentos no método da tabela de implicação: a construção da tabela e a análise.</p>
<h3>Construção da matriz (tabela)</h3>
<p>A matriz pode ser construída como uma matriz <span class="math">\(n\)</span> por <span class="math">\(n\)</span>, onde <span class="math">\(n\)</span> é o número de estados (se você começar no <span class="math">\(S_0\)</span>, o último estado será <span class="math">\(S_{n-1}\)</span>). Cada linha <span class="math">\(i\)</span> da matriz representa um estado e cada coluna <span class="math">\(j\)</span> também.</p>
<p>Não faz sentido analisar a equivalência de um estado com ele mesmo, pois um estado sempre é equivalente a ele mesmo. Por este motivo, eliminamos a diagonal da matriz, onde <span class="math">\(i=j\)</span>. As metades diagonais superiores e inferiores significam a mesma coisa pois se uma célula <span class="math">\(X_{ij}\)</span> mostra equivalência entre o estado <span class="math">\(S_i\)</span> e o estado <span class="math">\(S_j\)</span>, a célula <span class="math">\(X_{ji}\)</span> também deve mostrar a mesma equivalência. Por este motivo, eliminamos também uma das metades diagonais. Por convenção, elimina-se a diagonal superior, mas o resultado é o mesmo se você eliminar a metade diagonal inferior.</p>
<p>Quando estiver confortável com a construção da matriz, você poderá desenhá-la já sem a diagonal e sem a metade diagonal superior. A esse desenho contendo somente a metade diagonal inferior da tabela, chamamos de <strong>tabela de implicação</strong>. Na figura abaixo mostramos a matriz inteira, a matriz destacando a linha diagonal (vermelha) e a metade diagonal superior (laranja), e finalmente a tabela de implicação.</p>
<p><img alt="Construção da tabela de implicação." src="https://balbertini.github.io/images/sd/sdfsmoptconsttab.png"></p>
<p>Após obter a tabela de implicação, devemos preencher as células. Cada célula terá <span class="math">\(2^b\)</span> linhas, onde <span class="math">\(b\)</span> é o número de bits da entrada. E.g. se a entrada for de 1 bit, cada célula tem 2 linhas; se a entrada for de 2 bits, cada célula tem 4 linhas. Cada linha da entrada corresponde às transições daqueles estados para aquela entrada.</p>
<p><img src='https://balbertini.github.io/images/sd/sdfsmoptconstcel.png' width="45%" align="right" style="padding-left:5%" />
Na figura podemos ver o exemplo do preenchimento para duas células, ambas na linha do <span class="math">\(S_3\)</span> e coluna do <span class="math">\(S_4\)</span>. Para simplificar o preenchimento, usamos somente o número do estado, mas sinta-se a vontade para escrever o nome completo (especialmente útil se os nomes dos estados não forem numerados). Na célula na esquerda na figura, a entrada tem 1 bit, portanto temos duas linhas, uma para a entrada 0 e outra para a entrada 1. Já na célula a direita na figura, a entrada tem 2 bits, portanto temos 4 linhas, para as entradas 00, 01, 10 e 11.</p>
<p>Os números em cada linha correspondem a transição que o estado fará para cada entrada. No exemplo a esquerda na figura, podemos assumir que, para uma determinada entrada e estando em <span class="math">\(S_3\)</span> ou em <span class="math">\(S_4\)</span>, a máquina transicionará para o estado <span class="math">\(S_0\)</span> ou <span class="math">\(S_1\)</span>. Na mesma situação mas para a outra entrada, a máquina transicionará para o estado <span class="math">\(S_2\)</span> ou <span class="math">\(S_3\)</span>. Mas como eu sei qual entrada? Não é preciso saber para qual entrada, apenas que as transições da mesma linha, separadas por <code>-</code>, são para a mesma entrada. De fato, alguns projetistas preferem ordenar as transições em ordem crescente para facilitar a busca por estados equivalentes. E.g. (linha superior / linha inferior) 3-2/1-2 é o mesmo que 1-2/2-3, mas ordenado. Fica a seu critério decidir a melhor forma de organizar sua tabela de implicação, mas lembre-se que cada linha corresponde a exatamente dois estados separados por <code>-</code>, para os quais a máquina de estados transicionará quando houver a mesma entrada.</p>
<p>É de praxe também assinalar os estados que produzem saídas diferentes, pois eles não podem ser equivalentes. Neste caso, coloque uma <code>/</code> no índice de coluna e linha (caso a máquina for de Moore) ou na transição dentro da célula (caso a máquina for de Mealy). Isto ficará mais claro no exemplo.</p>
<h2>Procurando estados equivalentes</h2>
<p>Com a tabela de implicação construída, devemos procurar os estados equivalentes. Isto é feito de forma exaustiva, analisando todas as células da tabela.</p>
<ol>
<li>Risque todas as transições que vão para o mesmo estado e produzem a mesma saída (tipo s-s), pois elas são naturalmente equivalentes. E.g. se você tem uma transição 0-0, risque-a pois não é preciso analisá-la.</li>
<li>Elimine as células com estados (Moore) ou transições (Mealy) que produzem saídas diferentes. Estes estados nunca poderão ser equivalentes.</li>
<li>Analise uma célula qualquer que não tenha todas as transições riscadas e que não tenha sido eliminada anteriormente. Esta célula é uma candidata a equivalência.<ul>
<li>Olhe todas as linhas da célula que não foram riscadas no passo (1). Para cada uma, analise a célula alvo. E.g. se a transição marca 1-2, você deve analisar a célula correspondente aos estados S1 e S2.</li>
<li>Se a célula alvo estiver eliminada, você deve eliminar esta célula também.</li>
<li>Se você analisou todas as linhas e não eliminou a célula, não faça nada.</li>
</ul>
</li>
<li>Repita o (3) até que todas as células tenham sido analisadas.</li>
</ol>
<p>Note que este processo é exaustivo. Para não correr o risco de analisar a mesma célula várias vezes, aconselho começar pela célula mais a direita inferior e depois passar para a segunda mais a direita inferior, e assim por diante. Não faz diferença a ordem em que você analisa as células, mas você deve se organizar para não repetir células.</p>
<p>Durante a análise, pode acontecer de você eliminar uma linha inteira ou uma coluna inteira. Isso significa que o estado daquela linha ou coluna não é equivalente a nenhum outro estado, portanto você deve eliminar todas as células que tem alguma linha referenciando aquele estado. E.g. se você eliminou a linha toda do S3, você deve eliminar todas as células que possuam ao menos um 3 em alguma linha (x-3 ou 3-x).</p>
<p>Você não precisa analisar células onde todas as linhas tenham sido riscadas no passo 1. Se você riscar todas as linhas de uma célula, os estados desta célula (linha-coluna) são automaticamente equivalentes. Você não precisa tomar nenhuma ação em relação a isso, apenas pule a análise da célula.</p>
<p>Quando você terminar este processo, as células que você não eliminou representam <strong>classes de equivalência</strong>. Uma classe de equivalência é um grupo de estados que são equivalentes e, consequentemente, podem ser representados por um único estado. E.g. se a célula da linha 3 coluna 4 não foi eliminada, os estados S3 e S4 são equivalentes.</p>
<h2>Exemplo 1/2</h2>
<p>Suponha a mesma máquina de estados usada como exemplo no método de análise da tabela de transição de estados, mostrada na figura. Trata-se de uma máquina de Mealy que reconhece 0011 ou 1001 sem sobreposição.</p>
<p><img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"></p>
<p>A máquina tem 15 estados, portanto temos uma matriz 15x15. A tabela de implicação, já com os valores das transições preenchidos e com as transições s-s riscadas, pode ser vista na figura abaixo. Isto corresponde à construção da tabela de implicação e à execução do passo 1 do algoritmo.</p>
<p><img alt="Tabela exemplo 1 passo 1" src="https://balbertini.github.io/images/sd/sdfsmoptex1a.png"></p>
<p>No passo 2, devemos eliminar as transições que produzem saídas diferentes. Note que esta é uma máquina de Mealy, então coloquei a saída na transição (e.g. nos estados S8 e S11, que são os que produzem saída, há transições na forma 0/1, indicando que esta transição produz saída 1). Quando não está especificada, assume-se que a saída é 0. Continuando o passo 2, devemos eliminar todas as células que contém uma transição s-t onde a saída de s é diferente da saída de t. Exemplo: a célula S14-S11 possui a segunda linha como 0/1-0, o que significa que, apesar de irem para o mesmo estado, uma produz saída 1 (0/1) e outra produz saída 0 (0/0, o /0 é implícito), portanto devemos eliminar esta célula toda. Isto pode ser visto na figura abaixo, onde as células eliminadas foram identificadas com fundo cinza.</p>
<p><img alt="Tabela exemplo 1 passo 2" src="https://balbertini.github.io/images/sd/sdfsmoptex1b.png"></p>
<p>O passo 2 eliminou os estados que trivialmente não são equivalentes. Podemos então começar o passo 3 analisando cada célula. Eu comecei pela célula mais a direita inferior e continuei analisando para a esquerda. A célula S14-S13 não precisa ser analisada pois tem todas as transições riscadas. Idem para a célula S14-S12. Já a célula S14-S11 foi eliminada anteriormente e também não precisa ser analisada.</p>
<p>A primeira célula que realmente precisa ser analisada é a S14-S6. Nesta célula, a transição 13-0 aponta para a a célula S13-S0, e a transição 14-0 para a célula S14-S0. Estas células alvo ainda indicam equivalência, então não fiz nada na célula em análise (S14-S6). Idem para S14-S5 e S14-S4.</p>
<p>Já na célula S14-S3, encontrei uma referência à S8-S0, que já foi eliminado em um passo anterior. Isso significa que eu devo eliminar esta célula. Nesse ponto, percebi que a linha do S8 estava inteira eliminada, então eliminei na tabela todas as células que fazem referência a S8. Na figura abaixo, a célula em análise (S14-S3) está em amarelo, a célula referenciada que foi o motivo da eliminação (S8-S0) está com borda amarela, e as células que eu eliminei estão em amarelo escuro. Apesar de ter usado cores, todas estas células devem ser pintadas de cinza (quando estiver executando o algoritmo no papel, faça um X na célula toda).</p>
<p><img alt="Tabela exemplo 1 passo 3" src="https://balbertini.github.io/images/sd/sdfsmoptex1c.png"></p>
<p>Se está lendo com cuidado, deve ter percebido que a eliminação feita na figura anterior eliminou o estado S3 inteiro. Isto significa que você pode eliminar todas as células que contém transições que referenciam o S3, pois ele não pode ser equivalente a nenhum outro estado. Se você continuar o algoritmo, terminará com a tabela de implicação abaixo, onde as células eliminadas estão em cinza.</p>
<p><img alt="Tabela exemplo 1 fim" src="https://balbertini.github.io/images/sd/sdfsmoptex1d.png"></p>
<p>Com o algoritmo finalizado, podemos inferir os estados equivalentes observando as células que não foram eliminadas. A célula S6-S4 indica que estes dois estados são equivalentes. Similarmente, a coluna S7 indica que os estados S7, S9, S10, S12, S13 e S14 são todos equivalentes. Isso pode ser corroborado pelas colunas do S9, S10, S11, S12 e S13, que indicam também esta equivalência. Ainda, a célula S11-S8 indica que estes estados são equivalentes (note que eles produzem saída 1).</p>
<p>Para facilitar a visualização, a figura abaixo traz as classes de equivalência coloridas. Para a mesma cor, os estados são equivalentes.</p>
<p><img alt="Tabela exemplo 1 colorida" src="https://balbertini.github.io/images/sd/sdfsmoptex1e.png"></p>
<p><img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="45%" align="right" style="padding-left:5%" />
Por último, devemos reconstruir o diagrama de transição de estados. Para cada classe de equivalência, criamos um estado novo. As transições e as saídas podem ser copiadas de qualquer um dos estados da classe, pois eles são equivalentes (para as mesmas entradas, produzem a mesma saída e transicionam para o mesmo estado). Note que este método agrupa os estados em classes, então a transição do Sb (que é composto por S4 e S6) que vai para o S9, por exemplo, deve ir para o estado Sa (que é composto por S7, S9, S10, S12, S13 e S14) pois esta é a classe de equivalência que contém o S9. O diagrama desta tabela é idêntico ao obtido usando o método de análise da tabela de transição de estados.</p>
<div style="border: 0px; overflow: auto;width: 100%;"></div>

<h2>Exemplo 2/2</h2>
<p>A Tabela E2 é a tabela de transição de estados de uma máquina de Moore, com entrada de dois bits. Sua funcionalidade ou diagrama de transição de estados não importam neste momento, mas o diagrama equivalente pode ser visto na figura.</p>
<table class="tg" align="left">
  <tr>
    <th class="tg-baqh" colspan="5">Tabela E2</th>
  </tr>
  <tr>
    <td class="tg-zlqz" rowspan="2">E.A.</td>
    <td class="tg-zlqz" colspan="4">P.E.</td>
  </tr>
  <tr>
    <td class="tg-zlqz">00</td>
    <td class="tg-zlqz">01</td>
    <td class="tg-zlqz">10</td>
    <td class="tg-zlqz">11</td>
  </tr>
  <tr>
    <td class="tg-baqh">S0/1</td>
    <td class="tg-baqh">S0</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S2</td>
    <td class="tg-baqh">S3</td>
  </tr>
  <tr>
    <td class="tg-baqh">S1/0</td>
    <td class="tg-baqh">S0</td>
    <td class="tg-baqh">S3</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S5</td>
  </tr>
  <tr>
    <td class="tg-baqh">S2/1</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S3</td>
    <td class="tg-baqh">S2</td>
    <td class="tg-baqh">S4</td>
  </tr>
  <tr>
    <td class="tg-baqh">S3/0</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S0</td>
    <td class="tg-baqh">S4</td>
    <td class="tg-baqh">S5</td>
  </tr>
  <tr>
    <td class="tg-baqh">S4/1</td>
    <td class="tg-baqh">S0</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S2</td>
    <td class="tg-baqh">S5</td>
  </tr>
  <tr>
    <td class="tg-baqh">S5/0</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S4</td>
    <td class="tg-baqh">S0</td>
    <td class="tg-baqh">S5</td>
  </tr>
</table>

<p><img src='https://balbertini.github.io/images/sd/sdfsmoptex2diag.png' width="45%" align="right" style="padding-left:5%" /></p>
<div style="border: 0px; overflow: auto;width: 100%;"></div>

<p>Nas tabelas abaixo podemos ver a tabela construída e com o passo 1 executado (esquerda) e após o passo 2 executado (direita).</p>
<p><img src='https://balbertini.github.io/images/sd/sdfsmoptex2a.png' width="50%" align="left" />
<img src='https://balbertini.github.io/images/sd/sdfsmoptex2b.png' width="50%" align="right"/></p>
<div style="border: 0px; overflow: auto;width: 100%;"></div>

<p>Nas tabelas abaixo, podemos ver a tabela de implicação após o passo 3 executado a exaustão (esquerda) e com as classes de equivalência construídas (direita). Na tabela da esquerda, as linhas que provocaram a exclusão da tabela foram realçadas com um cinza escuro.</p>
<p><img src='https://balbertini.github.io/images/sd/sdfsmoptex2c.png' width="50%" align="left" />
<img src='https://balbertini.github.io/images/sd/sdfsmoptex2d.png' width="50%" align="right"/></p>
<div style="border: 0px; overflow: auto;width: 100%;"></div>

<p>Pela tabela, podemos inferir que os estados S4 e S0 (Sa) são equivalentes entre si, assim como os estados S5 e S3 (Sb). A tabela de transição de estados minimizada e o diagrama de transição de estados minimizado podem ser vistos abaixo. A máquina original possuía 6 estados, o que exige 3 <em>flip-flops</em> para sua implementação, mas a minimizada tem 4 estados, o que exige 2 <em>flip-flops</em>, portanto economizamos um <em>flip-flop</em> apenas minimizando a máquina.</p>
<table class="tg" align="left">
  <tr>
    <th class="tg-baqh" colspan="5">Tabela E2 min</th>
  </tr>
  <tr>
    <td class="tg-zlqz" rowspan="2">E.A.</td>
    <td class="tg-zlqz" colspan="4">P.E.</td>
  </tr>
  <tr>
    <td class="tg-zlqz">00</td>
    <td class="tg-zlqz">01</td>
    <td class="tg-zlqz">10</td>
    <td class="tg-zlqz">11</td>
  </tr>
  <tr>
    <td class="tg-vswx">Sa/1</td>
    <td class="tg-bolj">Sa</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-baqh">S2</td>
    <td class="tg-mfhl">Sb</td>
  </tr>
  <tr>
    <td class="tg-baqh">S1/0</td>
    <td class="tg-bolj">Sa</td>
    <td class="tg-mfhl">Sb</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-mfhl">Sb</td>
  </tr>
  <tr>
    <td class="tg-baqh">S2/1</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-mfhl">Sb</td>
    <td class="tg-baqh">S2</td>
    <td class="tg-bolj">Sa</td>
  </tr>
  <tr>
    <td class="tg-fcno">Sb/0</td>
    <td class="tg-baqh">S1</td>
    <td class="tg-bolj">Sa</td>
    <td class="tg-bolj">Sa</td>
    <td class="tg-mfhl">Sb</td>
  </tr>
</table>

<p><img src='https://balbertini.github.io/images/sd/sdfsmoptex2diagmin.png' width="45%" align="right" style="padding-left:5%" /></p>
<div style="border: 0px; overflow: auto;width: 100%;"></div>

<p><p/>
[1] DE VRIES, A. Finite automata: Behavior and synthesis. Elsevier, 2014.<br>
[2] KAM, Timothy et al. Synthesis of finite state machines: functional optimization. Springer Science &amp; Business Media, 2013.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>

   <div>
     Última atualização: 2018-09-26 18:02:00-03:00
   </div>


  <div class="tag-cloud">
    <p>
      <a href="https://balbertini.github.io/tag/sistemas-digitais.html">sistemas digitais</a>
      <a href="https://balbertini.github.io/tag/fsm.html">fsm</a>
      <a href="https://balbertini.github.io/tag/simplificacao.html">simplificação</a>
      <a href="https://balbertini.github.io/tag/otimizacao.html">otimização</a>
    </p>
  </div>





<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'balbertini';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Habilite JavaScript para ver os comentários.
</noscript>
<!-- End Disqus -->
</article>

    <footer>
<p>
  &copy; Bruno Albertini  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - O tema <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> foi criado por <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " B.Albertini's site ",
  "url" : "https://balbertini.github.io",
  "image": "",
  "description": ""
}
</script>

</body>
</html>