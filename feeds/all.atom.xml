<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>B.Albertini's site</title><link href="https://balbertini.github.io/" rel="alternate"></link><link href="https://balbertini.github.io/feeds/all.atom.xml" rel="self"></link><id>https://balbertini.github.io/</id><updated>2018-10-09T23:39:00-03:00</updated><entry><title>Exercício: Análise de Circuitos Realimentados</title><link href="https://balbertini.github.io/er0001-pt_BR.html" rel="alternate"></link><published>2018-10-09T14:38:00-03:00</published><updated>2018-10-09T23:39:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-09:/er0001-pt_BR.html</id><summary type="html">&lt;p&gt;Exercício resolvido de sistemas digitais: análise de circuitos realimentados.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Assunto: Análise de circuitos realimentados&lt;/p&gt;
&lt;h2&gt;Enunciado&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTnoReset.png' align="left" width="35%" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;p&gt;O circuito ao lado é um circuito digital sequencial realimentado, com entradas T e C, e saída Q. Analise-o por completo, apresentando:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As equações de excitação e saída;&lt;/li&gt;
&lt;li&gt;A tabela de transição de estados e saída;&lt;/li&gt;
&lt;li&gt;Análise de corridas (e classificação se houve);&lt;/li&gt;
&lt;li&gt;A tabela de fluxo e saída;&lt;/li&gt;
&lt;li&gt;O diagrama de transição de estados da máquina.&lt;/li&gt;
&lt;/ul&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Solução&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTvBuffers.png' align="right" width="35%" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;p&gt;Vamos começar colocando os buffers virtuais, como na figura ao lado. Já aproveitei e nomeei todas as conexões existentes para facilitar o próximo passo: a extração das equações.&lt;/p&gt;
&lt;div class="math"&gt;$$
I=\overline{T.C.Y_2}\\
J=\overline{\overline{T}.\overline{C}.\overline{Y_2}}\\
K=\overline{\overline{T}.\overline{C}.Y_2}\\
L=\overline{T.C.\overline{Y_2}}\\
M=\overline{Y_1.K.L}\\
N=\overline{T.\overline{C}.\overline{Y_1}}\\
O=\overline{T.\overline{C}.Y_1}\\
P=\overline{Y_2.O}
$$&lt;/div&gt;
&lt;p&gt;Resolvendo &lt;span class="math"&gt;\(M\)&lt;/span&gt; e &lt;span class="math"&gt;\(P\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
M=\overline{Y_1.K.L}=\overline{Y_1.\overline{\overline{T}.\overline{C}.Y_2}.\overline{T.C.\overline{Y_2}}}=\overline{Y_1.(T+C+\overline{Y_2}).(\overline{T}+\overline{C}+Y_2)}\\
 =\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}\\
P=\overline{Y_2.O}=\overline{Y_2.\overline{T.\overline{C}.Y_1}}=\overline{Y_2.(\overline{T}+C+\overline{Y_1})}=\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}
$$&lt;/div&gt;
&lt;p&gt;E finalmente resolvendo &lt;span class="math"&gt;\(Y_1^*\)&lt;/span&gt; e &lt;span class="math"&gt;\(Y_2^*\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
Y_1^*=\overline{I.J.M}\\
=\overline{\overline{T.C.Y_2}.\overline{\overline{T}.\overline{C}.\overline{Y_2}}.\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}}\\
=T.C.Y_2+\overline{T}.\overline{C}.\overline{Y_2}+T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}\\
Y_2^*=\overline{N.P}=\overline{\overline{T.\overline{C}.\overline{Y_1}}.\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}}\\
=T.\overline{C}.\overline{Y_1}+\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2\\
$$&lt;/div&gt;
&lt;p&gt;O próximo passo é preencher a tabela de transição de estados e saída. A tabela preenchida pode ser vista abaixo, para &lt;span class="math"&gt;\(Y_1^*Y_2^*\)&lt;/span&gt;. Os estados contornados são estados estáveis, ou seja, não há mudança de estado para aquela entrada. Também podemos ver a tabela de fluxo, com as saídas.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabelas de transição de estados e de fluxo, com saídas" src="https://balbertini.github.io/images/sd/er/er0001_tranTable.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/er0001_diagrama.png' align="right" width="35%" style="padding-left:5%" /&gt;
Por último, montamos o diagrama de transição de estados, que fica conforme a figura ao lado.&lt;/p&gt;
&lt;p&gt;A análise de comportamento é opcional, mas é relativamente fácil perceber que se trata de um &lt;em&gt;flip-flop&lt;/em&gt; tipo T sensível a borda de descida. A análise pode ser feita da seguinte forma: começa-se no estado &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; (pode ser qualquer estado) e analisa-se o comportamento das entradas. Percebe-se que, a única maneira de sair desse estado é se a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; for zero, de onde conclui-se que o circuito é algo que espera esta entrada virar zero. Nota-se ainda que, quando isso acontece, a saída muda caso a entrada &lt;span class="math"&gt;\(T\)&lt;/span&gt; seja um, caso contrário não muda. Todos os estados "seguram" a borda da entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt;, ou seja, independentemente se formos para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; ou &lt;span class="math"&gt;\(S_2\)&lt;/span&gt; a partir do &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; não altera mais o comportamento da máquina exceto se for para um e depois para zero novamente. Poderíamos dizer que os estados tem estas funções:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_0\)&lt;/span&gt;: saída zero, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;: saída um, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;: saída zero, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_3\)&lt;/span&gt;: saída um, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Repare que o efeito &lt;em&gt;toggle&lt;/em&gt; só acontece nas arestas horizontais, de &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; e de &lt;span class="math"&gt;\(S_3\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_2\)&lt;/span&gt;.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="exercícios resolvidos"></category><category term="análise"></category><category term="circuitos realimentados"></category></entry><entry><title>Arquitetura</title><link href="https://balbertini.github.io/vhdlarchitecture-pt_BR.html" rel="alternate"></link><published>2018-10-04T10:33:00-03:00</published><updated>2018-10-05T00:47:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-04:/vhdlarchitecture-pt_BR.html</id><summary type="html">&lt;p&gt;Arquiteturas em VHDL.&lt;/p&gt;</summary><content type="html">&lt;p&gt;As descrições em VHDL sempre possuem uma &lt;a href="https://balbertini.github.io/vhdlentity-pt_BR.html"&gt;entidade&lt;/a&gt;, que define as interfaces do módulo descrito. Porém, a entidade não descreve a funcionalidade, que é descrita na arquitetura.&lt;/p&gt;
&lt;p&gt;Assim como a entidade é a &lt;em&gt;cara&lt;/em&gt; do módulo que está descrevendo, a arquitetura, declarada pela palavra reservada &lt;code&gt;architecture&lt;/code&gt;, é o &lt;em&gt;corpo&lt;/em&gt; da sua descrição. Na arquitetura é onde descrevemos a funcionalidade do componente, ou seja, onde as coisas realmente acontecem. No diagrama esquemático, seria o equivalente de mostrar o que tem dentro do símbolo do seu componente.&lt;/p&gt;
&lt;p&gt;Faz sentido descrever um componente com entradas e saídas mas sem nada dentro? Claro que não, por isso toda entidade deve ter ao menos uma arquitetura pois, sem ela, o componente não tem função. É possível que uma entidade tenha varias arquiteturas, cada uma realizando a tarefa que seu componente se propõe a fazer de uma maneira diferente. Contudo, uma arquitetura só pode pertencer a uma entidade. De fato, todas as arquiteturas pertencentes a uma entidade devem estar no mesmo arquivo que ela, depois da declaração da entidade.&lt;/p&gt;
&lt;p&gt;A sintaxe de uma arquitetura em VHDL é:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;architecture&lt;/span&gt; &lt;span class="nc"&gt;nome_da_arquitetura&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;nome_da_entidade&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="n"&gt;declaracoes&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;declaracoes_combinatorias&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;nome_da_arquitetura&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Onde &lt;code&gt;declaracoes&lt;/code&gt; é a lista de elementos que serão utilizados na sua arquitetura, como sinais e componentes. As &lt;code&gt;declaracoes_combinatorias&lt;/code&gt; são todas as declarações concorrentes desta descrição, como uma atribuição (condicional ou não), uma instância de componente ou um &lt;code&gt;process&lt;/code&gt;. O &lt;code&gt;nome_da_arquitetura&lt;/code&gt; pode ser qualquer nome válido em VHDL, e o &lt;code&gt;nome_da_entidade&lt;/code&gt; deve ser o nome da entidade que esta arquitetura descreve.&lt;/p&gt;
&lt;p&gt;Como uma entidade pode ter mais de uma arquitetura, é comum termos um arquivo VHDL com várias arquiteturas pertencentes a mesma entidade. Isso é útil pois podemos ter o mesmo componente descrito de maneiras diferentes (e.g. otimizado para velocidade, consumo de energia ou área, descrito especificamente para uma tecnologia (ASIC, FPGA, etc.), ou até mesmo com estilos de descrição diferentes). Não há uma convenção, mas se não for utilizado nenhum mecanismo explícito para escolher uma das arquiteturas disponíveis, a maioria dos softwares de síntese utiliza a última arquitetura encontrada no arquivo.&lt;/p&gt;
&lt;h2&gt;Escolha explícita da arquitetura&lt;/h2&gt;
&lt;p&gt;A entidade, exceto se for uma entidade &lt;em&gt;toplevel&lt;/em&gt; (entidade máxima, que representa o circuito como um todo), sempre será usada como componente por uma arquitetura pertencente a outra entidade. Na prática, isso significa que há uma entidade raiz, que representa o circuito todo e possui ao menos uma arquitetura. Nesta  arquitetura, outras entidades filhas podem usadas como componentes para formar o circuito. Cada entidade filha usada pode usar outras como componente e assim por diante, criando uma árvore.&lt;/p&gt;
&lt;p&gt;Considerando que o componente já foi declarado corretamente, há duas possibilidades de instância. Sem escolher qual arquitetura, a instância segue a seguinte sintaxe:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;nome_da_intancia&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;nome_da_entidade&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nome_da_arquitetura&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;generic&lt;/span&gt; &lt;span class="k"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atribuicao_de_parametros&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="k"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atribuicao_de_portas&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Isto fará com que o sintetizador escolha a última arquitetura descrita (ou a que for configurada no sintetizador). Contudo, esta sintaxe existe pois, na maioria das vezes, as entidades só possuem uma arquitetura. Você pode fazer uma escolha explícita da arquitetura, prática recomendada caso a entidade possua mais de uma. Para isso, basta modificar a declaração da instância para a sintaxe completa, como abaixo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;nome_da_intancia&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;work&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nome_da_entidade&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nome_da_arquitetura&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;generic&lt;/span&gt; &lt;span class="k"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atribuicao_de_parametros&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="k"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atribuicao_de_portas&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A palavra reservada &lt;code&gt;work&lt;/code&gt; faz referência ao pacote de trabalho local, onde se encontram todas as entidades que foram desenvolvidas por você e não foram colocadas em um pacote. Caso você tenha colocado sua entidade em um pacote ou esteja usando uma entidade que você não fez e que está em um pacote, deve substituir &lt;code&gt;work&lt;/code&gt; pelo pacote onde a entidade se encontra.&lt;/p&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/mux2to1_arquitetura.png' width="39%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;mux2to1&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;    &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="k"&gt;out&lt;/span&gt;   &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;mux2to1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;architecture&lt;/span&gt; &lt;span class="nc"&gt;whenelse&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;mux2to1&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;whenelse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;architecture&lt;/span&gt; &lt;span class="nc"&gt;struct&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;mux2to1&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Acima, vemos um componente com duas arquiteturas, representadas tanto na descrição VHDL quanto na representação gráfica. Note que o componente possui uma entidade externa camada &lt;code&gt;mux2to1&lt;/code&gt;, que define as interfaces de entrada e saída. Por dentro, tem duas arquiteturas, que definem o comportamento do componente de duas maneiras distintas. Por padrão, se não especificarmos explicitamente, o software de síntese irá considerar a última arquitetura descrita como sendo a que ele deve utilizar, por isso ligamos as interfaces do desenho na arquitetura padrão.&lt;/p&gt;
&lt;p&gt;A arquitetura padrão nesse caso é a última descrita, chamada &lt;code&gt;struct&lt;/code&gt;, e descreve estruturalmente o multiplexador usando portas lógicas. Note que o nome &lt;code&gt;struct&lt;/code&gt; não é uma palavra reservada e sim um identificador válido em VHDL, portanto poderia ser qualquer outro. É recomendado que o nome da arquitetura reflita o que foi feito, nesse caso uma descrição estrutural. Podemos escolher a outra arquitetura se desejarmos, que é chamada de &lt;code&gt;whenelse&lt;/code&gt;. Note que ambas fazem a mesma coisa, mas de maneiras diferentes.&lt;/p&gt;
&lt;p&gt;No exemplo abaixo, temos a descrição de uma arquitetura pertencente a uma &lt;code&gt;entidade_mae&lt;/code&gt; que utiliza o multiplexador como componente três vezes. Na instância &lt;code&gt;mux1&lt;/code&gt;, a arquitetura é deixada a escolha do sintetizador, portanto será a arquitetura &lt;code&gt;struct&lt;/code&gt;. Na instância &lt;code&gt;mux2&lt;/code&gt;, a arquitetura utilizada ainda é a struct, mas dessa vez instruímos explicitamente o sintetizador a utilizá-la. Por último, na instância &lt;code&gt;mux3&lt;/code&gt; o projetista escolheu explicitamente a arquitetura &lt;code&gt;whenelse&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;architecture&lt;/span&gt; &lt;span class="nc"&gt;muxes&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;entidade_mae&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
  &lt;span class="k"&gt;component&lt;/span&gt; &lt;span class="nc"&gt;mux2to1&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;    &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="k"&gt;out&lt;/span&gt;   &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;component&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
  &lt;span class="n"&gt;mux1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mux2to1&lt;/span&gt; &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="k"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;mux2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;work&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mux2to1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="k"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;mux3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;work&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mux2to1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;whenelse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="k"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;muxes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Lembre-se que esta é a descrição de um hardware, portanto as três instâncias são três circuitos &lt;strong&gt;diferentes&lt;/strong&gt;, cada um com seu próprio arranjo de portas lógicas. A diferença é que o &lt;code&gt;mux1&lt;/code&gt; e o &lt;code&gt;mux2&lt;/code&gt; são idênticos, ou seja, se você observar o circuito gerado, são duas cópias do mesmo circuito. O &lt;code&gt;mux3&lt;/code&gt;, apesar de ter mesma funcionalidade, é diferente. Se você sintetizar o circuito acima para um circuito real em silício, poderá ver em um microscópio duas áreas idênticas e uma diferente, todas recebendo as mesmas entradas e cada uma com sua própria saída. &lt;strong&gt;Nota:&lt;/strong&gt; este parágrafo é uma simplificação didática, se tiver conhecimento de síntese de ASICs e quiser saber mais detalhes do que acontece durante a síntese, me escreva.&lt;/p&gt;
&lt;p&gt;Quando a entidade possui diversas arquiteturas, se uma determinada arquitetura não for escolhida por nenhuma instância, o sintetizador não a considerará. Isso significa que não será gerado nenhum circuito para aquela arquitetura, portanto ter várias arquiteturas não significa que o circuito gerado irá gastar mais energia ou ocupar mais área, pois só as arquiteturas utilizadas serão de fato sintetizadas.&lt;/p&gt;</content><category term="vhdl"></category><category term="basic"></category></entry><entry><title>Simplificação de FSM</title><link href="https://balbertini.github.io/fsmstatereduction-pt_BR.html" rel="alternate"></link><published>2018-09-25T14:22:00-03:00</published><updated>2018-09-26T22:49:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-25:/fsmstatereduction-pt_BR.html</id><summary type="html">&lt;p&gt;Como fazer simplificação de estados em máquinas de estados finitas.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A máquina de estados finita em sistemas digitais, quando realizada na forma de um circuito digital, utiliza recursos computacionais (e.g. &lt;em&gt;flip-flops&lt;/em&gt;, memórias, portas lógicas, etc.) que são caros do ponto de vista de área e consumo de energia, principalmente se a máquina possuir muitos estados. Por este motivo, é importante minimizar o número de estados da máquina para que, na implementação, utilizemos somente os recursos mínimos necessários para aquela máquina. Além disso, quando estamos projetando uma máquina de estados para resolver um problema, é mais confortável não pensar em otimizações mas sim na funcionalidade da máquina, para só depois pensar na otimização. De fato, a maioria dos projetistas comerciais não pensa na otimização quando estão modelando o problema pois isso nem sempre é possível (i.e. o projetista não tem visão da máquina toda mas sim da parte cabível a ele, a máquina é muito grande tornando impossível pensar em tudo, a máquina é particionada, etc).&lt;/p&gt;
&lt;p&gt;Na prática, com os sintetizadores modernos, você pode especificar sua máquina usando a linguagem de descrição de hardware de sua preferência e deixar o sintetizador otimizá-la para você. Os resultados da otimização automática são bons quando comparados aos métodos manuais [1,2]. Contudo, é necessário conhecer o mínimo do funcionamento dos algoritmos de minimização pois, quando for descrever sua máquina, você conhecerá ao menos o básico do que acontecerá quando sintetizá-la. Neste artigo, explicarei os métodos de minimização por identificação direta na tabela de transição de estados e por tabela de implicação. Em ambos os casos, o objetivo principal é encontrar estados equivalentes, ou seja, que &lt;strong&gt;para a mesma entrada, produzem a mesma saída e transicionam para os mesmos estados.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Minimização através da tabela de transição&lt;/h2&gt;
&lt;p&gt;Em muitos casos, é fácil identificar os estados equivalentes na tabela de transição de estados, por isso este método também é chamado de &lt;strong&gt;observação direta&lt;/strong&gt; ou &lt;strong&gt;casamento de linhas&lt;/strong&gt;. O algoritmo é simples:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Elimine todos os estados inalcançáveis (estados onde não chega nenhuma aresta partindo de outro estado alcançável).&lt;/li&gt;
&lt;li&gt;Identifique dois estados A e B que, para a mesma entrada, produzam exatamente a mesma saída e realizem a mesma transição (transicionem para o mesmo estado).&lt;/li&gt;
&lt;li&gt;Elimine um dos estados (e.g. B) apagando a linha correspondente a este estado e substitua todas as ocorrências de B por A (i.e. todos as transições para B agora devem apontar para A).&lt;/li&gt;
&lt;li&gt;Repita até que nenhum par de estados atenda (2).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;Uma forma muito comum de projetar máquinas de estados é modelando-a como árvore, onde cada ramificação é uma tomada de decisão. Tomemos a máquina abstrata a seguir que foi montada partindo de uma árvore binária canônica e modificada para reconhecer as sequencias 0011 e 1001:&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;Em vermelho está destacado o caminho que esta máquina irá seguir para reconhecer as duas sequencias. Note que esta é uma máquina de Mealy e não leva em consideração nenhuma sobreposição entre as sequencias detectadas, ou seja, ela só funciona para entradas de 4 bits agrupados a partir do &lt;em&gt;reset&lt;/em&gt; (e.g. detecta duas vezes se a entrada for 0011 1001 mas não detecta a segunda vez se a entrada for 0011 001).&lt;/p&gt;
&lt;p&gt;A tabela de transição de estados fica como na Tabela 1 a seguir.&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0px;margin-right:10px;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-3r9o{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-4m7p{background-color:#9aff99;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-uuae{background-color:#67fd9a;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-fcno{background-color:#fcff2f;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-bolj{background-color:#ffccc9;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-mfhl{background-color:#ffffc7;border-color:inherit;text-align:center;vertical-align:top}
&lt;/style&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela 1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S7/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S9/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S10/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S12/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S6&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S13/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S14/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S7&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S8&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S9&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S10&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S11&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S12&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S13&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S14&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S4&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S6&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S8&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S11&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 3&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sc&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A coluna &lt;strong&gt;E.A.&lt;/strong&gt; mostra o estado atual, e a coluna &lt;strong&gt;P.E.&lt;/strong&gt; o próximo estado. Esta última é bipartida para as entradas igual a &lt;strong&gt;0&lt;/strong&gt; e igual a &lt;strong&gt;1&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A Tabela 1 possui todas as transições da árvore como vista na figura. Esta máquina não tem nenhum estado inalcançável, então não há o que eliminar no passo 1.&lt;/p&gt;
&lt;p&gt;No passo 2, devemos procurar as equivalências. É fácil perceber que há estados que produzem exatamente o mesmo resultado (transição e saída) para determinada entrada. Tomemos por exemplo os estados S7, S9, S10, S12, S13 e S14: todos transicionam para S0 e produzem saída 0 para qualquer entrada, portanto são equivalentes. Podemos reduzir a tabela substituindo todos estes estados por um estado Sa, o que podemos ver na Tabela 2, destacado em verde.&lt;/p&gt;
&lt;p&gt;Se fizermos a busca novamente, os estados S4 e S6 agora são equivalentes pois ambos transicionam para Sa e produzem saída 0, independententemente da entrada. Criamos o estado Sb, em vermelho, para substituir estes estados. Similarmente os estados S8 e S11 são equivalentes, mas note que eles tem saídas diferentes para entradas diferentes. Para este conjunto de estados, criamos Sc, em amarelo. Não há mais estados equivalentes e o resultado final pode ser visto na Tabela 3.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="35%" align="right" style="padding-left:5%" /&gt;
&lt;br/&gt;
O diagrama de transição de estados minimizado pode ser visto na figura ao lado. Os estados S7, S9, S10, S12, S13 e S14 são representados pelo Sa, S4 e S6 pelo Sb e S8 e S11 pelo Sc.&lt;/p&gt;
&lt;p&gt;O método de análise da tabela de transição de estados se baseia na busca exaustiva por estados equivalentes. É fácil perceber que, conforme a tabela cresce, ficará mais difícil visualizar os estados equivalentes. Além disso, o método não garante a menor quantidade de estados possível pois é baseado em estados e não em grupos de estados (veja o primeiro exemplo da próxima seção).&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;O método de minimização por tabela de implicação&lt;/h2&gt;
&lt;p&gt;Nem sempre é tão fácil perceber a equivalência de estados através da tabela de transição de estados, especialmente para máquinas grandes ou com muitas entradas. No entanto, os projetistas desenvolveram um método chamado de tabela de implicação. Este método é equivalente à análise através da tabela de transição de estados, porém é algorítmico e está organizado em forma de uma matriz, o que minimiza erros por parte do projetista. Além disso, apesar de ambos os métodos serem exaustivos, há uma diferença primordial: enquanto o método de análise da tabela de transição de estados procura exaustivamente estados equivalentes, o método da tabela de implicação procura exaustivamente os estados que &lt;strong&gt;não são equivalentes&lt;/strong&gt;. Parte-se da premissa de que todos os estados são equivalentes entre si e, a cada iteração, elimina-se os estados que não podem ser equivalentes. Os estados que sobrarem são equivalentes.&lt;/p&gt;
&lt;p&gt;Há dois momentos no método da tabela de implicação: a construção da tabela e a análise.&lt;/p&gt;
&lt;h3&gt;Construção da matriz (tabela)&lt;/h3&gt;
&lt;p&gt;A matriz pode ser construída como uma matriz &lt;span class="math"&gt;\(n\)&lt;/span&gt; por &lt;span class="math"&gt;\(n\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(n\)&lt;/span&gt; é o número de estados (se você começar no &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, o último estado será &lt;span class="math"&gt;\(S_{n-1}\)&lt;/span&gt;). Cada linha &lt;span class="math"&gt;\(i\)&lt;/span&gt; da matriz representa um estado e cada coluna &lt;span class="math"&gt;\(j\)&lt;/span&gt; também.&lt;/p&gt;
&lt;p&gt;Não faz sentido analisar a equivalência de um estado com ele mesmo, pois um estado sempre é equivalente a ele mesmo. Por este motivo, eliminamos a diagonal da matriz, onde &lt;span class="math"&gt;\(i=j\)&lt;/span&gt;. As metades diagonais superiores e inferiores significam a mesma coisa pois se uma célula &lt;span class="math"&gt;\(X_{ij}\)&lt;/span&gt; mostra equivalência entre o estado &lt;span class="math"&gt;\(S_i\)&lt;/span&gt; e o estado &lt;span class="math"&gt;\(S_j\)&lt;/span&gt;, a célula &lt;span class="math"&gt;\(X_{ji}\)&lt;/span&gt; também deve mostrar a mesma equivalência. Por este motivo, eliminamos também uma das metades diagonais. Por convenção, elimina-se a diagonal superior, mas o resultado é o mesmo se você eliminar a metade diagonal inferior.&lt;/p&gt;
&lt;p&gt;Quando estiver confortável com a construção da matriz, você poderá desenhá-la já sem a diagonal e sem a metade diagonal superior. A esse desenho contendo somente a metade diagonal inferior da tabela, chamamos de &lt;strong&gt;tabela de implicação&lt;/strong&gt;. Na figura abaixo mostramos a matriz inteira, a matriz destacando a linha diagonal (vermelha) e a metade diagonal superior (laranja), e finalmente a tabela de implicação.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Construção da tabela de implicação." src="https://balbertini.github.io/images/sd/sdfsmoptconsttab.png"&gt;&lt;/p&gt;
&lt;p&gt;Após obter a tabela de implicação, devemos preencher as células. Cada célula terá &lt;span class="math"&gt;\(2^b\)&lt;/span&gt; linhas, onde &lt;span class="math"&gt;\(b\)&lt;/span&gt; é o número de bits da entrada. E.g. se a entrada for de 1 bit, cada célula tem 2 linhas; se a entrada for de 2 bits, cada célula tem 4 linhas. Cada linha da entrada corresponde às transições daqueles estados para aquela entrada.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptconstcel.png' width="45%" align="right" style="padding-left:5%" /&gt;
Na figura podemos ver o exemplo do preenchimento para duas células, ambas na linha do S3 e coluna do S4. Para simplificar o preenchimento, usamos somente o número do estado, mas você pode escrever o nome completo do estado (especialmente útil se os nomes dos estados não forem numerados).&lt;/p&gt;
&lt;p&gt;Na célula na esquerda na figura, a entrada tem 1 bit, portanto temos duas linhas, uma para a entrada 0 e outra para a entrada 1. Nesta célula, a máquina é de Mealy com saída de 1 bit, que pode ser vista representada nas transições.&lt;/p&gt;
&lt;p&gt;Já na célula a direita na figura, a entrada tem 2 bits, portanto temos 4 linhas para as entradas 00, 01, 10 e 11. A máquina representada é de Moore e também tem um bit só de saída, que nesse caso é representado no estado e não na transição.&lt;/p&gt;
&lt;p&gt;Os números em cada linha correspondem a transição que o estado fará para cada entrada (e à saída referente àquela transição no caso de uma máquina de Mealy). No exemplo a esquerda na figura, podemos assumir que, para uma determinada entrada e estando em S3 ou em S4, a máquina transicionará para o estado S0/0 ou S1/0 (note que em ambas as transições a saída é 0). Na mesma situação mas para a outra entrada, a máquina transicionará para o estado S2/0 ou S3/1. Mas como eu sei qual entrada? Não é preciso saber para qual entrada, apenas que as transições da mesma linha, separadas por &lt;code&gt;-&lt;/code&gt;, são para a mesma entrada. De fato, alguns projetistas preferem ordenar as transições em ordem crescente para facilitar a busca por estados equivalentes. E.g. (linha superior / linha inferior) 3-2/1-2 é o mesmo que 1-2/2-3, mas ordenado. Fica a seu critério decidir a melhor forma de organizar sua tabela de implicação, mas lembre-se que cada linha corresponde a exatamente dois estados separados por &lt;code&gt;-&lt;/code&gt;, para os quais a máquina de estados transicionará quando houver a mesma entrada.&lt;/p&gt;
&lt;p&gt;É de praxe também assinalar os estados que produzem saídas diferentes, pois eles não podem ser equivalentes. Neste caso, coloque uma &lt;code&gt;/&lt;/code&gt; no índice de coluna e linha (caso a máquina for de Moore) ou na transição dentro da célula (caso a máquina for de Mealy). Isto ficará mais claro no exemplo.&lt;/p&gt;
&lt;h2&gt;Procurando estados equivalentes&lt;/h2&gt;
&lt;p&gt;Com a tabela de implicação construída, devemos procurar os estados equivalentes. Isto é feito de forma exaustiva, analisando todas as células da tabela.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Risque todas as transições que vão para o mesmo estado e produzem a mesma saída (tipo s-s), pois elas são naturalmente equivalentes. E.g. se você tem uma transição 0-0, risque-a pois não é preciso analisá-la.&lt;/li&gt;
&lt;li&gt;Elimine as células com estados (Moore) ou transições (Mealy) que produzem saídas diferentes. Estes estados nunca poderão ser equivalentes.&lt;/li&gt;
&lt;li&gt;Analise uma célula qualquer que não tenha todas as transições riscadas e que não tenha sido eliminada anteriormente. Esta célula é uma candidata a equivalência.&lt;ul&gt;
&lt;li&gt;Olhe todas as linhas da célula que não foram riscadas no passo (1). Para cada uma, analise a célula alvo. E.g. se a transição marca 1-2, você deve analisar a célula correspondente aos estados S1 e S2.&lt;/li&gt;
&lt;li&gt;Se a célula alvo estiver eliminada, você deve eliminar esta célula também.&lt;/li&gt;
&lt;li&gt;Se você analisou todas as linhas e não eliminou a célula, não faça nada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Repita o (3) até que todas as células tenham sido analisadas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note que este processo é exaustivo. Para não correr o risco de analisar a mesma célula várias vezes, aconselho começar pela célula mais a direita inferior e depois passar para a segunda mais a direita inferior, e assim por diante. Não faz diferença a ordem em que você analisa as células, mas você deve se organizar para não repetir células.&lt;/p&gt;
&lt;p&gt;Durante a análise, pode acontecer de você eliminar uma linha inteira ou uma coluna inteira. Isso significa que o estado daquela linha ou coluna não é equivalente a nenhum outro estado, portanto você deve eliminar todas as células que tem alguma linha referenciando aquele estado. E.g. se você eliminou a linha toda do S3, você deve eliminar todas as células que possuam ao menos um 3 em alguma linha (x-3 ou 3-x).&lt;/p&gt;
&lt;p&gt;Você não precisa analisar células onde todas as linhas tenham sido riscadas no passo 1. Se você riscar todas as linhas de uma célula, os estados desta célula (linha-coluna) são automaticamente equivalentes. Você não precisa tomar nenhuma ação em relação a isso, apenas pule a análise da célula.&lt;/p&gt;
&lt;p&gt;Quando você terminar este processo, as células que você não eliminou representam &lt;strong&gt;classes de equivalência&lt;/strong&gt;. Uma classe de equivalência é um grupo de estados que são equivalentes e, consequentemente, podem ser representados por um único estado. E.g. se a célula da linha 3 coluna 4 não foi eliminada, os estados S3 e S4 são equivalentes.&lt;/p&gt;
&lt;h2&gt;Exemplo 1/3 - Moore simples&lt;/h2&gt;
&lt;p&gt;Este exemplo é de uma máquina de Moore que detecta uma paridade ímpar considerando todas as entradas que já passaram pela máquina. O diagrama e a tabela de transição de estados podem ser vistos abaixo:&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela E1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;A/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;A&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;B/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;C/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diag.png' width="13%" align="left" style="padding-left:5%; padding-right:5%"/&gt;
Tente minimizar esta máquina usando o método de análise da tabela de transição. É possível encontrar algum estado equivalente? Perceba que os estados A e C são equivalentes, mas não é possível perceber isto apenas com a tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1a.png' width="55%" align="right" style="padding-left:5%"/&gt;
Vamos construir a tabela de implicação para verificar. Na figura ao lado, podemos ver: (esquerda) a tabela de implicação construída e com os estados (note que é uma máquina de Moore, então as saídas são representadas nos estados); (meio) a tabela de implicação com as linhas de acordo com a tabela de transição de estados; e (direita) a versão com a linha B-B já riscada, pois para esta entrada, a máquina transiciona para o mesmo estado independententemente de qual estado esteja. Isto equivale à construção da tabela de implicação e à execução do primeiro passo do algoritmo.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1b.png' width="45%" align="left" style="padding-right:5%"/&gt;
No segundo passo eliminamos os estados que produzem saída diferentes, pois nunca poderão ser equivalentes. Isto pode ser visto à esquerda na figura ao lado (os estados eliminados foram destacados em cinza). Sobra a única célula a ser verificada, correspondente aos estados C/0-A/0. Esta célula tem uma linha riscada (que não precisa ser analisada) e uma linha que referencia A-C. A referência A-C aponta para a mesma célula que estamos analisando, a célula C/0-A/0. Como esta célula ainda não foi eliminada, nada resta a fazer e devemos continuar o algoritmo. Porém, não há mais células a serem analisadas, portanto o algoritmo terminou. Isso significa que a única célula que não foi eliminada será a nossa classe de equivalência, destacada em vermelho na tabela de implicação da figura.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diagmin.png' width="13%" align="left" style="padding-right:5%"/&gt;
A célula indica que a classe de equivalência contém somente dois estados, o C/0 e o A/0. Para finalizar, montamos um novo diagrama de transição de estados com um estado chamado AC/0, em vermelho, representando a classe de equivalência encontrada. As transições são transportadas dos estados da classe de equivalência e, obviamente, são esperadas que sejam as mesmas pois os estados são equivalentes. Esta máquina tem a mesma funcionalidade que a anterior, porém tem um estado a menos. Este tipo de minimização não é possível usando a análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 2/3 - Moore com entrada de 2 bits&lt;/h2&gt;
&lt;p&gt;A Tabela E2 é a tabela de transição de estados de uma máquina de Moore, com entrada de dois bits. Sua funcionalidade ou diagrama de transição de estados não importam neste momento, mas o diagrama equivalente pode ser visto na figura.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diag.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo podemos ver a tabela construída e com o passo 1 executado (esquerda) e após o passo 2 executado (direita). Note que, para minimizar o esforço em preencher a tabela e evitar poluí-la, eu eliminei o "S" e utilizei somente os índices dos estados.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2a.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2b.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo, podemos ver a tabela de implicação após o passo 3 executado a exaustão (esquerda) e com as classes de equivalência construídas (direita). Na tabela da esquerda, as linhas que provocaram a exclusão da tabela foram realçadas com um cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2c.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2d.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Pela tabela, podemos inferir que os estados S4 e S0 (Sa) são equivalentes entre si, assim como os estados S5 e S3 (Sb). A tabela de transição de estados minimizada e o diagrama de transição de estados minimizado podem ser vistos abaixo. A máquina original possuía 6 estados, o que exige 3 &lt;em&gt;flip-flops&lt;/em&gt; para sua implementação, mas a minimizada tem 4 estados, o que exige 2 &lt;em&gt;flip-flops&lt;/em&gt;, portanto economizamos um &lt;em&gt;flip-flop&lt;/em&gt; apenas minimizando a máquina.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2 min&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sa/1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sb/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diagmin.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 3/3 - Mealy com 15 estados&lt;/h2&gt;
&lt;p&gt;Suponha a mesma máquina de estados usada como exemplo no método de análise da tabela de transição de estados, mostrada na figura. Trata-se de uma máquina de Mealy que reconhece 0011 ou 1001 sem sobreposição.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;A máquina tem 15 estados, portanto temos uma matriz 15x15. A tabela de implicação, já com os valores das transições preenchidos e com as transições s-s riscadas, pode ser vista na figura abaixo. Note que esta é uma máquina de Mealy, então coloquei a saída na transição (e.g. nos estados S8 e S11, que são os que produzem saída, há transições na forma 0/1, indicando que esta transição produz saída 1). Isto corresponde à construção da tabela de implicação e à execução do passo 1 do algoritmo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 1" src="https://balbertini.github.io/images/sd/sdfsmoptex3a.png"&gt;&lt;/p&gt;
&lt;p&gt;No passo 2, devemos eliminar as transições que produzem saídas diferentes, ou seja, devemos eliminar todas as células que contém uma transição s-t onde a saída de s é diferente da saída de t. Exemplo: a célula S14-S11 possui a segunda linha como 0/1-0, o que significa que, apesar de irem para o mesmo estado, uma produz saída 1 (0/1) e outra produz saída 0 (0/0), portanto devemos eliminar esta célula toda. Isto pode ser visto na figura abaixo, onde todas as células eliminadas por este motivo foram identificadas com fundo cinza e a linha que foi o motivo da eliminação com cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 2" src="https://balbertini.github.io/images/sd/sdfsmoptex3b.png"&gt;&lt;/p&gt;
&lt;p&gt;O passo 2 eliminou os estados que trivialmente não são equivalentes. Podemos então começar o passo 3 analisando cada célula. Eu comecei pela célula mais a direita inferior e continuei analisando para a esquerda. A célula S14-S13 não precisa ser analisada pois tem todas as transições riscadas. Idem para a célula S14-S12. Já a célula S14-S11 foi eliminada anteriormente e também não precisa ser analisada.&lt;/p&gt;
&lt;p&gt;A primeira célula que realmente precisa ser analisada é a S14-S6. Nesta célula, a transição 13-0 aponta para a a célula S13-S0, e a transição 14-0 para a célula S14-S0. Estas células alvo ainda indicam equivalência, então não fiz nada na célula em análise (S14-S6). Idem para S14-S5 e S14-S4.&lt;/p&gt;
&lt;p&gt;Já na célula S14-S3, encontrei uma referência à S8-S0, que já foi eliminado em um passo anterior. Isso significa que eu devo eliminar esta célula. Nesse ponto, percebi que a linha do S8 estava inteira eliminada, então eliminei  todas as células que fazem referência a S8, ou seja, que tem transições 8/x-x/x ou x/x-8/x. O resultado pode ser visto na figura abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 3" src="https://balbertini.github.io/images/sd/sdfsmoptex3c.png"&gt;&lt;/p&gt;
&lt;p&gt;Se está lendo com cuidado, deve ter percebido que a eliminação que acabei de fazer eliminou o estado S3 inteiro. Isto significa que podemos eliminar todas as células que contém transições que referenciam o S3, pois ele não pode ser equivalente a nenhum outro estado. Se você continuar o algoritmo, terminará com a tabela de implicação abaixo, onde as células eliminadas estão em cinza.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 eliminadas" src="https://balbertini.github.io/images/sd/sdfsmoptex3d.png"&gt;&lt;/p&gt;
&lt;p&gt;A única célula que ainda precisa de análise é a célula S6-S4. Esta célula referencia os estados S9-S13 na primeira linha e S10-S14 na segunda linha. Ambas as células S9-S13 e S10-S14 não foram eliminadas pois possuem todas as suas linhas riscadas, então não devemos fazer nada nesta célula. Como não há mais células a serem analisadas, o algoritmo terminou.&lt;/p&gt;
&lt;p&gt;Com o algoritmo finalizado, podemos inferir os estados equivalentes observando as células que não foram eliminadas. A célula S6-S4 indica que estes dois estados são equivalentes. Similarmente, a coluna S7 indica que os estados S7, S9, S10, S12, S13 e S14 são todos equivalentes. Isso pode ser corroborado pelas colunas do S9, S10, S11, S12 e S13, que indicam também esta equivalência. Ainda, a célula S11-S8 indica que estes dois estados são equivalentes entre si (note que ambos produzem saída 1).&lt;/p&gt;
&lt;p&gt;Para facilitar a visualização, a figura abaixo traz as classes de equivalência coloridas. Para a mesma cor, os estados são equivalentes.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 fim" src="https://balbertini.github.io/images/sd/sdfsmoptex3e.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="45%" align="right" style="padding-left:5%" /&gt;
Por último, devemos reconstruir o diagrama de transição de estados. Para cada classe de equivalência, criamos um estado novo. As transições e as saídas podem ser copiadas de qualquer um dos estados da classe, pois eles são equivalentes (para as mesmas entradas, produzem a mesma saída e transicionam para o mesmo estado). Note que este método agrupa os estados em classes, então a transição do Sb (que é composto por S4 e S6) que vai para o S9, por exemplo, deve ir para o estado Sa (que é composto por S7, S9, S10, S12, S13 e S14) pois esta é a classe de equivalência que contém o S9. O diagrama desta tabela é idêntico ao obtido usando o método de análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h1&gt;Referências&lt;/h1&gt;
&lt;p&gt;&lt;p/&gt;
[1] DE VRIES, A. Finite automata: Behavior and synthesis. Elsevier, 2014.&lt;br&gt;
[2] KAM, Timothy et al. Synthesis of finite state machines: functional optimization. Springer Science &amp;amp;
Business Media, 2013.&lt;/p&gt;
&lt;p&gt;Algumas partes dos exemplos foram adaptados de apresentações do &lt;a href="http://www-inst.eecs.berkeley.edu/~cs150/sp00/classnotes/katz-ch9-mod.pdf"&gt;Prof. Randy H. Katz&lt;/a&gt; e da disciplina &lt;a href="https://courses.cs.washington.edu/courses/cse370/09wi/LectureSlides/22-Minimization.pdf"&gt;CSE370, Lecture 22&lt;/a&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="fsm"></category><category term="simplificação"></category><category term="otimização"></category></entry><entry><title>Entidade</title><link href="https://balbertini.github.io/vhdlentity-pt_BR.html" rel="alternate"></link><published>2018-09-21T14:37:00-03:00</published><updated>2018-09-26T18:53:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-21:/vhdlentity-pt_BR.html</id><summary type="html">&lt;p&gt;Entidades em VHDL.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Toda descrição em VHDL segue um padrão base de uma entidade e uma arquitetura. Neste artigo, explicarei como funciona a entidade.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/vhdl_maqrefri.png' width="20%" align="left" style="padding-right:5%" /&gt;
A entidade, declarada pela palavra reservada &lt;code&gt;entity&lt;/code&gt;, é a unidade básica de descrição de VHDL. O equivalente em um diagrama esquemático é o desenho que você faz para representar seu componente. Por exemplo, pense em uma máquina de vender refrigerantes em lata. Suponha que você (abstratamente), tenha que desenhar um símbolo para sua máquina. O meu símbolo seria como o da figura: entra dinheiro e sai latas.
&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;A sintaxe de uma entidade em VHDL é:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;nome_da_entidade&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
   &lt;span class="k"&gt;generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lista_de_elementos_genericos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lista_de_portas&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;nome_da_entidade&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/entidade.png' width="20%" align="right" style="padding-left:5%" /&gt;
No caso do VHDL, a entidade segue o mesmo princípio que você pensou para definir as entradas e saídas da máquina de refrigerantes, mas obviamente estamos descrevendo um circuito digital, então as entradas e saídas são digitais. A palavra reservada &lt;code&gt;generic&lt;/code&gt; é opcional e não será explicada neste artigo. Na entidade, quem declara os sinais que são usados para modelar as suas entradas e saídas é a palavra reservada &lt;code&gt;port&lt;/code&gt;. O &lt;code&gt;port&lt;/code&gt; tem a seguinte sintaxe: &lt;code&gt;port(porta1; porta2; porta3);&lt;/code&gt;. Pode-se colocar quantas portas desejar na sua descrição, separadas por ponto e vírgula &lt;code&gt;;&lt;/code&gt;. Note que a última porta declarada não tem &lt;code&gt;;&lt;/code&gt; pois o parênteses &lt;code&gt;)&lt;/code&gt; fecha a declaração. O último &lt;code&gt;;&lt;/code&gt; pertence à declaração do &lt;code&gt;port&lt;/code&gt; e não à uma porta específica.&lt;/p&gt;
&lt;p&gt;Cada porta em VHDL deve ser descrita com o formato &lt;code&gt;nome: direção tipo&lt;/code&gt;. O nome pode ser o que você desejar, desde que seja um nome válido em VHDL. O tipo da porta define qual tipo de dados será utilizado para aquela porta e pode ser &lt;a href="https://balbertini.github.io/vhdlbasicdatatypes-pt_BR.html"&gt;qualquer tipo suportado&lt;/a&gt;. Quanto a direção, há quatro direções possíveis: &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;buffer&lt;/code&gt; ou &lt;code&gt;inout&lt;/code&gt;. O &lt;code&gt;in&lt;/code&gt; é uma entrada e, como tal, só pode ser lida pelo seu componente. Analogamente, o &lt;code&gt;out&lt;/code&gt; indica uma saída, que só pode ser escrita pelo seu componente (note que &lt;strong&gt;não&lt;/strong&gt; pode ser lida). As direções de saída &lt;code&gt;buffer&lt;/code&gt; e &lt;code&gt;inout&lt;/code&gt; devem ser evitados (o motivo está &lt;a href="#bufferEinout"&gt;no final do artigo&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/mux2x1_entidade.png' width="70%"/&gt;&lt;/p&gt;
&lt;p&gt;Vamos descrever um multiplexador como o da figura. A entidade chama-se &lt;code&gt;mux2to1&lt;/code&gt; e, na figura, está a esquerda. O equivalente em um diagrama esquemático está a direita na figura. Note que não desenhei as setas na figura, nem coloquei o tamanho de alguns sinais. Isto porque é uma convenção desenhar entradas a esquerda do componente, saídas a direita e sinais de controle embaixo ou em cima. O tamanho, quando não especificado, é assumido em 1 bit.&lt;/p&gt;
&lt;p&gt;O código VHDL para esta entidade é:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;mux2to1&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;-- selection: 0=a, 1=b&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;    &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;-- inputs&lt;/span&gt;
        &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="k"&gt;out&lt;/span&gt;   &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;-- output&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="nc"&gt;mux2to1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Boas práticas ao definir a entidade&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Use um nome de entidade que indique o que ela faz.&lt;/li&gt;
&lt;li&gt;O nome do arquivo deve ser &lt;code&gt;&amp;lt;nome_da_entidade&amp;gt;.vhd&lt;/code&gt; (e.g. &lt;code&gt;mux2to1.vhd&lt;/code&gt;). Isso não se refere ao VHDL mas sim à algumas ferramentas de síntese que exigem este tipo de padronização para encontrar sua entidade.&lt;/li&gt;
&lt;li&gt;Descreva primeiro os sinais de controle, depois as entradas e depois as saídas. Não há nenhuma restrição quando a isso, mas ficará mais fácil de associar sua entidade como um componente depois.&lt;/li&gt;
&lt;li&gt;Sua entidade é a "cara" do seu componente. Capriche nos nomes das entradas e saídas e descreva-as como se estivesse desenhando-as em um diagrama esquemático.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="bufferEinout"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Saídas com direção &lt;code&gt;buffer&lt;/code&gt; e &lt;code&gt;inout&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;Uma saída que pode ser lida é especificada pelo tipo &lt;code&gt;buffer&lt;/code&gt;. Este tipo de porta é considerada especial pois implica que o sintetizador vai colocar um elemento sequencial na saída (&lt;em&gt;latch&lt;/em&gt; ou &lt;em&gt;flip-flop&lt;/em&gt;), para fazer o papel de &lt;em&gt;buffer&lt;/em&gt;, registrando a sua saída para ela que possa ser lida. Se você utilizar o &lt;code&gt;buffer&lt;/code&gt;, seu circuito nunca será combinatório. Quase todos os dispositivos de prototipação FPGA modernos suportam o &lt;code&gt;buffer&lt;/code&gt;, mas você pode aumentar um pouco a área utilizada devido ao roteamento.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/entidade.png' width="30%" align="right" style="padding-left:5%" /&gt;
Note que usando o &lt;code&gt;buffer&lt;/code&gt; você não pode ler um valor que foi colocado na saída por um elemento externo ao seu, você apenas pode ler os valores que o seu próprio componente colocou na saída. Para ler o valor que um componente externo colocou na sua saída, existe o &lt;code&gt;inout&lt;/code&gt;, um tipo de porta diferente pois é bidirecional: pode ser usada como entrada, quando você lê um sinal escrito por algo externo para dentro do seu componente, e pode ser usada como saída, quando você escreve o sinal de dentro do seu componente para que algo de fora leia. O &lt;code&gt;inout&lt;/code&gt; indica para o sintetizador que ele deve colocar um &lt;em&gt;buffer&lt;/em&gt; que suporte &lt;em&gt;tri-state&lt;/em&gt; na sua saída. Neste caso, você deve garantir que os elementos em VHDL que possam escrever ou ler façam isso de forma mutuamente exclusiva, para que o sintetizador possa inferir corretamente os sinais de controle do &lt;em&gt;buffer tri-state&lt;/em&gt;. Os dispositivos de prototipação FPGA modernos costumam possuir este tipo de &lt;em&gt;bufer&lt;/em&gt; somente nos pinos de saída do FPGA, o que deve aumentar bastante seu roteamento e, consequentemente, a área do seu circuito.&lt;/p&gt;
&lt;p&gt;Resumindo, não utilize &lt;code&gt;buffer&lt;/code&gt; nem &lt;code&gt;inout&lt;/code&gt; nas suas descrições exceto se você quer mesmo os componente que serão inferidos na sua descrição. Recomendo &lt;strong&gt;fortemente&lt;/strong&gt; que aprendizes não os utilizem. A maneira de contornar a restrição de leitura de uma porta &lt;code&gt;out&lt;/code&gt; é criar um sinal temporário, fazer o que você tem que fazer sobre este sinal e, no final da arquitetura, atribuir o sinal temporário à saída que ele representa.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nota:&lt;/strong&gt; se você é meu aluno, não utilize &lt;code&gt;buffer&lt;/code&gt; ou &lt;code&gt;inout&lt;/code&gt; somente com a intenção de ler o valor na saída em hipótese alguma.&lt;/p&gt;</content><category term="vhdl"></category><category term="basic"></category></entry><entry><title>Tipos de Dados Básicos em VHDL</title><link href="https://balbertini.github.io/vhdlbasicdatatypes-pt_BR.html" rel="alternate"></link><published>2018-09-15T10:56:00-03:00</published><updated>2018-10-05T00:57:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-15:/vhdlbasicdatatypes-pt_BR.html</id><summary type="html">&lt;p&gt;Tipos de dados básicos existentes em VHDL.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Um tipo de dado é uma classificação do conjunto possível de valores que determinado item pode assumir. VHDL é uma linguagem fortemente tipada, o que significa que a escolha do tipo de dado para um sinal, variável ou constante é de suma importância pois, para converter de um tipo ao outro, devemos utilizar funções de conversão. Uma vantagem de se utilizar uma linguagem fortemente tipada é que o sintetizador pode perceber a maioria dos erros cometidos pelos projetistas. Exemplos (todos erros que podem ser capturados em VHDL, mas difícil de detectar em outras linguagens): atribuir um grupo de sinais de 4 bits para um grupo de 8 bits; atribuir um grupo de bits sem representação numérica para um grupo de bits representando um inteiro.&lt;/p&gt;
&lt;p&gt;É importante salientar que, apesar de usar um estilo programático, a linguagem VHDL é uma linguagem de descrição de hardware, portanto no final da síntese todos os tipos assumem valores altos ou baixos. Os conceitos de tipos das linguagens de programação não existem em nenhuma HDL e esse é um dos erros mais comuns dos projetistas de hardware. Lembre-se: você não está descrevendo um programa e sim um hardware.&lt;/p&gt;
&lt;p&gt;O tipo de dado implicitamente influencia na síntese do seu circuito. Neste artigo veremos os tipos de dados mais comuns em VHDL e como utilizá-los.&lt;/p&gt;
&lt;h1&gt;Tipos pré-definidos&lt;/h1&gt;
&lt;p&gt;Os tipos de VHDL são definidos pelos padrões IEEE 1076 e IEEE 1164. São divididos em escalares, vetores, enumerados e compostos. Todos os tipos pré-definidos estão na biblioteca &lt;code&gt;std.standard&lt;/code&gt;, que é incluída implicitamente em todos os projetos de VHDL (não é necessário incluí-la).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Tipo&lt;/th&gt;
&lt;th align="center"&gt;Categoria&lt;/th&gt;
&lt;th align="center"&gt;Sintetizável?&lt;/th&gt;
&lt;th align="left"&gt;Valores&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;bit&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;enumerado&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;0&lt;/code&gt; ou &lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;enumerado&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;FALSE&lt;/code&gt; ou &lt;code&gt;TRUE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;real&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;escalar&lt;/td&gt;
&lt;td align="center"&gt;Não&lt;/td&gt;
&lt;td align="left"&gt;-1.0E38 a +1.0E38&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;character&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;enumerado&lt;/td&gt;
&lt;td align="center"&gt;Não&lt;/td&gt;
&lt;td align="left"&gt;ASCII&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O tipo &lt;code&gt;bit&lt;/code&gt; é o mais utilizado. O &lt;code&gt;boolean&lt;/code&gt; é útil para tomadas de decisão, como por exemplo em condições para um &lt;code&gt;if-else&lt;/code&gt;. É importante notar que há um mapeamento direto entre &lt;code&gt;FALSE&lt;/code&gt; e &lt;code&gt;0&lt;/code&gt;, e entre &lt;code&gt;TRUE&lt;/code&gt; e &lt;code&gt;1&lt;/code&gt;, portanto &lt;code&gt;FALSE&lt;/code&gt;&amp;lt;&lt;code&gt;TRUE&lt;/code&gt;.  O &lt;code&gt;real&lt;/code&gt; normalmente é tratado como um número de ponto flutuante de precisão dupla. O &lt;code&gt;character&lt;/code&gt; representa um grupo de 8 bits correspondentes aos 256 caracteres da tabela ASCII. Note que estes dois últimos &lt;strong&gt;não são sintetizáveis&lt;/strong&gt;, portanto não devem ser utilizados como entradas ou saídas dos módulos. Apesar de não serem sintetizáveis, estes tipos são úteis durante as simulações.&lt;/p&gt;
&lt;p&gt;O tipo &lt;code&gt;integer&lt;/code&gt; tamém é bastante utilizado e possui dois subtipos padrões:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Tipo&lt;/th&gt;
&lt;th align="center"&gt;Categoria&lt;/th&gt;
&lt;th align="center"&gt;Sintetizável?&lt;/th&gt;
&lt;th align="left"&gt;Valores&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;escalar&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;-2147483648 a 2147483648&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;natural&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;escalar&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;0 a 2147483648&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;positive&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;escalar&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;1 a 2147483648&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A especificação da linguagem não limita o número de bits do inteiro, mas a maioria das ferramentas utiliza inteiros de 32 bits. A forma de interpretação também não é definida, mas a maioria das ferramentas interpreta como uma representação em complemento de dois. Os tipos &lt;code&gt;natural&lt;/code&gt; e &lt;code&gt;positive&lt;/code&gt; são apenas limitações nos valores que um objeto deste tipo poderá assumir. É possível declarar inteiros com uma limitação personalizada:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;meusinal&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;integer&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O trecho acima declara o &lt;code&gt;meusinal&lt;/code&gt; como um inteiro de 4 bits. Contudo, valores maiores que a implementação da ferramenta de síntese não são possíveis, portanto se você precisar de um inteiro maior que 32 bits veja se sua ferramenta suporta inteiros grandes ou utilize vetores. A utilização da limitação do inteiro (com &lt;code&gt;range&lt;/code&gt; ou usando os subtipos &lt;code&gt;natural&lt;/code&gt; e &lt;code&gt;positive&lt;/code&gt;) ajuda na detecção de erros pois, se em algum momento da simulação for feita a tentativa de atribuir um valor fora da faixa permitida, o simulador irá emitir uma mensagem de erro. Além disso, usar a limitação explícita diminui o número de bits utilizados para a representação, o que economizará portas lógicas no seu circuito. Pense assim: por que você precisa de um somador de 32 bits se seus inteiros só vão assumir valores de -16 a 15?&lt;/p&gt;
&lt;p&gt;Os tipos &lt;code&gt;bit&lt;/code&gt; e &lt;code&gt;character&lt;/code&gt; também possuem suas versões em vetores:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Tipo&lt;/th&gt;
&lt;th align="center"&gt;Categoria&lt;/th&gt;
&lt;th align="center"&gt;Sintetizável?&lt;/th&gt;
&lt;th align="left"&gt;Valores&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;bit_vector&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;vetor&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;bits&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;vetor&lt;/td&gt;
&lt;td align="center"&gt;Não&lt;/td&gt;
&lt;td align="left"&gt;caracteres&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O &lt;code&gt;bit_vector&lt;/code&gt; é muito utilizado para representar um grupo de bits. Já o tipo &lt;code&gt;string&lt;/code&gt; é usado somente para mensagens durante a simulação (note que ele não é sintetizável).&lt;/p&gt;
&lt;p&gt;Há ainda dois tipos que não são sintetizáveis mas são importantes em VHDL:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Tipo&lt;/th&gt;
&lt;th align="center"&gt;Categoria&lt;/th&gt;
&lt;th align="center"&gt;Sintetizável?&lt;/th&gt;
&lt;th align="left"&gt;Valores&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;severity_level&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;enumerado&lt;/td&gt;
&lt;td align="center"&gt;Não&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;note&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; ou &lt;code&gt;failure&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;time&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;enumerado&lt;/td&gt;
&lt;td align="center"&gt;Não&lt;/td&gt;
&lt;td align="left"&gt;depende&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O tipo &lt;code&gt;severity_level&lt;/code&gt; é usado em &lt;em&gt;testbenchs&lt;/em&gt; para informar a gravidade do problema encontrado. O tipo &lt;code&gt;time&lt;/code&gt; é usado para descrever a temporização do circuito, tanto em descrições temporizadas quanto em &lt;em&gt;testbenchs&lt;/em&gt;. Os valores de tempo são acompanhados dos multiplicadores que indicam a escala de tempo: &lt;code&gt;fs&lt;/code&gt; (fentosegundos), &lt;code&gt;ps&lt;/code&gt; (picosegungos), &lt;code&gt;ns&lt;/code&gt; (nanosegundos), &lt;code&gt;us&lt;/code&gt; (microsegundos), &lt;code&gt;ms&lt;/code&gt; (milisegundos), &lt;code&gt;sec&lt;/code&gt; (segundos), &lt;code&gt;min&lt;/code&gt; (minutos) e &lt;code&gt;hr&lt;/code&gt; (horas).&lt;/p&gt;
&lt;p&gt;No exemplo abaixo, a mensagem "Teste" será impressa na tela sem parar a simulação e o &lt;code&gt;sinal&lt;/code&gt; assumirá o valor &lt;code&gt;entrada&lt;/code&gt;, mas somente após 10ns.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;report&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Teste&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;severity&lt;/span&gt; &lt;span class="n"&gt;note&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;sinal&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;entrada&lt;/span&gt; &lt;span class="k"&gt;after&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Pacote IEEE 1164&lt;/h1&gt;
&lt;p&gt;Um dos pacotes mais utilizados em VHDL é o &lt;code&gt;std_logic_1164&lt;/code&gt; da biblioteca &lt;code&gt;ieee&lt;/code&gt;, que define um MVL (lógica multivariada, ou o nome completo &lt;em&gt;Multivalue Logic System for VHDL Model Interoperability&lt;/em&gt;). Pra usar este pacote, é necessário incluir a declaração de uso no preambulo do seu projeto:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;library&lt;/span&gt; &lt;span class="nn"&gt;ieee&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;ieee.std_logic_1164.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O tipo de dado primário definido nesta biblioteca é o &lt;code&gt;std_ulogic&lt;/code&gt; (&lt;em&gt;standard unresolved logic&lt;/em&gt;), que pode assumir outros valores usados em projeto digital além dos valores ideais &lt;code&gt;0&lt;/code&gt; e &lt;code&gt;1&lt;/code&gt;. Esta modelagem de valores é mais próxima do mundo real, mas deve ser utilizada com cuidado.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Valor&lt;/th&gt;
&lt;th align="center"&gt;Significado&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;U&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Não inicializado (&lt;em&gt;uninitialized&lt;/em&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Desconhecido (forte)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Zero (forte)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Um (forte)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;Z&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Alta impedância (&lt;em&gt;tri-state&lt;/em&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;W&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Desconhecido (fraco)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;L&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Zero (fraco)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;H&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Um (fraco)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Qualquer um (&lt;em&gt;don't care&lt;/em&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O valor &lt;code&gt;U&lt;/code&gt; não foi pensado para ser utilizado pelo projetista mas sim pelas ferramentas de simulação. Quando seu circuito é simulado, um sinal em &lt;code&gt;U&lt;/code&gt; significa que até aquele momento não houve nenhuma atribuição para aquele sinal. Isso é útil para depuração pois permite diferenciar um sinal que nunca foi atribuído de um que foi atribuído com zero, por exemplo. É especialmente útil para detectar o esquecimento do acionamento do &lt;em&gt;reset&lt;/em&gt; de um circuito, pois é comum os projetistas negligenciarem o &lt;em&gt;reset&lt;/em&gt; antes de começar a simular.&lt;/p&gt;
&lt;p&gt;Já o &lt;code&gt;X&lt;/code&gt; e o &lt;code&gt;W&lt;/code&gt; indicam valores que estão fora do escopo naquele ponto do projeto. Atribuir o valor &lt;code&gt;X&lt;/code&gt; para um sinal não é uma boa prática, mas ele também é útil em uma simulação. Quando aparecer um sinal com valor &lt;code&gt;X&lt;/code&gt; ou &lt;code&gt;W&lt;/code&gt; na sua simulação, muito provavelmente houve mais de uma atribuição para o mesmo sinal e elas são divergentes (e.g. uma atribuição &lt;code&gt;0&lt;/code&gt; e uma &lt;code&gt;1&lt;/code&gt; em pontos diferentes da sua descrição). Se sua simulação tem um destes valores, corrija 0 seu circuito antes de sintetizá-lo  pois este valor não existe no mundo real: o circuito vai efetivamente assumir &lt;code&gt;1&lt;/code&gt; ou &lt;code&gt;0&lt;/code&gt;, fechando um curto-circuito caso haja uma atribuição divergente.&lt;/p&gt;
&lt;p&gt;Note também que o &lt;code&gt;X&lt;/code&gt; &lt;strong&gt;não representa&lt;/strong&gt; o &lt;em&gt;don't care&lt;/em&gt; mas sim um valor desconhecido. Como a letra X é utilizada para o &lt;em&gt;don't care&lt;/em&gt; nos métodos manuais (e.g. mapa de Karnaugh), é comum a confusão entre os dois valores.&lt;/p&gt;
&lt;p&gt;A diferença entre um valor &lt;em&gt;forte&lt;/em&gt; e &lt;em&gt;fraco&lt;/em&gt; é apenas que os fracos indicam a utilização de resistores de &lt;em&gt;pull-up&lt;/em&gt; ou &lt;em&gt;pull-down&lt;/em&gt;, portanto se uma saída &lt;code&gt;H&lt;/code&gt; for ligada a uma saída &lt;code&gt;0&lt;/code&gt;, o sinal será &lt;code&gt;0&lt;/code&gt; e não há problemas além do consumo de energia extra ocasionado pelo resistor. Contudo, se uma saída forte &lt;code&gt;1&lt;/code&gt; for ligada a uma saída &lt;code&gt;0&lt;/code&gt;, o resultado é um curto-circuito e possível dano ao circuito. Você pode livremente atribuir &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; ou &lt;code&gt;0&lt;/code&gt; para um sinal, e ambos serão sintetizados similarmente, mas as versões &lt;code&gt;H&lt;/code&gt; e &lt;code&gt;L&lt;/code&gt; instruem o sintetizador a usar portas com tecnologia de dreno aberto (&lt;em&gt;open-drain&lt;/em&gt;) ou similar, permitindo a utilização de resistores de &lt;em&gt;pull-up&lt;/em&gt; ou &lt;em&gt;pull-down&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Se a plataforma alvo não suportar buffers &lt;em&gt;tri-state&lt;/em&gt; o valor &lt;code&gt;Z&lt;/code&gt; não será sintetizado, mas as ferramentas normalmente conseguem inferir um decisor baseado em multiplexador para substituir a escolha de qual saída será colocada no sinal. Note que a plataforma alvo pode não ter &lt;em&gt;tri-state&lt;/em&gt;, então tome cuidado ao interligá-la com circuitos externos que esperam que ela tenha.&lt;/p&gt;
&lt;p&gt;Outro tipo desta biblioteca é o &lt;code&gt;std_logic&lt;/code&gt;. Ele é idêntico ao &lt;code&gt;std_ulogic&lt;/code&gt; e pode assumir qualquer valor dos citados acima, mas tem uma diferença aos olhos do sintetizador: ele pode ser resolvido. O &lt;code&gt;std_ulogic&lt;/code&gt; não especifica o que acontece quando você faz duas atribuições para o mesmo sinal (não importa se diferente ou iguais). Se o sinal for &lt;code&gt;std_logic&lt;/code&gt;, o sintetizador entende que você sabe o que está fazendo e não te indicará nada ou no máximo mostrará uma mensagem de alerta, enquanto se o sinal for do tipo &lt;code&gt;std_ulogic&lt;/code&gt;, o sintetizador irá se recusar a continuar a síntese, alertando-o que há mais de uma atribuição para aquele sinal.&lt;/p&gt;
&lt;p&gt;Ambos os tipos desta biblioteca suportam a versão em vetor:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Tipo&lt;/th&gt;
&lt;th align="center"&gt;Categoria&lt;/th&gt;
&lt;th align="center"&gt;Sintetizável?&lt;/th&gt;
&lt;th align="left"&gt;Valores&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;std_ulogic&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;enumerado&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;multivariado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;std_logic&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;enumerado&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;multivariado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;std_ulogic_vector&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;vetor&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;std_ulogic&lt;/code&gt;s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;std_logic_vector&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;vetor&lt;/td&gt;
&lt;td align="center"&gt;Sim&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;std_logic&lt;/code&gt;s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Os valores multivariados são qualquer um da tabela no início desta seção. A síntese é possível para estes tipos, mas esteja atento para as observações nesta seção quando eles forem diferentes de &lt;code&gt;0&lt;/code&gt; ou &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Qual tipo utilizar?&lt;/h1&gt;
&lt;p&gt;Não existe uma regra de que tipo utilizar, mas há várias dicas de como utilizar melhor a infraestrutura de tipos em VHDL.&lt;/p&gt;
&lt;p&gt;A primeira dica é usar o bom senso. Se você está projetando uma unidade aritmética (e.g. multiplicador), faz pleno sentido que as entradas e saídas sejam &lt;code&gt;unsigned&lt;/code&gt; ou &lt;code&gt;signed&lt;/code&gt; de acordo com a maneira como a unidade aritmética as interpreta (e.g. o multiplicador é de inteiros sem ou com sinal). Contudo, se você está projetando um multiplexador, não faz sentido usar um tipo de dados com interpretação embutida pois o multiplexador não opera sobre os dados. Nesse caso, utilize o tipo &lt;code&gt;bit&lt;/code&gt; ou &lt;code&gt;std_logic&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;std_logic&lt;/code&gt; ou &lt;code&gt;bit&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Este é um tema de debate entre os projetistas há anos. A maioria dos projetistas opta por utilizar o &lt;code&gt;std_logic&lt;/code&gt; e evitar aborrecimentos, mas esta não é uma boa prática. Para escolher corretamente, você precisa pensar no circuito que está desenvolvendo e na arquitetura alvo.&lt;/p&gt;
&lt;p&gt;O FPGA, por exemplo, não suporta internamente nenhum dos tipos do &lt;code&gt;std_logic&lt;/code&gt;, portanto não faz sentido utilizá-lo pois internamente só haverá bits. Se sua arquitetura alvo é um FPGA, como por exemplo nas disciplinas de laboratório, use sempre o tipo &lt;code&gt;bit&lt;/code&gt;. As excessões onde a utilização do &lt;code&gt;std_logic&lt;/code&gt; é correta são: (i) quando você estiver projetando um barramento, (ii) quando estiver lidando com a saída, e (iii) em simulações.&lt;/p&gt;
&lt;p&gt;No caso (i) a utilização do &lt;em&gt;tri-state&lt;/em&gt; pode ser útil pois você poderá interligar saídas sem problemas, desde que somente uma delas esteja ativa e as demais estejam em &lt;em&gt;tri-state&lt;/em&gt;. Contudo, se o seu barramento for interno ao FPGA, ele será sintetizado usando multiplexadores e não &lt;em&gt;tri-state&lt;/em&gt; real pois o FPGA não tem esta funcionalidade internamente. Lembre-se que o &lt;em&gt;tri-state&lt;/em&gt; do &lt;code&gt;std_logic&lt;/code&gt; é representado por &lt;code&gt;Z&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Já no caso (ii) você pode utilizar o &lt;code&gt;std_logic&lt;/code&gt; livremente pois a maioria dos FPGAs implementa &lt;em&gt;open-drain&lt;/em&gt; e &lt;em&gt;tri-state&lt;/em&gt; nos buffers de saída. Você pode facilmente usar &lt;em&gt;tri-state&lt;/em&gt; e valores de &lt;em&gt;weak&lt;/em&gt; (que implementam &lt;em&gt;pull-up&lt;/em&gt; e &lt;em&gt;pull-down&lt;/em&gt;), mas lembre-se que nem todos os valores do &lt;code&gt;std_logic&lt;/code&gt; são sintetizáveis.&lt;/p&gt;
&lt;p&gt;No último caso (iii), o valor &lt;code&gt;U&lt;/code&gt; (&lt;em&gt;uninitialized&lt;/em&gt;) pode ser útil para saber se um determinado valor foi ou não escrito alguma vez durante a simulação pois é o valor padrão do &lt;code&gt;std_logic&lt;/code&gt;. Na simulação todos os valores do &lt;code&gt;std_logic&lt;/code&gt; são expressos corretamente, mas lembre-se que na síntese os valores sempre vão assumir &lt;code&gt;0&lt;/code&gt; ou &lt;code&gt;1&lt;/code&gt; mesmo que nunca tenham tido um valor atribuído.&lt;/p&gt;
&lt;p&gt;Uma das falácias do tipo &lt;code&gt;std_logic&lt;/code&gt; é o &lt;em&gt;don't care&lt;/em&gt;. Ele é representado pelo &lt;code&gt;-&lt;/code&gt; e não pelo &lt;code&gt;X&lt;/code&gt; (&lt;em&gt;unknown&lt;/em&gt;) normalmente usado nos métodos manuais (e.g mapa de Karnaugh). Se usado corretamente, a maioria das ferramentas interpreta o &lt;code&gt;-&lt;/code&gt; como o &lt;em&gt;don't care&lt;/em&gt; esperado, inclusive na atribuição condicional. Algumas ferramentas tratam ambos os &lt;code&gt;X&lt;/code&gt; e o &lt;code&gt;-&lt;/code&gt; como &lt;em&gt;don't care&lt;/em&gt; para evitar a confusão, mais ela ainda acontece especialmente entre projetistas iniciantes, portanto evite-o.&lt;/p&gt;
&lt;p&gt;De fato, a maioria dos projetos não necessita do &lt;code&gt;std_logic&lt;/code&gt; e acabam por utilizá-lo apenas com os valores &lt;code&gt;0&lt;/code&gt; ou &lt;code&gt;1&lt;/code&gt;, como substituição ao tipo &lt;code&gt;bit&lt;/code&gt;. Como regra geral, utilize o tipo de dado certo para o trabalho que está fazendo e, enquanto você estiver aprendendo, utilize somente o tipo &lt;code&gt;bit&lt;/code&gt; para evitar problemas. Quando estiver confortável, transicione para o tipo &lt;code&gt;std_ulogic&lt;/code&gt; qaundo precisar de sinais multivariados e só quando realmente precisar de um sinal de multivariado com múltiplas atribuições (e.g. barramento) use o &lt;code&gt;std_logic&lt;/code&gt;.&lt;/p&gt;</content><category term="vhdl"></category><category term="tipos"></category></entry><entry><title>Máquina virtual com GHDL</title><link href="https://balbertini.github.io/virtualmachineghdl-pt_BR.html" rel="alternate"></link><published>2018-09-13T12:16:00-03:00</published><updated>2018-09-15T10:39:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-13:/virtualmachineghdl-pt_BR.html</id><summary type="html">&lt;p&gt;Como utilizar a VM com GHDL.&lt;/p&gt;</summary><content type="html">&lt;p&gt;O GHDL é um simulador de VHDL que gera código nativo, o que significa que as simulações são muito rápidas. Contudo, foi escrito em ADA, uma linguagem na iminência de ser considerada exótica. Como vários professores de Sistemas Digitais usam este software para corrigir os exercícios dados nas disciplinas teóricas, mantemos uma máquina virtual com uma versão recente do GHDL instalada, que também compartilhamos com os alunos. Neste artigo, mostrarei como usar uma VM que contém o &lt;a href="http://ghdl.free.fr/"&gt;GHDL&lt;/a&gt; para simular e testar funcionalmente sua descrição VHDL.&lt;/p&gt;
&lt;p&gt;Há também uma gravação de uma Live disponível no YouTube.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://youtu.be/PEaDYHk8CBc"&gt;Link para o tutorial no YouTube&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Preparando o ambiente&lt;/h1&gt;
&lt;p&gt;Comece fazendo download da máquina virtual clicando nos links abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/file/d/1_KPXSVHjk3UmFIFHAbIfzLdwWwrXGmHQ" target="_blank"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; GHDL.ova&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/file/d/1wqwmZvWUJHamL2AnWSRm3D2B2eI7pi2f" target="_blank"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; GHDL.ova.md5sum&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O arquivo md5sum possui o hash MD5 do arquivo e não precisa ser baixado. Aconselha-se que baixe-o e verifique se o arquivo &lt;code&gt;GHDL.ova&lt;/code&gt; que você baixou possui o mesmo hash contido no arquivo &lt;code&gt;GHDL.ova.md5sum&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A máquina está no formato &lt;em&gt;Open Virtual Appliance&lt;/em&gt;, portanto você também precisará de um software de virtualização compatível com sua máquina e com o formato OVF 2.0 (&lt;em&gt;Open Virtualization Format&lt;/em&gt;). Este artigo usará o &lt;a href="https://www.virtualbox.org/"&gt;VirtualBox&lt;/a&gt; como software de virtualização.&lt;/p&gt;
&lt;h1&gt;Preparando a máquina virtual&lt;/h1&gt;
&lt;p&gt;Abra o arquivo &lt;code&gt;GHDL.ova&lt;/code&gt; com o seu software de virtualização (e.g. clique duas vezes, vá em &lt;code&gt;Arquivo/Importar Appliance&lt;/code&gt;, etc).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Adicionando a VM" src="https://balbertini.github.io/images/vhdl/vmghdl1.png"&gt;&lt;/p&gt;
&lt;p&gt;Não é necessário mudar nenhum parâmetro da VM neste momento. Opcionalmente desligue os itens que não pretende utilizar, como por exemplo o controlador USB ou a placa de som. Não desabilite a placa de rede pois iremos utilizá-la para acessar a máquina. Quando estiver satisfeito, clique no botão &lt;code&gt;Importar&lt;/code&gt; finalize a importação da máquina.&lt;/p&gt;
&lt;p&gt;Com a importação finalizada, a VM deve aparecer na sua lista de VMs. Com a VM selecionada, vá em &lt;code&gt;Máquina/Configurações&lt;/code&gt; ou clique com o botão direito dobre a máquina e escolha &lt;code&gt;Configurações&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Configurando a VM" src="https://balbertini.github.io/images/vhdl/vmghdl2.png"&gt;&lt;/p&gt;
&lt;p&gt;Na caixa que abrirá, selecione &lt;code&gt;Rede&lt;/code&gt;, expanda a aba &lt;code&gt;Avançado&lt;/code&gt; e clique no botão &lt;code&gt;Redirecionamento de Portas&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Redirecionamento de portas" src="https://balbertini.github.io/images/vhdl/vmghdl3.png"&gt;&lt;/p&gt;
&lt;p&gt;Na tela que se abrirá, você deve ver uma regra pré-carregada. Confira os dados ou caso não veja nenhuma regra, clique no botão de adicionar uma nova regra e adicione o seguinte:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Nome&lt;/code&gt;: qualquer um, no exemplo usarei "SSH"&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Protocolo&lt;/code&gt;: TCP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Endereço IP do Hospedeiro&lt;/code&gt;: deixar em branco&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Porta do Hospedeiro&lt;/code&gt;: qualquer uma alta, no exemplo usei 5022&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IP do Convidado&lt;/code&gt;: deixar em branco&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Porta do Convidado&lt;/code&gt;: 22&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Regra de redirecionamento" src="https://balbertini.github.io/images/vhdl/vmghdl4.png"&gt;&lt;/p&gt;
&lt;p&gt;Note que a imagem não mostra todos os campos. Configure todos como na lista acima. Aqui terminamos com a rede. Clique no OK e volte para a tela de configuração da máquina virtual. Dessa vez vá para aba &lt;code&gt;Pastas Compartilhadas&lt;/code&gt; e use o botão para adicionar uma nova pasta.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Regra de redirecionamento" src="https://balbertini.github.io/images/vhdl/vmghdl5.png"&gt;&lt;/p&gt;
&lt;p&gt;No campo &lt;code&gt;Caminho da Pasta&lt;/code&gt;, escolha uma pasta qualquer da sua máquina. No campo &lt;code&gt;Nome da Pasta&lt;/code&gt;, coloque o nome que desejar (neste exemplo usei &lt;em&gt;VMShared&lt;/em&gt;). O &lt;code&gt;Caminho da Pasta&lt;/code&gt; é a pasta na sua máquina real (host) e o &lt;code&gt;Nome da Pasta&lt;/code&gt; é o nome do compartilhamento. A pasta que você escolher em &lt;code&gt;Caminho da Pasta&lt;/code&gt; será compartilhada com a máquina virtual na montagem da pasta compartilhada, portanto escolha uma pasta onde vai colocar os arquivos. Resumo: a pasta que você escolher em &lt;code&gt;Caminho da Pasta&lt;/code&gt; será exatamente a mesma dentro da máquina virtual: o que você colocar/editar em uma aparece na outra e vice-versa.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Regra de redirecionamento" src="https://balbertini.github.io/images/vhdl/vmghdl6.png"&gt;&lt;/p&gt;
&lt;p&gt;Finalizamos a configuração da VM. Clique no OK até voltar para a tela do software de virtualização.&lt;/p&gt;
&lt;h1&gt;Iniciando a máquina virtual&lt;/h1&gt;
&lt;p&gt;Antes de começar, leia esta seção toda, caso contrário você poderá ficar com o mouse e teclado capturados pela máquina virtual. Com a máquina selecionada na tela principal do software de virtualização, clique no botão &lt;code&gt;Iniciar&lt;/code&gt; (botão com seta verde). A máquina irá iniciar e você verá uma tela preta com o &lt;em&gt;prompt&lt;/em&gt; de login. Esta tela é como se fosse a tela de outro computador, com a diferença que ele é virtual.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Prompt de login" src="https://balbertini.github.io/images/vhdl/vmghdl7.png"&gt;&lt;/p&gt;
&lt;p&gt;Dependendo da configuração da sua máquina, a tela inicial estará toda preta; nesse caso, pressione qualquer tecla (e.g. enter) para habilitar o &lt;em&gt;prompt&lt;/em&gt; de login. Se desejar logar na máquina, clique na tela e utilize o usuário padrão e a senha padrão, que é &lt;code&gt;poli&lt;/code&gt; para ambos. Contudo, esta máquina não tem interface gráfica para ficar mais rápida e diminuir o tamanho do download (você pode instalar se desejar, mas o tamanho da máquina aumentará consideravelmente). Se você está confortável com sistemas em modo texto, pule a próxima seção e utilize esta tela para o restante deste artigo, caso contrário a próxima seção mostrará como logar via SSH. Caso você esteja com o mouse ou apontador presona sua máquina virtual, veja a tecla de desabilitar a captura do mouse e teclado no canto direito inferior da máquina (no exemplo é Left &amp;#8984;). Pressione essa tecla por 2s e solte. Seu mouse e teclado agora devem ser devolvidos para a sua máquina.&lt;/p&gt;
&lt;h1&gt;Acessando a máquina virtual por SSH&lt;/h1&gt;
&lt;p&gt;Uma forma mais fácil de acessar a máquina é logar via SSH, pois assim você pode aproveitar todos os benefícios da sua própria máquina, como interface gráfica e editores modernos, usando o SHH apenas para executar o GHDL. Há clientes SSH para vários sistemas operacionais, como o &lt;a href="https://www.putty.org"&gt;PuTTY&lt;/a&gt; (Windows, Linux). Os sistemas operacionais baseados em *nix (e.g. MacOS e Linux) e algumas versões do Windows (e.g. Windows 10) já possuem um cliente SSH pré-instalado, portanto basta abrir um terminal (no Windows, o terminal chama-se &lt;code&gt;cmd.exe&lt;/code&gt;e pode ser acessado pelo menu principal/executar/cmd.exe).&lt;/p&gt;
&lt;p&gt;No terminal aberto na sua máquina, abra uma sessão SSH para a VM através do comando &lt;code&gt;ssh -p5022 poli@127.0.0.1&lt;/code&gt;. O usuário é &lt;code&gt;poli&lt;/code&gt; (já especificado na linha de comando) e a senha também é &lt;code&gt;poli&lt;/code&gt;. Se você escolheu outra porta no momento de adicionar a regra de redirecionamento, deverá substituir de acordo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;Brunos-MacBook-Pro:~ balbertini$&lt;/span&gt; ssh -p5022 poli@127.0.0.1
&lt;span class="go"&gt;The authenticity of host &amp;#39;[127.0.0.1]:5022 ([127.0.0.1]:5022)&amp;#39; can&amp;#39;t be established.&lt;/span&gt;
&lt;span class="go"&gt;ECDSA key fingerprint is SHA256:fSLO3evzG//rjYMSM0OwLPx1XeqHPg4Sj7NTeQdVfq0.&lt;/span&gt;
&lt;span class="go"&gt;Are you sure you want to continue connecting (yes/no)? yes&lt;/span&gt;
&lt;span class="go"&gt;Warning: Permanently added &amp;#39;[127.0.0.1]:5022&amp;#39; (ECDSA) to the list of known hosts.&lt;/span&gt;
&lt;span class="go"&gt;poli@127.0.0.1&amp;#39;s password:&lt;/span&gt;
&lt;span class="go"&gt;Welcome to Ubuntu 18.04.1 LTS (GNU/Linux 4.15.0-30-generic x86_64)&lt;/span&gt;

&lt;span class="go"&gt; * Documentation:  https://help.ubuntu.com&lt;/span&gt;
&lt;span class="go"&gt; * Management:     https://landscape.canonical.com&lt;/span&gt;
&lt;span class="go"&gt; * Support:        https://ubuntu.com/advantage&lt;/span&gt;

&lt;span class="go"&gt;Last login: Wed Aug  8 14:22:50 2018&lt;/span&gt;
&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No primeiro acesso, seu cliente vai mostrar a chave de criptografia do servidor SSH executando na máquina virtual. Aceite com &lt;em&gt;yes&lt;/em&gt; e o cliente solicitará a senha do usuário &lt;code&gt;poli&lt;/code&gt;, que também é &lt;code&gt;poli&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Caso esteja usando o PuTTY, abra um terminal e digite o comando equivalente, substituindo &lt;code&gt;ssh -p5022 poli@127.0.0.1&lt;/code&gt; por &lt;code&gt;putty -p5022 poli@127.0.0.1&lt;/code&gt; (Linux) ou &lt;code&gt;putty.exe -p5022 poli@127.0.0.1&lt;/code&gt; (Windows).
Se preferir usar a versão gráfica, veja um tutorial &lt;a href="https://www.secnet.com.br/blog/ssh-com-putty"&gt;aqui&lt;/a&gt;. As credenciais são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Host Name (or IP address)&lt;/code&gt;: 127.0.0.1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Port&lt;/code&gt;: 5022 (ou a porta que você definiu no redirecionamento de portas)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;login as&lt;/code&gt;: poli&lt;/li&gt;
&lt;li&gt;&lt;code&gt;password&lt;/code&gt;: poli (esta é a mesma senha usada para o sudo)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O acesso via SSH é opcional, mas facilitará bastante. Caso opte por não fazê-lo, logue diretamente na tela do seu software de virtualização. Se acessar via SSH, você pode minimizar a máquina virtual e deixá-la executando em segundo plano.&lt;/p&gt;
&lt;h1&gt;Reconfigurando o teclado&lt;/h1&gt;
&lt;p&gt;Caso tenha problemas com o layout do seu teclado, use o comando abaixo para mudá-lo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt; sudo dpkg-reconfigure keyboard-configuration
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Fazendo update do VirtualBox Guest Additions&lt;/h1&gt;
&lt;p&gt;Quando estiver logado na máquina virtual (via SSH ou via tela do software de virtualização), faça o update do módulo de &lt;em&gt;Guest Additions&lt;/em&gt;. Este passo é necessário pois o módulo muda com frequência, e você precisa mantê-lo alinhado com a sua versão do VirtualBox. Refaça este passo todas as vezes que atualizar o VirtualBox na sua máquina real (&lt;em&gt;host&lt;/em&gt;). Caso sua máquina virtual já esteja com a última versão do &lt;em&gt;Guest Additions&lt;/em&gt; instalada, nenhum pacote será atualizado e, dependendo de quando você fizer o download da máquina virtual, você pode pular este passo. Aproveite e faça um update do sistema operacional também.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt; sudo apt-get update
&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt; sudo apt-get install virtualbox-guest-utils
&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt; sudo apt-get upgrade
&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt; sudo reboot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O comando do meio, &lt;code&gt;sudo apt-get install virtualbox-guest-utils&lt;/code&gt; é o único passo obrigatório, os demais fica a seu critério. O último comando irá reiniciar a máquina para que possíveis atualizações da máquina surtam efeito, o que acarretará na sua desconexão. Aguarde a máquina virtual reiniciar e logue novamente.&lt;/p&gt;
&lt;h1&gt;Montando a pasta compartilhada&lt;/h1&gt;
&lt;p&gt;Precisamos primeiro criar um ponto de montagem, que nada mais é que um diretório na máquina virtual.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt; mkdir shared
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Depois montamos a pasta da sua máquina real (host) na máquina virtual.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~$&lt;/span&gt; sudo mount -t vboxsf -ouid&lt;span class="o"&gt;=&lt;/span&gt;poli,rw VMShared shared
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Com isso, a pasta &lt;code&gt;shared&lt;/code&gt; na máquina virtual será a mesma que a pasta que escolheu quando configurou a pasta compartilhada. Note que se você deu outro nome para o compartilhamento, deve substituir &lt;code&gt;VMShared&lt;/code&gt; pelo nome que escolheu.&lt;/p&gt;
&lt;h1&gt;Usando o GHDL na máquina virtual&lt;/h1&gt;
&lt;p&gt;Você pode editar os arquivos VHDL na sua máquina real (&lt;em&gt;host&lt;/em&gt;) normalmente, usando o editor de sua preferência (eu utilizo o &lt;a href="https://atom.io/"&gt;Atom&lt;/a&gt; com o pacote &lt;code&gt;language-vhdl&lt;/code&gt; para o &lt;em&gt;syntax highlight&lt;/em&gt;). Sempre salve os seus arquivos na pasta compartilhada na sua máquina real e eles automaticamente estarão disponíveis dentro da máquina virtual, na pasta onde montou a pasta compartilhada.&lt;/p&gt;
&lt;p&gt;Para usar o GHDL, você deve passar por três fases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Análise: &lt;code&gt;ghdl -a arquivo.vhd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Elaboração: &lt;code&gt;ghdl -e entidade&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Simulação: &lt;code&gt;ghdl -e entidade&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Você deve fazer a análise de todos os arquivos VHDL que for utilizar. Na análise, o GHDL irá verificar erros de sintaxe e verificará se os componentes necessários estão todos presentes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~/shared$&lt;/span&gt; ghdl -a shiftleft2.vhd
&lt;span class="gp"&gt;poli@ghdl:~/shared$&lt;/span&gt; ghdl -a utils.vhd
&lt;span class="gp"&gt;poli@ghdl:~/shared$&lt;/span&gt; ghdl -a shiftleft2_tb.vhd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Neste exemplo, analisamos os arquivos &lt;code&gt;shiftleft2.vhd&lt;/code&gt;, &lt;code&gt;utils.vhd&lt;/code&gt; e &lt;code&gt;shiftleft2_tb.vhd&lt;/code&gt;. A análise do &lt;code&gt;utils.vhd&lt;/code&gt; precisa vir antes da análise do &lt;code&gt;shiftleft2_tb.vhd&lt;/code&gt; pois este último utiliza o pacote (&lt;code&gt;package&lt;/code&gt;) dentro do &lt;code&gt;utils.vhd&lt;/code&gt;, portanto este deve estar analisado no momento da análise da entidade que o utiliza.&lt;/p&gt;
&lt;p&gt;Com todos os arquivos analisados, vamos para a fase de elaboração. Nesta fase, o GHDL irá montar o simulador com a entidade desejada, ligando de fato todos os componentes e verificando erros semânticos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~/shared$&lt;/span&gt; ghdl -e shiftleft2_tb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Agora que a entidade a ser executada está elaborada, podemos executar a simulação em si:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~/shared$&lt;/span&gt; ghdl -r shiftleft2_tb
&lt;span class="go"&gt;shiftleft2_tb.vhd:44:7:@0ms:(report note): BOT&lt;/span&gt;
&lt;span class="go"&gt;shiftleft2_tb.vhd:65:7:@4ns:(report note): EOT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A entidade que será simulada está no &lt;code&gt;shiftleft2_tb.vhd&lt;/code&gt; e chama-se &lt;code&gt;shiftleft2_tb&lt;/code&gt;, portanto no exemplo elaboramos esta entidade, depois executamos a simulação com a mesma. Esta entidade representa um &lt;em&gt;testbench&lt;/em&gt; escrito em VHDL. A saída impressa são provenientes dos comandos &lt;code&gt;report&lt;/code&gt; colocados no &lt;em&gt;testbench&lt;/em&gt; para indicar o início e o final da simulação.&lt;/p&gt;
&lt;p&gt;Ainda podemos passar alguns parâmetros para o simulador:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;poli@ghdl:~/shared$&lt;/span&gt; ghdl -r shiftleft2_tb --vcd&lt;span class="o"&gt;=&lt;/span&gt;shiftleft2_tb.vcd
&lt;span class="go"&gt;shiftleft2_tb.vhd:44:7:@0ms:(report note): BOT&lt;/span&gt;
&lt;span class="go"&gt;shiftleft2_tb.vhd:65:7:@4ns:(report note): EOT&lt;/span&gt;
&lt;span class="gp"&gt;poli@ghdl:~/shared$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Há diversos parâmetros que podem ser passados para a simulação. Um muito útil que pode ser visto acima é o &lt;code&gt;--vcd=arquivo.vcd&lt;/code&gt;. Este parâmetro salvará a forma de onda resultante da simulação no arquivo (neste caso o &lt;code&gt;shiftleft2_tb.vcd&lt;/code&gt;). Para visualizar o arquivo VCD você precisará de um programa que visualize formas de onda. Recomendo o &lt;a href="http://gtkwave.sourceforge.net/"&gt;GTKWave&lt;/a&gt;, disponível para várias as plataformas. Na sua máquina real (&lt;em&gt;host&lt;/em&gt;), navegue até a pasta compartilhada e veja que os arquivos gerados pelo GHDL estão lá, incluindo o resultado da simulação. Você pode abrir o arquivo VCD com o seu visualizador preferido.&lt;/p&gt;</content><category term="vhdl"></category><category term="ghdl"></category><category term="vm"></category></entry><entry><title>Simuladores e sintetizadores de HDL</title><link href="https://balbertini.github.io/simuladores-pt_BR.html" rel="alternate"></link><published>2018-09-13T08:45:00-03:00</published><updated>2018-09-13T08:45:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-13:/simuladores-pt_BR.html</id><summary type="html">&lt;p&gt;Lista de programas para HDL.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Há diversos programas que suportam descrições em HDL. Para começar no seu mundo de projetista de hardware usando VHDL ou Verilog, escolha um programa nesta lista e prepare seu ambiente. Quase todos são um &lt;em&gt;Integrated Design Environment&lt;/em&gt; (IDE), ou seja, possuem um ambiente com suporte a descrição incluindo &lt;em&gt;syntax highlight&lt;/em&gt;, acesso rápido a simulação, síntese e algum sistema de gerenciamento de projetos.&lt;/p&gt;
&lt;h3&gt;GHDL&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/ghdl/ghdl/releases"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; Download&lt;/a&gt; |
&lt;a href="http://ghdl.free.fr/"&gt;&lt;i style="font-size: 1em;" class="fas fa-file-alt"&gt;&lt;/i&gt; Página&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDLs:&lt;/strong&gt; VHDL | &lt;strong&gt;SOs:&lt;/strong&gt; &lt;i style="font-size: 1em;" class="fab fa-windows"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-linux"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-apple"&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;O GHDL é um simulador de código aberto para a linguagem VHDL somente, mantido pelo desenvolvedor Tristan Gingold. Permite que você compile e simule sua descrição na sua máquina usando um compilador nativo, o que é bem rápido em comparação aos outros simuladores desta página. Contudo, o GHDL não faz síntese nem simulação temporizada (exceto se você descrever seu circuito usando temporização explícita no VHDL).&lt;/p&gt;
&lt;p&gt;Este é o simulador usado para corrigir os exercícios de Sistemas Digitais. Os professores mantém uma máquina virtual com GHDL instalado, atualizado e funcionando, e esta máquina está disponível para os alunos. Veja &lt;a href="https://balbertini.github.io/virtualmachineghdl-pt_BR.html"&gt;este artigo&lt;/a&gt; se deseja trabalhar com esta máquina virtual.&lt;/p&gt;
&lt;h3&gt;Active-HDL&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.aldec.com/students/student.php?id=9"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; Download&lt;/a&gt; |
&lt;a href="https://www.aldec.com/en/products/fpga_simulation/active_hdl_student"&gt;&lt;i style="font-size: 1em;" class="fas fa-file-alt"&gt;&lt;/i&gt; Página&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDLs:&lt;/strong&gt; VHDL, Verilog | &lt;strong&gt;SOs:&lt;/strong&gt; &lt;i style="font-size: 1em;" class="fab fa-windows"&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Este programa é uma IDE completo e suporta simulação somente. Para síntese, você deve ter instalado um programa de síntese na sua máquina (e.g. Quartus, Vivado, ISE, etc), e a IDE se encarrega de invocá-lo corretamente.&lt;/p&gt;
&lt;p&gt;Possui a vantagem de ser mantido por uma empresa terceira (&lt;a href="https://www.aldec.com"&gt;Aldec&lt;/a&gt;), independente do fabricante do hardware alvo do seu projeto. O link para download é da versão de estudante e necessita cadastro (use seu email \@usp).&lt;/p&gt;
&lt;h3&gt;Quartus&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://fpgasoftware.intel.com/?edition=lite"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; Download&lt;/a&gt; |
&lt;a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html"&gt;&lt;i style="font-size: 1em;" class="fas fa-file-alt"&gt;&lt;/i&gt; Página&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDLs:&lt;/strong&gt; VHDL, Verilog | &lt;strong&gt;SOs:&lt;/strong&gt; &lt;i style="font-size: 1em;" class="fab fa-windows"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-linux"&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;O Quartus é um IDE fornecido pela Altera, uma subsidiária da &lt;a href="https://www.intel.com"&gt;Intel&lt;/a&gt;. Permite simulação através do Modelsim (fornecido com o pacote), incluindo simulação temporizada para os dispositivos fabricados pela Intel. Quando fizer download, tenha certeza que fez download do pacote completo incluindo o Modelsim. O link para download é da versão Lite, que é gratuita para todos e suporta sem licença os dispositivos do programa universitário. Caso esteja trabalhando em algum projeto que utilize um dispositivo não suportado na versão Lite, é possível obter uma licença através do programa universitário (consulte seu orientador).&lt;/p&gt;
&lt;h3&gt;Vivado/ISE&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.xilinx.com/support/download.html"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; Download&lt;/a&gt; |
&lt;a href="https://www.xilinx.com/products/design-tools/vivado.html"&gt;&lt;i style="font-size: 1em;" class="fas fa-file-alt"&gt;&lt;/i&gt; Página&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDLs:&lt;/strong&gt; VHDL, Verilog | &lt;strong&gt;SOs:&lt;/strong&gt; &lt;i style="font-size: 1em;" class="fab fa-windows"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-linux"&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;O Vivado é um IDE fornecido pela &lt;a href="https://www.xilinx.com/"&gt;Xilinx&lt;/a&gt;. Também permite simulação através do Modelsim (fornecido no pacote), incluindo simulação temporizada para os dispositivos fabricados pela Xilinx. O link para download é genérico, consulte seu professor(a) qual versão irá utilizar (recomendo a Lab Edition pois não precisa de licença alguma). A versão HLx possui ainda suporte a síntese de alto nível.&lt;/p&gt;
&lt;p&gt;O ISE é uma versão antiga do IDE da Xilinx disponível somente para Windows. Faça &lt;a href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/design-tools.html"&gt;download&lt;/a&gt; dessa versão somente se for trabalhar com placas antigas (i.e. Spartan-6), caso contrário opte pelo Vivado.&lt;/p&gt;
&lt;h1&gt;Programas úteis&lt;/h1&gt;
&lt;h3&gt;GTKWave&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/gtkwave/files/"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; Download&lt;/a&gt; |
&lt;a href="http://gtkwave.sourceforge.net/"&gt;&lt;i style="font-size: 1em;" class="fas fa-file-alt"&gt;&lt;/i&gt; Página&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SOs:&lt;/strong&gt; &lt;i style="font-size: 1em;" class="fab fa-windows"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-linux"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-apple"&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;O GTKWave é um visualizador de formas de onda de código aberto baseado no &lt;a href="http://www.gtk.org/"&gt;GTK+&lt;/a&gt;. Quando estiver simulando a descrição do seu circuito, o seu simulador gera um arquivo &lt;a href="https://en.wikipedia.org/wiki/Value_change_dump"&gt;VCD&lt;/a&gt;, que deve ser aberto em um visualizador como o GTKWave. Este programa é especialmente útil se você não estiver usando um IDE (e.g. GHDL).&lt;/p&gt;
&lt;h3&gt;Atom&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/atom/atom/releases/tag/v1.30.0"&gt;&lt;i style="font-size: 1em;" class="fas fa-download"&gt;&lt;/i&gt; Download&lt;/a&gt; |
&lt;a href="https://atom.io/"&gt;&lt;i style="font-size: 1em;" class="fas fa-file-alt"&gt;&lt;/i&gt; Página&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SOs:&lt;/strong&gt; &lt;i style="font-size: 1em;" class="fab fa-windows"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-linux"&gt;&lt;/i&gt; &lt;i style="font-size: 1em;" class="fab fa-apple"&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;O Atom é um editor de textos com suporte a várias linguagens. Eu o utilizo para a maioria dos meus projetos envolvendo HDLs. Para habilitar o suporte a VHDL, instale o pacote &lt;code&gt;language-vhdl&lt;/code&gt; depois de instalar o atom.&lt;/p&gt;
&lt;h1&gt;Utilização nas disciplinas&lt;/h1&gt;
&lt;p&gt;Nas disciplinas teóricas de Sistemas Digitais o GHDL é utilizado para correção dos exercícios, mas não faz muita diferença qual simulador você usa para desenvolver, desde que &lt;strong&gt;não utilize&lt;/strong&gt; nenhuma tecnologia dependente de um determinado fabricante. Nestas disciplinas você raramente será solicitado a sintetizar seu circuito.&lt;/p&gt;
&lt;p&gt;Nas disciplinas práticas, você invariavelmente irá sintetizar e experimentar seu circuito em uma placa de prototipação. No Laboratório Digital, as placas são do programa universitário da Intel, fabricadas pela Terasic com FPGAs da Intel. Isso significa que você terá que utilizar o Quartus. É possível utilizar o Active-HDL com o Quartus como backend, mas esta configuração ainda não é suportada no laboratório. As disciplinas de Arquitetura de Computadores, apesar de teóricas, possuem forte componente prática e você também precisará de um software que suporte síntese. Contudo, nestas disciplinas a placa utilizada é do programa universitário da Xilinx, fabricadas pela Digilent com FPGAs da Xilinx. O software de síntese deste fabricante é o Vivado (ou ISE para placas antigas), porém a disciplina utiliza o arrajo Active-HDL com o Vivado como backend. Note que o software de síntese só funciona para os dispositivos daquele fabricante, portanto não há como utilizar um software de um fabricante com uma placa de outro (e.g. sintetizar no Vivado e programar a placa da Intel).&lt;/p&gt;
&lt;p&gt;Sempre que for configurar seu ambiente, opte pela versão mais atualizada ou consulte qual versão será utilizada na disciplina. Em vários casos, se sua versão for diferente da utilizada no laboratório, você pode ter problemas para levar seu projeto para o laboratório e usar os computadores disponíveis para programar a placa. Em nenhum laboratório há restrições quanto a levar seu próprio notebook, mas consulte sempre o técnico do laboratório ou seu professor(a) para ter certeza que há nenhum problema em ligar a placa no seu próprio equipamento.&lt;/p&gt;
&lt;p&gt;A escolha de qual software utilizar é sua, porém aconselho que sempre descreva seu hardware sem utilizar nenhuma construção que dependa de um fabricante específico, assim você pode facilmente transportar seu código de um software para o outro.&lt;/p&gt;</content><category term="vhdl"></category><category term="verilog"></category><category term="simuladores"></category></entry><entry><title>Circuitos Sequenciais em VHDL</title><link href="https://balbertini.github.io/sequential-pt_BR.html" rel="alternate"></link><published>2018-09-05T03:51:00-03:00</published><updated>2018-09-05T03:51:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-05:/sequential-pt_BR.html</id><summary type="html">&lt;p&gt;Como descrever circuitos sequenciais em VHDL.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A principal característica de um &lt;strong&gt;circuito sequencial&lt;/strong&gt; é que as saídas dependem não somente das entradas, como em um circuito combinatório, mas também das entradas passadas. Diz-se que um circuito sequencial possui um &lt;strong&gt;elemento de memória&lt;/strong&gt; ou é dependente do tempo (esta última é discutível pois nem sempre o tempo está envolvido na sua forma explícita, como um sinal de &lt;em&gt;clock&lt;/em&gt;).&lt;/p&gt;
&lt;h2&gt;Process&lt;/h2&gt;
&lt;p&gt;A estrutura utilizada para descrever circuitos sequenciais em VHDL é o &lt;code&gt;process&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Sintaxe de um &lt;code&gt;process&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;nome_opcional&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lista_de_sensibilidade&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;declaracoes&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;primitivas&lt;/span&gt; &lt;span class="n"&gt;sequenciais&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt; &lt;span class="nc"&gt;nome_opcional&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O nome do &lt;code&gt;process&lt;/code&gt; é opcional e serve para identificá-lo durante a simulação. Recomenda-se a sua utilização para melhorar a legibilidade e facilitar a depuração, obviamente usando um nome que representa o circuito sendo descrito. Se optar por retirar o nome, retira-se o &lt;code&gt;nome_opcional&lt;/code&gt;, incluindo o &lt;code&gt;:&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Primitivas sequenciais e concorrentes&lt;/h2&gt;
&lt;p&gt;As primitivas sequenciais dentro de um &lt;code&gt;process&lt;/code&gt; podem ser quaisquer primitivas utilizadas para descrever  circuitos combinatórios (e.g. atribuições condicionais) e também as duas que só podem ser utilizadas de maneira sequencial: &lt;code&gt;if-else&lt;/code&gt; e &lt;code&gt;case&lt;/code&gt;. No entanto, todas as primitivas que estiverem dentro de um &lt;code&gt;process&lt;/code&gt; se &lt;strong&gt;comportam de maneira sequencial&lt;/strong&gt;. Em contraste, as primitivas que estão dentro da descrição uma arquitetura - que só podem ser combinatórias - são consideradas concorrentes.&lt;/p&gt;
&lt;p&gt;As primitivas concorrentes (dentro da arquitetura), representam circuitos combinatórios, portanto serão sintetizadas para tais circuitos. Quaisquer modificações na entrada têm efeito imediato e todas as funções combinatórias descritas terão suas saídas afetadas (após o devido tempo de propagação caso aplicável). É importante notar que um bloco de um &lt;code&gt;process&lt;/code&gt; inteiro é equivalente a uma primitiva combinatória, ou seja, a avaliação das saídas do &lt;code&gt;process&lt;/code&gt; ocorre ao mesmo tempo que a avaliação de todas as primitivas concorrentes da mesma arquitetura, incluindo outros possíveis blocos &lt;code&gt;process&lt;/code&gt; descritos na mesma arquitetura, portanto não é possível aninhar mais de um &lt;code&gt;process&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/sequencial.png' align="right" style="padding-left:5%" /&gt;
Já as primitivas sequencias (dentro de um &lt;code&gt;process&lt;/code&gt;), representam um circuito sequencial nos moldes da figura acima. Qualquer circuito sequencial pode ser mapeado para um circuito com um elemento de memória e uma lógica combinatória dependente do estado atual do circuito, fornecido pelo elemento de memória. Dentro de um &lt;code&gt;process&lt;/code&gt;, as primitivas sequencias são &lt;strong&gt;avaliadas em ordem&lt;/strong&gt; e caso haja divergência (i.e. mais de um valor atribuído para um determinado sinal), prevalece a última primitiva (i.e. o último valor atribuído a um sinal).&lt;/p&gt;
&lt;p&gt;A lógica combinatória dentro de um bloco &lt;code&gt;process&lt;/code&gt; pode ser a identidade (i.e. não possuir lógica que altere os dados, ou em outras palavras representar um fio) e o elemento de memória também pode estar ausente. É possível representar circuitos combinatórios usando &lt;code&gt;process&lt;/code&gt; se descrevermos um circuito sequencial que possua uma lógica combinatória mas não um elemento de memória. Vale lembrar que descrever circuitos combinatórios com &lt;code&gt;process&lt;/code&gt; é uma prática &lt;strong&gt;fortemente desencorajada&lt;/strong&gt;, portanto se o seu circuito não possui um elemento de memória, não utilize &lt;code&gt;process&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Lista de sensibilidade&lt;/h2&gt;
&lt;p&gt;A lista de sensibilidade define o gatilho para o &lt;code&gt;process&lt;/code&gt;. De maneira programática, o &lt;code&gt;process&lt;/code&gt; será ativado quando algum evento acontecer em algum sinal presente na lista de sensibilidade. Se algum sinal da lista for alterado fora do &lt;code&gt;process&lt;/code&gt;, por exemplo, todas as primitivas sequenciais dentro do &lt;code&gt;process&lt;/code&gt; serão avaliadas novamente, em sequencia.&lt;/p&gt;
&lt;p&gt;No entanto, a lista de sensibilidade não representa um elemento sintetizável. Ela é uma indicação para o sintetizador de quais sinais controlam o elemento de memória, ou seja, quando o circuito sequencial que está sendo descrito fará de fato uma amostragem no elemento de memória. Em outras palavras, o sintetizador olha para a lista de sensibilidade na hora de escolher os &lt;em&gt;enables&lt;/em&gt; e os &lt;em&gt;clocks&lt;/em&gt; dos &lt;em&gt;latches&lt;/em&gt; ou &lt;em&gt;flip-flops&lt;/em&gt; que serão usados para construir o elemento de memória. É muito importante que a lista seja feita com cuidado para que o sintetizador possa gerar o circuito sequencial que o projetista deseja. Falhar na construção da lista de sensibilidade pode levar o circuito a comportamentos diferentes do esperado pelo projetista ou até mesmo torná-lo inutilizável. Por este motivo, recomenda-se que o elemento de memória seja descrito usando &lt;code&gt;process&lt;/code&gt;, mas a lógica combinatória dentro do mesmo &lt;strong&gt;seja a mínima necessária&lt;/strong&gt; para o funcionamento do circuito sequencial descrito.&lt;/p&gt;
&lt;p&gt;Na lista de sensibilidade, deve-se colocar todos os sinais que possam alterar o comportamento do componente descrito. Como dica para os iniciantes de prototipação de hardware, coloque na lista de sensibilidade todos e somente todos os sinais que são &lt;strong&gt;lidos&lt;/strong&gt; dentro do &lt;code&gt;process&lt;/code&gt;. Isto pode gerar códigos menos legíveis e até mesmo atrapalhar a otimização do circuito sintetizado, mas evitará a maioria dos problemas que os iniciantes enfrentam quando lidam com descrições sequenciais em VHDL.&lt;/p&gt;
&lt;h2&gt;Wait&lt;/h2&gt;
&lt;p&gt;Uma alternativa para a lista de sensibilidade é a primitiva &lt;code&gt;wait&lt;/code&gt;. Quando opta-se pela utilização desta primitiva, a lista de sensibilidade deve ser omitida, pois o sintetizador irá inferir os sinais de controle dos elementos de memória a partir dos &lt;code&gt;wait&lt;/code&gt; presentes no &lt;code&gt;process&lt;/code&gt;. As formas desta primitiva usadas para descrever circuitos sequenciais são &lt;code&gt;wait until condicao;&lt;/code&gt;, que aguarda até que a condição seja satisfeita e &lt;code&gt;wait on sinal;&lt;/code&gt;, que aguarda o sinal mudar. Tanto a condição quanto o sinal podem ser uma composição de condições (desde que o resultado final seja verdadeiro ou falso) ou uma lista de sinais separados por vírgula.&lt;/p&gt;
&lt;h3&gt;Exemplos&lt;/h3&gt;
&lt;h4&gt;FF-D com enable&lt;/h4&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/ffd.png' align="left" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;ffd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;wait&lt;/span&gt; &lt;span class="k"&gt;until&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="na"&gt;&amp;#39;event&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;q_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt; &lt;span class="nc"&gt;ffd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este exemplo é o mais simples possível: um &lt;em&gt;flip-flop&lt;/em&gt; tipo D. Se o &lt;em&gt;en&lt;/em&gt; for alto, o componente amostra a entrada &lt;code&gt;d&lt;/code&gt; nas saídas &lt;code&gt;q&lt;/code&gt; e &lt;code&gt;q_n&lt;/code&gt; na borda de subida do &lt;em&gt;clock&lt;/em&gt;. Note que o &lt;em&gt;process&lt;/em&gt; não tem lista de sensibilidade, mas a primeira coisa que ele faz é aguardar que aconteça uma mudança no sinal de &lt;em&gt;clock&lt;/em&gt; (espera por &lt;code&gt;clock'event&lt;/code&gt;) e que esta mudança seja a borda de subida (verifica se &lt;code&gt;clock=1&lt;/code&gt;). Quando isto acontecer, ele faz uma verificação para saber se o &lt;code&gt;en=1&lt;/code&gt; e, caso seja, amostra a entrada para as saídas. Note que não está especificado o que acontece com as saídas caso &lt;code&gt;en=0&lt;/code&gt;, o que faz com que a saída não mude, exatamente o comportamento desejado para o &lt;em&gt;flip-flop&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O equivalente usando lista de sensibilidade é:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;ffd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="na"&gt;&amp;#39;event&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt; &lt;span class="nc"&gt;ffd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note que neste caso, os sinais &lt;code&gt;en&lt;/code&gt; e &lt;code&gt;d&lt;/code&gt; podem ficar de fora da lista de sensibilidade pois, apesar de serem lidos dentro do &lt;code&gt;process&lt;/code&gt;, não alteram o comportamento do circuito exceto na borda do &lt;em&gt;clock&lt;/em&gt;, portanto não faz diferença se o colocarmos na lista de sensibilidade: &lt;code&gt;process(clock, en, d)&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;FF-D com enable e reset assíncrono&lt;/h4&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/ffdr.png' align="left" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;ffdr&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;wait&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;q_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;elsif&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="na"&gt;&amp;#39;event&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O &lt;code&gt;process&lt;/code&gt; irá aguardar que aconteça alguma mudança nos sinais &lt;em&gt;clock&lt;/em&gt; ou &lt;em&gt;reset&lt;/em&gt; para continuar. Neste exemplo, o &lt;em&gt;flip-flop&lt;/em&gt; possui um sinal de &lt;em&gt;reset&lt;/em&gt; assíncrono ativo alto, portanto ele é verificado fora da condição de borda de subida. Neste caso, se o &lt;code&gt;reset=1&lt;/code&gt;, as saídas vão para &lt;code&gt;q=0&lt;/code&gt; e &lt;code&gt;q_n=1&lt;/code&gt; incondicionalmente, ignorando-se a borda, portanto o &lt;em&gt;reset&lt;/em&gt; tem prioridade sobre o a amostragem da entrada. Note que neste caso utiliza-se o &lt;code&gt;wait on&lt;/code&gt; e não o &lt;code&gt;wait until&lt;/code&gt;. Qualquer mudança nos sinais &lt;em&gt;clock&lt;/em&gt; ou &lt;em&gt;reset&lt;/em&gt; faz com que o &lt;code&gt;process&lt;/code&gt; passe da linha do &lt;code&gt;wait on clock, reset&lt;/code&gt; e reavalie todas as condições.&lt;/p&gt;
&lt;p&gt;O equivalente usando lista de sensibilidade é:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;ffdr&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;q_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;elsif&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="na"&gt;&amp;#39;event&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q_n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Observe que o &lt;code&gt;wait on&lt;/code&gt; substitui a lista de sensibilidade. Normalmente o &lt;code&gt;wait on&lt;/code&gt; é usado como a primeira primitiva do &lt;code&gt;process&lt;/code&gt;, em substituição à lista de sensibilidade. Para circuitos sequenciais síncronos, aconselha-se a utilização da versão com lista de sensibilidade para evitar que a linha do &lt;code&gt;wait on&lt;/code&gt; seja colocada em locais inadequados, o que pode gerar um circuito sequencial assíncrono. A maioria das ferramentas de síntese suporta somente um &lt;code&gt;wait on&lt;/code&gt; no início ou final do &lt;code&gt;process&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Outras primitivas sequenciais&lt;/h2&gt;
&lt;p&gt;Há outras primitivas exclusivas para utilização sequencial (&lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; e &lt;code&gt;loop&lt;/code&gt;), que possuem propósitos específicos que não foram cobertos neste artigo pois possuem restrições para a síntese. Isto significa que, para que elas representem um hardware, o projetista deve utilizá-las de uma maneira específica, caso contrário elas não podem ser sintetizadas (i.e. não representam uma descrição de hardware). É muito comum entre os iniciantes considerar que estas primitivas são equivalentes às encontradas em linguagens de programação estruturada, o que na maioria das vezes é uma falácia pois não existe laço interativo em hardware equivalente ao conceito homônimo das linguagens de programação (e.g. o equivalente em hardware a um laço iterativo de um algoritmo é na verdade uma máquina de estados completa). Estas primitivas devem ser evitadas na descrição de circuitos sequenciais, especialmente por iniciantes, e são na maioria das vezes usadas somente na construção de &lt;em&gt;testbenchs&lt;/em&gt;, quando as restrições para síntese não se aplicam. Sobre o &lt;code&gt;wait&lt;/code&gt;, ainda existem o &lt;code&gt;wait for tempo;&lt;/code&gt; e o &lt;code&gt;wait;&lt;/code&gt; (só o &lt;em&gt;wait&lt;/em&gt;), mas ambos não são sintetizáveis e também são usados para descrever &lt;em&gt;testbenchs&lt;/em&gt;.&lt;/p&gt;</content><category term="vhdl"></category><category term="sequenciais"></category></entry><entry><title>Circuitos Combinatórios em VHDL</title><link href="https://balbertini.github.io/combinatory-pt_BR.html" rel="alternate"></link><published>2018-09-04T00:23:00-03:00</published><updated>2018-09-13T08:35:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-04:/combinatory-pt_BR.html</id><summary type="html">&lt;p&gt;Como descrever circuitos combinatórios em VHDL.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Circuitos combinatórios&lt;/strong&gt; são aqueles que implementam uma função booleana. Sua principal característica é a ausência de dependência temporal, ou seja, a saída depende apenas da entrada. Este tipo de circuito pode ser representado por uma série de portas lógicas interligadas entre si &lt;strong&gt;sem realimentação&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Há três maneiras de descrever circuitos puramente combinatórios em VHDL: estrutural, atribuição condicional com &lt;code&gt;with-select&lt;/code&gt; e atribuição condicional com &lt;code&gt;when-else&lt;/code&gt;. As descrições realizadas utilizando uma destas três formas serão sintetizadas para circuitos puramente combinatórios.&lt;/p&gt;
&lt;h2&gt;Estrutural&lt;/h2&gt;
&lt;p&gt;A descrição estrutural é a maneira mais direta de se descrever uma função combinatória. Consiste em descrever o circuito a partir da própria função lógica que o representa. O equivalente em um diagrama esquemático é exatamente a &lt;strong&gt;função lógica&lt;/strong&gt;, como descrita usando as portas lógicas equivalentes. A desvantagem é que a descrição é prolixa e consequentemente torna-se rapidamente difícil de ler, razão pela qual não é recomendada para circuitos grandes. Caso opte por este tipo de descrição utilize uma técnica de projeto baseada em divisão e conquista e mantenha os blocos que usam descrição estrutural pequenos, minimizando o esforço necessário para compreender o seu funcionamento.&lt;/p&gt;
&lt;p&gt;VHDL suporta os seguintes &lt;strong&gt;operadores lógicos&lt;/strong&gt; para descrever circuitos estruturais:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Operador&lt;/th&gt;
&lt;th align="left"&gt;Descrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;not&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;complemento&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;E&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;OU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;nand&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;E-negado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;nor&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;OU-negado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;OU-exclusivo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;&lt;code&gt;xnor&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;OU-exclusivo-negado&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Os operadores estão em ordem decrescente de prioridade, ou seja, o &lt;code&gt;not&lt;/code&gt; tem precedência sobre todos os demais operadores. Aconselha-se a utilização de parênteses &lt;code&gt;()&lt;/code&gt; para deixar claro a intenção do projetista. Todos os operadores podem operar sobre tipos booleanos, bits ou vetores unidimensionais de bits (bits podem ser do tipo &lt;code&gt;bit&lt;/code&gt; ou derivados como &lt;code&gt;std_logic&lt;/code&gt;). É necessário que os operandos sejam do mesmo tamanho e o resultado é sempre igual à entrada (i.e. se os operandos são vetores de bits, o resultado é um vetor de bits). Quando o tipo é um vetor, o resultado é calculado bit a bit (lógica binária ou &lt;em&gt;bitwise&lt;/em&gt;).&lt;/p&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/mux.png' align="left" style="padding-right:5%" /&gt;
Este exemplo é um multiplexador 2x1 com entradas &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt;, saída &lt;code&gt;o&lt;/code&gt; e seletor &lt;code&gt;s&lt;/code&gt;. As entradas podem ser vetores (e.g. &lt;code&gt;bit_vector(3 downto 0)&lt;/code&gt;), mas nesse caso é necessário que o seletor &lt;code&gt;s&lt;/code&gt; também seja um vetor do mesmo tamanho.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;With-select&lt;/h2&gt;
&lt;p&gt;O &lt;code&gt;with-select&lt;/code&gt; é a representação da &lt;strong&gt;tabela verdade&lt;/strong&gt; de uma função lógica. Não há equivalente em um diagrama esquemático. O mais próximo seria uma LUT (&lt;em&gt;LookUp Table&lt;/em&gt;), mas a síntese não necessariamente utiliza esta abordagem (e.g. dependendo das otimizações feitas pelo sintetizador, pode ser feita usando um arranjo de portas lógicas que implemente a função equivalente).&lt;/p&gt;
&lt;p&gt;Sintaxe do &lt;code&gt;with-select&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;sinalSelecao&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;sinalSaida&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;
  &lt;span class="n"&gt;valorSaida1&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;valorSelecao1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;valorSaida2&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;valorSelecao2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;valorSaida3&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="k"&gt;others&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No &lt;code&gt;with-select&lt;/code&gt;, a atribuição ao &lt;code&gt;sinalSaida&lt;/code&gt; é feita através de uma comparação de igualdade com o sinal de seleção &lt;code&gt;sinalSelecao&lt;/code&gt;. O valores a serem comparados são os expressos como &lt;code&gt;valorSelecao&lt;/code&gt; (e.g. se a o valor do sinal &lt;code&gt;sinalSelecao&lt;/code&gt; for igual a &lt;code&gt;valorSelecao1&lt;/code&gt;, o sinal &lt;code&gt;sinalSaida&lt;/code&gt; será &lt;code&gt;valorSaida1&lt;/code&gt;). Não é necessário que o número de entradas seja múltiplo de uma potência de dois e os valores de saída &lt;code&gt;valorSaida&lt;/code&gt; podem ser outros sinais ou expressões. Os valores para comparação devem ser constantes ou serem passíveis de resolução (i.e. não devem ser variáveis ou valores transitivos). Tanto a entrada de seleção quando a saída podem ser vetores. &lt;strong&gt;Atenção:&lt;/strong&gt; é fortemente recomendada a descrição da &lt;a href="#others"&gt;opção padrão&lt;/a&gt; (comparação com &lt;code&gt;others&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;table align="left" style="border-right: 30px solid #fff;"&gt;
  &lt;tr&gt;&lt;th&gt;s&lt;/th&gt;&lt;th&gt;a&lt;/th&gt;&lt;th&gt;b&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;o&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Este exemplo é um multiplexador 2x1 com entradas &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt;, saída &lt;code&gt;o&lt;/code&gt; e seletor &lt;code&gt;s&lt;/code&gt;. Lembre-se que um seletor de um multiplexador deve ter tamanho &lt;code&gt;ceil(log2(n))&lt;/code&gt;, onde &lt;code&gt;n&lt;/code&gt; é o número de entradas, portanto é possível que ele seja um vetor. Neste exemplo, como há duas entradas, o seletor &lt;code&gt;s&lt;/code&gt; tem somente um bit (&lt;code&gt;ceil(log2(2))=1&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Versão com saídas como constantes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;bit_vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;-- Declaração&lt;/span&gt;
&lt;span class="n"&gt;sel&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;-- Concatenação&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;000&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;001&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;010&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;011&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;100&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;101&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;110&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="k"&gt;others&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note que este é um trecho de código de uma descrição: a declaração do sinal deve estar no local apropriado dentro da arquitetura (antes do &lt;code&gt;begin&lt;/code&gt;), assim como a atribuição ao sinal &lt;code&gt;sel&lt;/code&gt; (concatenação, depois do &lt;code&gt;begin&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Versão com saídas como sinais:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="k"&gt;others&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A vantagem é muito clara quando se tem uma função lógica expressa na forma de uma tabela verdade. No entanto, esta opção tem a desvantagem de ser prolixa. Note a diferença entre as duas versões acima: a &lt;em&gt;versão com as saídas como sinais&lt;/em&gt; é compacta e passível de utilização. Já a &lt;em&gt;versão com saídas como constantes&lt;/em&gt; é uma transcrição da tabela verdade e pode se tornar impraticável (ou ilegível) rapidamente pois a tabela cresce exponencialmente ao número de entradas (lembre-se que a tabela verdade terá &lt;code&gt;2^n&lt;/code&gt; linhas, onde &lt;code&gt;n&lt;/code&gt; é o número de entradas).&lt;/p&gt;
&lt;h2&gt;When-else&lt;/h2&gt;
&lt;p&gt;O &lt;code&gt;when-else&lt;/code&gt; é uma maneira fácil de descrever funcionalmente um circuito com várias funções lógicas. O equivalente a um diagrama esquemático é um &lt;strong&gt;multiplexador&lt;/strong&gt;, cujas entradas são funções lógicas.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/mux_exp.png' align="left" style="padding-right:5%" /&gt;
Sintaxe do &lt;code&gt;when-else&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sinal&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;expressao1&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;condicao1&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt;
         &lt;span class="n"&gt;expressao2&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;condicao2&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt;
         &lt;span class="n"&gt;expressao3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A atribuição acontece de acordo com a primeira condição atendida, em ordem (e.g. se a &lt;code&gt;condicao1&lt;/code&gt; for atendida, o &lt;code&gt;sinal&lt;/code&gt; será &lt;code&gt;expressao1&lt;/code&gt; e as demais condições não serão avaliadas). &lt;strong&gt;Atenção:&lt;/strong&gt; é fortemente recomendada a descrição da &lt;a href="#others"&gt;opção padrão&lt;/a&gt; (atribuição para a &lt;code&gt;expressao3&lt;/code&gt; no &lt;code&gt;else&lt;/code&gt; final sem condição), que será a atribuição caso nenhuma condição for atendida.&lt;/p&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/vhdl/mux2x1.png' align="left" style="padding-right:5%" /&gt;
Este exemplo é um multiplexador 2x1 com entradas &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt;, saída &lt;code&gt;o&lt;/code&gt; e seletor &lt;code&gt;s&lt;/code&gt;. As entradas podem ser vetores (e.g. &lt;code&gt;bit_vector(3 downto 0)&lt;/code&gt;). Lembre-se que um seletor de um multiplexador deve ter tamanho &lt;code&gt;ceil(log2(n))&lt;/code&gt;, onde &lt;code&gt;n&lt;/code&gt; é o número de entradas, portanto é possível que ele seja um vetor. Neste exemplo, como há duas entradas, o seletor &lt;code&gt;s&lt;/code&gt; tem somente um bit (&lt;code&gt;ceil(log2(2))=1&lt;/code&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="others"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Opção padrão&lt;/h2&gt;
&lt;p&gt;Os operadores em VHDL possuem uma opção padrão indicada pela palavra chave &lt;code&gt;others&lt;/code&gt; ou no último &lt;code&gt;else&lt;/code&gt;, que será a atribuição a ser realizada caso nenhuma condição anterior for atendida. Se a opção padrão não for especificada, a atribuição é considerada uma &lt;em&gt;atribuição incompleta&lt;/em&gt; e a síntese poderá inferir um &lt;em&gt;latch&lt;/em&gt;, tornando o circuito sequencial. Uma maneira fácil de especificar a opção padrão é deixar o último valor possível sem escolha, ou seja, caso nenhuma das opções anteriores atenda a atribuição condicional, a última opção será tomada.&lt;/p&gt;
&lt;p&gt;Quando se utiliza tipos &lt;code&gt;std_logic&lt;/code&gt; e derivados, também é comum a opção padrão ser a atribuição para &lt;code&gt;X&lt;/code&gt; (valor desconhecido ou &lt;em&gt;unknown&lt;/em&gt;), mas não recomendo esta abordagem pois o valor &lt;code&gt;X&lt;/code&gt; não é sintetizável. Para simulação e depuração, o valor será mostrado como &lt;code&gt;X&lt;/code&gt;, o que pode facilitar a depuração do circuito. Contudo, após a síntese a atribuição &lt;code&gt;X&lt;/code&gt; irá assumir um valor binário, o que torna difícil a identificação de problemas com o circuito funcionando pois pode não ser possível distinguí-lo de um valor legítimo.&lt;/p&gt;
&lt;p&gt;É &lt;strong&gt;fortemente recomendada&lt;/strong&gt; a utilização da opção padrão quando se utiliza as construções &lt;code&gt;when-else&lt;/code&gt; ou &lt;code&gt;with-select&lt;/code&gt; para descrever circuitos combinatórios pois, se a atribuição for incompleta o circuito pode não operar como desejado.&lt;/p&gt;
&lt;h2&gt;Outras maneiras&lt;/h2&gt;
&lt;p&gt;Há outras maneiras de se descrever circuitos combinatórios em VHDL. Dois exemplos comuns que &lt;strong&gt;não são  recomendados&lt;/strong&gt; utilizam o &lt;code&gt;case&lt;/code&gt; e o &lt;code&gt;if-else&lt;/code&gt;. Este tipo de descrição é fácil de ser encontrado pois utiliza primitivas similares às encontradas em linguagens de programação estruturadas (e.g. C/C++, Java, etc).&lt;/p&gt;
&lt;p&gt;Os dois exemplos abaixo são de um multiplexador 2x1 com entradas &lt;code&gt;a&lt;/code&gt; e &lt;code&gt;b&lt;/code&gt;, saída &lt;code&gt;o&lt;/code&gt; e seletor &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Com &lt;code&gt;case&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;-- NÃO UTILIZE / DO NOT USE&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="k"&gt;others&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Com &lt;code&gt;if-else&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;-- NÃO UTILIZE / DO NOT USE&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;process&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Estas duas descrições são consideradas &lt;strong&gt;inadequadas&lt;/strong&gt; do ponto de vista de boas práticas em descrições de hardware e são &lt;strong&gt;fortemente desencorajadas&lt;/strong&gt;. O principal motivo é que utilizam primitivas que devem estar dentro de um bloco sequencial do tipo &lt;code&gt;process&lt;/code&gt;. Apesar de estarem corretas do ponto de vista sintático, este tipo de descrição é considerada errada do ponto de vista semântico, pois há a utilização de uma primitiva sequencial para descrever um circuito combinatório. Em outras palavras, você está dizendo ao sintetizador que quer descrever um circuito sequencial, mas na verdade está descrevendo um circuito combinatório.&lt;/p&gt;
&lt;p&gt;As descrições acima serão sintetizadas corretamente para um multiplexador combinatório pois não possuem erros e os sintetizadores conseguirão perceber que se trata de um circuito combinatório mesmo na presença do &lt;code&gt;process&lt;/code&gt;. No entanto, qualquer deslize (e.g. atribuição incompleta, esquecer um sinal na lista de sensibilidade, etc.) induzirá o sintetizador a inserir &lt;em&gt;latches&lt;/em&gt; ou &lt;em&gt;flip-flops&lt;/em&gt; no caminho de dados. A inserção destes elementos sequenciais em um circuito puramente combinatório pode torná-lo sequencial ou até mesmo inutilizar o circuito. O funcionamento do circuito pode não ser o esperado, diferindo da intenção do projetista.&lt;/p&gt;
&lt;p&gt;Lembre-se que estas duas últimas descrições são &lt;strong&gt;fortemente desencorajadas&lt;/strong&gt; para descrever circuitos combinatórios e devem ser evitadas para este propósito. Utilize uma das três opções no começo desta página para descrever o seu circuito combinatório. &lt;strong&gt;Atenção:&lt;/strong&gt; se você é meu aluno não utilize descrições de circuitos combinatórios usando &lt;code&gt;process&lt;/code&gt; em nenhuma hipótese.&lt;/p&gt;</content><category term="vhdl"></category><category term="combinatorios"></category></entry></feed>