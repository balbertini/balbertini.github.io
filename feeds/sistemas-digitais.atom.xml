<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>B.Albertini's site - sistemas digitais</title><link href="https://balbertini.github.io/" rel="alternate"></link><link href="https://balbertini.github.io/feeds/sistemas-digitais.atom.xml" rel="self"></link><id>https://balbertini.github.io/</id><updated>2018-12-17T12:03:00-02:00</updated><entry><title>Algorithmic State Machines</title><link href="https://balbertini.github.io/asm-pt_BR.html" rel="alternate"></link><published>2018-12-17T12:03:00-02:00</published><updated>2018-12-17T12:03:00-02:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-12-17:/asm-pt_BR.html</id><summary type="html">&lt;p&gt;ASM (Algorithmic State Machines)&lt;/p&gt;</summary><content type="html">&lt;p&gt;A máquina de estados algorítmica, do inglês &lt;em&gt;Algorithmic State Machine&lt;/em&gt; (ASM), é uma forma gráfica de descrição de um circuito síncrono. Assim como os diagramas de transição de estados, a ASM captura o comportamento do circuito em um nível abstrato, mas sintetizável.&lt;/p&gt;
&lt;h2&gt;Elementos gráficos&lt;/h2&gt;
&lt;h3&gt;Estado&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_estado.png' width="20%" align="right" style="padding-left:5%" /&gt;
Um estado é representado por uma caixa quadrada com arestas orientadas entrando e saindo do estado. As arestas sempre são as mesmas duas, sem exceção. A aresta superior pode vir de um outro elemento ASM anterior a este estado na sequencia imposta pela máquina, ou não possuir nenhuma origem, o que imlica que este estado é o inicial (estado após o &lt;em&gt;reset&lt;/em&gt;) da máquina. Lembre-se que somente um estado da máquina toda pode ser o estado inicial. Já a aresta inferior liga este estado ao próximo elemento na sequencia imposta pela máquina e não é opcional: deve existir e ser conectada a algum outro elemento.  &lt;/p&gt;
&lt;p&gt;O nome do estado e o seu código (em binário) são considerados obrigatórios por alguns autores. No entanto, dependendo do método de síntese adotado, a codificação não se faz necessária. Também alguns autores circulam o nome do estado, em alguns casos deixando-o também na lateral esquerda da caixa. Em sistemas digitais usamos a notação sobre a caixa (à esquerda), sem circular o nome do estado, e consideramos a codificação opcional exceto quando solicitado explicitamente.  &lt;/p&gt;
&lt;p&gt;A saída representa exatamente os sinais de saída deste estado. Por convenção, só é necessário listar os sinais ativos neste estado, pois considera-se que todas as saídas da máquina não listadas em um estado assumem o valor desativado. Lembre-se que o valor ativo de um sinal depende da lógica que está utilizando (normalmente o valor ativo é alto, ou 1). Para evitar confusão, liste sempre todos os sinais que assumem o valor 1 pois quando não dizemos nada assume-se implicitamente (convenção) que a lógica é positiva. Sinais não listados que possuam mais de um bit assumem desativado (i.e. zero) para todos os bits.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Decisor&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_decisor.png' width="30%" align="right" style="padding-left:3%" /&gt;
O decisor é o componente que faz a transição condicional entre os estados. Sem ele, toda transição seria incondicional e não dependeria de entrada alguma. É representado graficamente por um losango, com uma aresta orientada de entrada e duas de saída. A aresta de entrada é proveniente de um elemento sequencialmente anterior da máquina de estados e deve obrigatoriamente ter uma origem. As arestas de saída são condicionais, ou seja, caso a condição do decisor seja verdadeira, a máquina segue pelo caminho 1, caso contrário pelo caminho 0. É importante notar que há duas e somente duas arestas de saída, uma para o caso da condição ser falsa e outra verdadeira. Não há condição com múltiplos bits ou múltiplas saídas e as duas saídas devem ser conectadas em outro elemento ASM.&lt;br&gt;
A condição sempre deve ser uma condição resolvível em lógica booleana, retornando sempre verdadeiro ou falso (1 ou 0). É tolerável inverter as saídas de lado para facilitar o diagrama, assim como desenhar uma seta saindo na ponta inferior do losango, mas prefira sempre usar o desenho padrão como no exemplo ao lado (incluindo os lados de saída para verdadeiro e falso) para garantir que está seguindo as boas práticas.   &lt;/p&gt;
&lt;p&gt;Este componente é atemporal, ou seja, não representa tampouco depende do tempo. Isso implica que é um componente puramente combinatório e deve estar inserido em um caminho válido entre dois elementos sequenciais, que em ASM são os estados. É permitido cascatear múltiplos decisores, mas não deve-se retornar para caminhos atemporais (e.g. um decisor voltar para ele mesmo ou para um caminho atemporal; veja no final do post os erros mais comuns).  &lt;/p&gt;
&lt;p&gt;Há também um símbolo alternativo que é um hexágono achatado, com o mesmo significado do losango. Apesar de pouco utilizado, este símbolo é útil quando a condição tem um nome extenso.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Saída condicional&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_saidaCondicional.png' width="15%" align="right" style="padding-left:5%" /&gt;
As saídas listadas dentro de um estado são as que serão ativadas durante o tempo em que a máquina permanecer naquele estado. Contudo, há casos em que a saída não depende somente do estado mais também da saída (i.e. máquina de Mealy). Para este tipo de saída, existe a representação de saída condicional, sujo símbolo é um retângulo oblongo com as laterais arrendondadas ao máximo possível (i.e. um semi-círculo). Há uma aresta direcional de entrada e uma de saída. A aresta de saída deve ser conectada a qualquer outro elemento ASM, porém este também é um componente atemporal e deve estar em um caminho válido entre dois estados. Assim como o decisor, este componente não tem dependência temporal, sendo puramente combinatório. A entrada de uma saída condicional deve necessariamente originar-se da saída de um grupo de decisores (que pode ser unitário). A condição, por consequência, indicará a condição para que esta saída seja ativada.  &lt;/p&gt;
&lt;p&gt;Assim como a lista de saídas em um estado, a lista de saídas de uma saída condicional apresenta a lista de sinais que devem ser ativados quando a máquina estiver com este caminho ativo, ou seja, a condição do grupo de decisores que a antecedem for satisfeita. Note que, enquanto a máquina estiver no estado em que os decisores estão ativos, mudar a condição pode levar os decisores a ativar outro caminho, alterando o estado de ativação de uma saída condicional dependente destes decisores.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Junção&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_juncao.png' width="15%" align="right" style="padding-left:5%" /&gt;
A junção é o componente que permite juntar dois caminhos diferentes em direção a outro estado. É composta por um ponto onde chegam duas arestas direcionais e sai somente uma. Este componente deve ser desenhado na forma como está, tolerando-se que as arestas sejam desenhadas em diferentes posições ao redor do ponto, mantidas duas de entrada e uma de saída. Todas as arestas devem ter como origem ou destino um elemento ASM, incluindo outra junção, mas devem estar em um caminho sequencial (entre dois estados) pois, assim como o decisor e a saída condiciona, a junção não possui dependência temporal.  &lt;/p&gt;
&lt;p&gt;Observe que o ponto foi exagerado no exemplo ao lado. Quando desenhar sua máquina, use somente um ponto onde fique clara a convergência de duas arestas de entrada e uma de saída. De fato, em desenhos feito usando auxílio de ferramentas computacionais, é comum omitir a junção, desde que fique clara a convergência. Também é possível uma junção com mais de duas arestas de entrada, mas sempre há somente uma aresta de saída.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Outros elementos gráficos&lt;/h3&gt;
&lt;p&gt;Alguns autores permitem uma condição em uma aresta, logo após a saída do estado e antes de qualquer outro bloco. Para isto, basta escrever o nome de uma condição booleana ao lado da aresta. Isto implica que o estado irá transicionar para aquela transição caso a condição seja verdadeira, ou não irá transicionar caso seja falsa, permanecendo no mesmo estado. Este tipo de mecanimso está relacionado ao &lt;em&gt;clock enable&lt;/em&gt; presente em &lt;em&gt;flip-flops&lt;/em&gt;. A condição é exatamente o &lt;em&gt;enable&lt;/em&gt;, prevenindo que o &lt;em&gt;flip-flop&lt;/em&gt; transicione caso seja falsa. Contudo, deve-se evitar este tipo de transição, especialmente se você é iniciante, pois: (i) nem todo &lt;em&gt;flip-flop&lt;/em&gt; conta com um &lt;em&gt;clock enable&lt;/em&gt;, e (ii) esta transição não deve permitir que o próximo estado seja acionado, complicando desnecessariamente a síntese. Nem pense em inserir uma porta no caminho do &lt;em&gt;clock&lt;/em&gt; para implementar um &lt;em&gt;clock enable&lt;/em&gt; pois as implicações podem ser bem desastrosas. Em suma: não use este tipo de construção exceto se souber o que está fazendo.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Fluxo de um diagrama ASM&lt;/h2&gt;
&lt;p&gt;Um diagrama ASM tem um fluxo simples: sai de um estado ativo e vai para o próximo. O estado ativo inicialmente é sempre aquele que é o destino da única aresta sem origem do diagrama. É possível que entre esta aresta e o estado existam junções, mas nenhum outro componente é permitido entre a aresta que representa o &lt;em&gt;reset&lt;/em&gt; e o estado inicial.&lt;/p&gt;
&lt;p&gt;A partir de um estado inicial, segue-se a analogia de circuitos chaveados: o estado ativo no momento ativa todos os elementos que estão ligados em sua saída. É possível que haja um decisor entre um estado e outro, indicando que esta é uma transição condicional: dependendo da condição ser atendida ou não, a máquina segue para um estado ou para outro. No momento da transição (sinal de &lt;em&gt;clock&lt;/em&gt;), o estado que possuir sua entrada ativa é ativado e o anterior desativado. É permitido um estado ativar-se a si mesmo bastando colocar na sua entrada uma junção,  ligando-se uma das entradas da junção à saída do estado, fazendo um laço (ou &lt;em&gt;loop&lt;/em&gt;). No entanto, não é permitido que o fluxo ative dois estados. Cada transição sai de um estado e vai para outro de forma determinística e não ambígua. Caso não seja especificado, assume-se que a transição acontece na borda de subida do &lt;em&gt;clock&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Normalmente os diagramas ASM são desenhados na vertical, com o estado inicial acima na página e o final abaixo. Não há limitações em desenhá-lo em outra orientação, mas evite fugir do usual. Jamais mude a orientação do diagrama no meio do desenho (e.g. inicia-se superior e no meio do diagrama parte-se para a direita) para não dar margem a interpretações ambíguas.&lt;/p&gt;
&lt;h3&gt;Exemplo 1: máquina de detectar 1001 com sobreposição (Moore)&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_exemplo1.png' width="30%" align="left" style="padding-right:5%" /&gt;
Esta máquina possui uma entrada &lt;code&gt;e&lt;/code&gt; e uma saída &lt;code&gt;z&lt;/code&gt;. A saída &lt;code&gt;z&lt;/code&gt; é alta quando a sequencia 1001 é detectada na entrada &lt;code&gt;e&lt;/code&gt;, com sobreposição.&lt;/p&gt;
&lt;p&gt;A máquina pode ser vista ao lado, com os estados &lt;code&gt;ini&lt;/code&gt;,&lt;code&gt;S1&lt;/code&gt;,&lt;code&gt;S10&lt;/code&gt;,&lt;code&gt;S100&lt;/code&gt; e &lt;code&gt;S1001&lt;/code&gt;. O estado &lt;code&gt;ini&lt;/code&gt; é o único que possui uma aresta com origem indeterminada, portanto é o estado inicial. Note que entre esta aresta e o estado há somente uma junção, o que é permitido. A única saída da máquina, &lt;code&gt;z&lt;/code&gt;, é ativada somente no estado &lt;code&gt;S1001&lt;/code&gt;, portanto todos os outros estados não possuem lista de saída. Esta máquina não possui nenhuma saída condicional, portanto representa uma máquina de Moore.  &lt;/p&gt;
&lt;p&gt;Enquanto o estado &lt;code&gt;ini&lt;/code&gt; está ativo, sua saída também está, portanto o decisor abaixo deste estado está ativo. Este decisor possui como condição a entrada &lt;code&gt;e&lt;/code&gt;, o que implica que se a entrada for verdadeira (1) a máquina segue para a direita, caso contrário para a esquerda. Se &lt;code&gt;e=0&lt;/code&gt;, o destino do decisor é uma nova junção que acaba ativando o próprio estado &lt;code&gt;ini&lt;/code&gt;, portanto na borda de subida do &lt;em&gt;clock&lt;/em&gt; a máquina transicionará para o mesmo estado, ou seja, não há efeito sobre a máquina. É importante notar que a máquina não deixa de transicionar, apenas transiciona para o mesmo estado. Caso &lt;code&gt;e=1&lt;/code&gt; a máquina transiciona para a direita, ativando o estado &lt;code&gt;S1&lt;/code&gt;. Neste caso, na próxima borda de subida do &lt;em&gt;clock&lt;/em&gt;, o estado ativo passará a ser o &lt;code&gt;S1&lt;/code&gt;, portanto todos os elementos abaixo de &lt;code&gt;ini&lt;/code&gt; serão desativados e os elementos abaixo de &lt;code&gt;S1&lt;/code&gt; serão ativados.&lt;/p&gt;
&lt;p&gt;Com &lt;code&gt;S1&lt;/code&gt; ativo, repete-se a análise, mas desta vez o destino será o &lt;code&gt;S10&lt;/code&gt; se &lt;code&gt;e=0&lt;/code&gt; ou &lt;code&gt;S1&lt;/code&gt; se &lt;code&gt;e=1&lt;/code&gt;. É importante notar que os caminhos ativam-se com a mudança da entrada, portanto se a entrada mudar o decisor também muda o caminho ativo. O caminho que será seguido é o caminho ativo no momento da borda do &lt;em&gt;clock&lt;/em&gt;. Lembre-se que estes componentes (decisores e junções) são combinatórios, com os atrasos inerentes deste tipo de circuito, e os estados são elementos síncronos também com atrasos e ainda susceptíveis a violações nos tempos de &lt;em&gt;setup&lt;/em&gt; e &lt;em&gt;hold&lt;/em&gt;. Mudar a entrada entre duas bordas de &lt;em&gt;clock&lt;/em&gt; não altera o comportamento da máquina e a esta transicionará para o caminho ativo no momento da borda, mas caso mude-se a entrada muito próximo da borda do &lt;em&gt;clock&lt;/em&gt;, deve-se levar em consideração os tempos envolvidos ou a máquina poderá transicionar erroneamente.&lt;/p&gt;
&lt;p&gt;Se continuarmos a análise, invariavelmente chegaremos no &lt;code&gt;S1001&lt;/code&gt;, que contém a saída &lt;code&gt;z&lt;/code&gt; na sua lista de saídas. Isto significa que quanto este estado estiver ativo, a saída também estará. A única maneira de chegarmos neste estado é a entrada assumir os valores &lt;code&gt;1001&lt;/code&gt; antes de cada borda de subida do &lt;em&gt;clock&lt;/em&gt;, portanto o estado &lt;code&gt;S1001&lt;/code&gt; é literalmente o estado onde a máquina detecta que observou o valor correto na entrada. Observe também a transição a partir deste estado: elas não voltam para o estado &lt;code&gt;ini&lt;/code&gt; e sim para os estados correspondentes a sobreposição. E.g. se após detectarmos uma sequencia começarmos outra (&lt;code&gt;1001001&lt;/code&gt;), a máquina produzirá saída &lt;code&gt;z=1&lt;/code&gt; em ambos os &lt;code&gt;1&lt;/code&gt; depois do primeiro.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h3&gt;Exemplo 2: máquina de detectar 1001 com sobreposição (Mealy)&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_exemplo2.png' width="30%" align="left" style="padding-right:5%" /&gt;
Esta máquina é similar a do Exemplo 1. Há uma única diferençaestá na geração da saída, que é dependente da entrada, caracterizando a máquina como Mealy.&lt;/p&gt;
&lt;p&gt;Até o estado &lt;code&gt;S100&lt;/code&gt; a máquina tem comportamento idêntico à máquina do Exemplo 1. A partir do estado &lt;code&gt;S100&lt;/code&gt;, caso a entrada &lt;code&gt;e=0&lt;/code&gt;, a máquina transicionará para a esquerda (indo para o estado &lt;code&gt;ini&lt;/code&gt; pois detectou-se a sequencia errada &lt;code&gt;1000&lt;/code&gt; na entrada). Mas caso &lt;code&gt;e=1&lt;/code&gt;, o caminho ativado será o da direita. Como neste caminho temos uma saída condicional, a saída &lt;code&gt;z&lt;/code&gt; estará ativa enquanto este caminho estiver ativo, ou seja, enquanto a máquina estiver no estado &lt;code&gt;S100&lt;/code&gt; e a entrada for &lt;code&gt;e=1&lt;/code&gt;. A saída condicional também é um elemento combinatório, portanto a saída &lt;code&gt;z&lt;/code&gt; será &lt;code&gt;1&lt;/code&gt; assim que a entrada mudar para &lt;code&gt;1&lt;/code&gt; (e os atrasos de propagação forem atendidos). Se durante o estado &lt;code&gt;S100&lt;/code&gt;(entre a borda de subida do &lt;em&gt;clock&lt;/em&gt; onde este estado foi ativado e antes da próxima borda de subida) mudarmos o valor da entrada, também mudaremos o valor da saída! Esta é uma característica das máquinas Mealy, onde a saída depende não somente do estado mas também das entradas.&lt;/p&gt;
&lt;p&gt;Mas é possível escrever uma saída também na lista dos estados. Por exemplo: suponha que queiramos uma saída secundária &lt;code&gt;y&lt;/code&gt;, que é alta quando a máquina detectar &lt;code&gt;10&lt;/code&gt; durante a detecção da sequencia principal. Bastaria para isso escrever &lt;code&gt;y&lt;/code&gt; dentro do estado &lt;code&gt;S10&lt;/code&gt;. Ao atingir este estado, a máquina ativa a saída &lt;code&gt;y&lt;/code&gt;. Isto está correto, mas não misturamos uma saída Moore com uma saída Mealy? É comum o entendimento de que em ASM pode-se fazer máquinas mistas, ou seja, com saídas dependentes somente do estado e saídas dependentes do estado e da entrada, na mesma máquina. Não se engane: isto é uma falácia pois uma máquina deste tipo é uma máquina Mealy. Se há uma saída qualquer na máquina que dependa de uma entrada, a máquina deve ser classificada como Mealy. Em ASM é possível que uma mesma saída seja escrita em um estado e em uma saída condicional, portanto esta saída será ativa quando atingir-se aquele estado e quando ativar-se aquele caminho. Este poder de expressão não existe em um diagrama de transição de estados e costuma confundir quem está aprendendo, mas não implica em máquina mista e sim numa máquina de Mealy.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;!--
### Síntese de ASM

### Erros comuns
erros na montagem do fluxo
pseudo-código na asm, Confusão com fluxograma

 --&gt;

&lt;hr&gt;
&lt;h2&gt;Quando devo usar ASM?&lt;/h2&gt;
&lt;p&gt;O diagrama ASM foi criado na década de 70 e esquecido desde então pois na maioria das vezes a síntese de uma ASM é feita usando &lt;em&gt;one-hot-encoding&lt;/em&gt;, onde cada estado é um &lt;em&gt;flip-flop&lt;/em&gt; (em FSM usamos &lt;span class="math"&gt;\(\lceil log_2{n} \rceil\)&lt;/span&gt; &lt;em&gt;flip-flops&lt;/em&gt; para &lt;span class="math"&gt;\(n\)&lt;/span&gt; estados). Naquela época, este tipo de síntese era inaceitável pois um &lt;em&gt;flip-flop&lt;/em&gt; era caro para se desperdiçar em um único estado, então os projetistas digitais preferiam sintetizar a máquina com a melhor otimização possível em relação ao número de &lt;em&gt;flip-flops&lt;/em&gt;, não raramente feita manualmente. No entanto, com o advento dos sintetizadores modernos, você pode expressar-se usando uma ASM e o sintetizador irá gerar um hardware tão otimizado ou até mais otimizado que o feito manualmente. Além disso, se você estiver usando FPGA para prototipar seu hardware, o sintetizador provavelmente irá usar &lt;em&gt;one-hot-encoding&lt;/em&gt; de qualquer forma devido a organização interna destes dispositivos.&lt;/p&gt;
&lt;p&gt;A vantagem de se utilizar ASM é que o diagrama é muito próximo de um pseudo-algoritmo, incluindo os nomes das entradas e saídas (normalmente ausentes em um diagrama de transição de estados). É muito comum começar um projeto digital com uma prova de conceito em software que resolva o problema. Neste sentido, partir para uma ASM, especialmente quando utiliza-se metodologias de divisão e conquista (e.g. fluxo de dados e unidade de controle), facilita o trabalho do projetista evitando erros e aumentando a legibilidade, sem prejudicar a qualidade do hardware gerado. Por estas razões, a utilização de ASM vem crescendo e é comum vê-las em projetos digitais. VHDL e Verilog, as duas linguagens de descrição de hardware mais comuns, contam com padrões onde é possível expressar uma ASM facilmente. Há diversas ferramentas que suportam ASM (inclusive graficamente) e há até mesmo uma linguagem totalmente dedicada à expressão de diagramas ASM (&lt;a href="http://www.epyme.uva.es/asm++"&gt;ASM++&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Se você tem um pseudo-código ou um algoritmo que resolve o seu problema, parta para uma ASM sem medo.&lt;/p&gt;
&lt;!-- Analogia com redes de petri

Diferença entre FSM , psudo-código na asm--&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="asm"></category></entry><entry><title>Exercício: Associação de Contadores</title><link href="https://balbertini.github.io/er0002-pt_BR.html" rel="alternate"></link><published>2018-10-12T12:28:00-03:00</published><updated>2018-10-12T12:28:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-12:/er0002-pt_BR.html</id><summary type="html">&lt;p&gt;Exercício resolvido de sistemas digitais: associação de contadores.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Assunto: Associação de contadores&lt;/p&gt;
&lt;h2&gt;Enunciado&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20181012_associacaoContadores.png' align="left" width="50%" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;p&gt;Mostra-se no circuito ao lado uma associação de contadores. Sabe-se que o &lt;em&gt;load&lt;/em&gt; é síncrono e o &lt;em&gt;reset&lt;/em&gt; assíncrono.&lt;br&gt;
Pede-se: (i) o módulo da contagem e (ii) as formas de onda nos pontos A e B.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Solução&lt;/h2&gt;
&lt;p&gt;Os contadores são de módulo 16, ou seja, tem capacidade de contar de 0000 (0) a 1111 (15). O contador A está em um arranjo onde ele se auto-carrega de 0101 (5) quando seu valor atingir 1001 (9), formando um contador de 5 a 9, ou seja, módulo 5. O contador B está em um arranjo onde ele se auto-reseta quando sua contagem for 0011 (3). Contudo, como o &lt;em&gt;reset&lt;/em&gt; é assíncrono, assim que este valor é atingido o contador reseta-se de imediato, portanto os valores de contagem são de 0000 (0) a 0010 (2), ou seja, módulo 3.&lt;/p&gt;
&lt;p&gt;Os contadores ainda estão em cascata, onde o valor de carga do contador A (1001) é usado como &lt;em&gt;enable&lt;/em&gt; para o contador B. Nesse arranjo em cascata, mesmo que o &lt;em&gt;clock&lt;/em&gt; seja comum a ambos, podemos dizer que o contador B conta uma vez para cada ciclo completo de contagem do contador A.&lt;/p&gt;
&lt;p&gt;O módulo da contagem total é 15. O ciclo de contagem em regime será: 0101 0000, 0110 0000, 0111 0000, 1000 0000, 1001 0000, 0101 0001, 0110 0001, 0111 0001, 1000 0001, 1001 0001, 0101 0010, 0110 0010, 0111 0010, 1000 0010, 1001 0010. As formas de onda em A e em B podem ser descritas como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A: é alto quando o contador A estiver na contagem máxima, ou seja, a cada 4 pulsos de &lt;em&gt;clock&lt;/em&gt;, com duração de 1 pulso de &lt;em&gt;clock&lt;/em&gt;. Período do sinal: 5 pulsos de &lt;em&gt;clock&lt;/em&gt;, &lt;em&gt;Duty-cycle&lt;/em&gt;: 20%.&lt;/li&gt;
&lt;li&gt;B: é alto quando o contador B estiver na contagem máxima, ou seja, a cada 10 pulsos de &lt;em&gt;clock&lt;/em&gt;, com duração de 5 pulsos de &lt;em&gt;clock&lt;/em&gt;. Período do sinal: 15 pulsos de &lt;em&gt;clock&lt;/em&gt;. &lt;em&gt;Duty-cycle&lt;/em&gt;: 33%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A figura abaixo mostra os dois sinais, e também as saídas dos contadores. Repare que o primeiro ciclo é diferente pois o contador A começa em zero e não com o valor de carga.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Forma de onda do Exercício" src="/images/sd/er/er0002_onda.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://balbertini.github.io/extra/sd/er/er0002.zip"&gt;Download da descrição em VHDL&lt;/a&gt;&lt;br&gt;
&lt;a href="https://balbertini.github.io/extra/sd/er/20181012_associacaoContadores.circ"&gt;Download do circuito no LogiSim&lt;/a&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;</content><category term="sistemas digitais"></category><category term="exercícios resolvidos"></category><category term="associação de contadores"></category></entry><entry><title>Exercício: Análise de Circuitos Realimentados</title><link href="https://balbertini.github.io/er0001-pt_BR.html" rel="alternate"></link><published>2018-10-09T14:38:00-03:00</published><updated>2018-10-10T09:40:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-09:/er0001-pt_BR.html</id><summary type="html">&lt;p&gt;Exercício resolvido de sistemas digitais: análise de circuitos realimentados.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Assunto: Análise de circuitos realimentados&lt;/p&gt;
&lt;h2&gt;Enunciado&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTnoReset.png' align="left" width="35%" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;p&gt;O circuito ao lado é um circuito digital sequencial realimentado, com entradas T e C, e saída Q. Analise-o por completo, apresentando:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As equações de excitação e saída;&lt;/li&gt;
&lt;li&gt;A tabela de transição de estados e saída;&lt;/li&gt;
&lt;li&gt;Análise de corridas (e classificação se houve);&lt;/li&gt;
&lt;li&gt;A tabela de fluxo e saída;&lt;/li&gt;
&lt;li&gt;O diagrama de transição de estados da máquina.&lt;/li&gt;
&lt;/ul&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Solução&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTvBuffers.png' align="right" width="35%" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;p&gt;Vamos começar colocando os buffers virtuais, como na figura ao lado. Já aproveitei e nomeei todas as conexões existentes para facilitar o próximo passo: a extração das equações.&lt;/p&gt;
&lt;div class="math"&gt;$$
I=\overline{T.C.Y_2}\\
J=\overline{\overline{T}.\overline{C}.\overline{Y_2}}\\
K=\overline{\overline{T}.\overline{C}.Y_2}\\
L=\overline{T.C.\overline{Y_2}}\\
M=\overline{Y_1.K.L}\\
N=\overline{T.\overline{C}.\overline{Y_1}}\\
O=\overline{T.\overline{C}.Y_1}\\
P=\overline{Y_2.O}
$$&lt;/div&gt;
&lt;p&gt;Resolvendo &lt;span class="math"&gt;\(M\)&lt;/span&gt; e &lt;span class="math"&gt;\(P\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
M=\overline{Y_1.K.L}=\overline{Y_1.\overline{\overline{T}.\overline{C}.Y_2}.\overline{T.C.\overline{Y_2}}}=\overline{Y_1.(T+C+\overline{Y_2}).(\overline{T}+\overline{C}+Y_2)}\\
 =\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}\\
P=\overline{Y_2.O}=\overline{Y_2.\overline{T.\overline{C}.Y_1}}=\overline{Y_2.(\overline{T}+C+\overline{Y_1})}=\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}
$$&lt;/div&gt;
&lt;p&gt;E finalmente resolvendo &lt;span class="math"&gt;\(Y_1^*\)&lt;/span&gt; e &lt;span class="math"&gt;\(Y_2^*\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
Y_1^*=\overline{I.J.M}\\
=\overline{\overline{T.C.Y_2}.\overline{\overline{T}.\overline{C}.\overline{Y_2}}.\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}}\\
=T.C.Y_2+\overline{T}.\overline{C}.\overline{Y_2}+T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}\\
Y_2^*=\overline{N.P}=\overline{\overline{T.\overline{C}.\overline{Y_1}}.\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}}\\
=T.\overline{C}.\overline{Y_1}+\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2\\
$$&lt;/div&gt;
&lt;p&gt;O próximo passo é preencher a tabela de transição de estados e saída. A tabela preenchida pode ser vista abaixo, para &lt;span class="math"&gt;\(Y_1^*Y_2^*\)&lt;/span&gt;. Os estados contornados são estados estáveis, ou seja, não há mudança de estado para aquela entrada. Também podemos ver a tabela de fluxo, com as saídas.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabelas de transição de estados e de fluxo, com saídas" src="https://balbertini.github.io/images/sd/er/er0001_tranTable.png"&gt;&lt;/p&gt;
&lt;p&gt;Na tabela de transição de estados, podemos fazer a análise de corridas. Uma corrida acontece quando &lt;strong&gt;uma única mudança na entrada causa uma mudança em mais de uma variável de estado&lt;/strong&gt;. No nosso caso, uma única mudança em &lt;span class="math"&gt;\(T\)&lt;/span&gt; ou &lt;span class="math"&gt;\(C\)&lt;/span&gt; (tanto de zero para um quanto de um para zero, em qualquer uma das entradas), deve provocar uma mudança das variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt; de mais de um bit, ou seja, de 00 para 11 ou de 10 para 01 (ou vice-versa). Na tabela, podemos verificar que não há corridas. Exemplo: na primeira linha estamos com as variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt; em 00. Nenhuma transição desta linha indica uma transição para 11, as transições possíveis são para 10, 00, 00 e 01, de acordo com as entradas 00, 01, 11 ou 10 respectivamente. Isso significa que, se estivermos no estado 00, uma mudança de um bit não ocasionará uma mudança de mais de um bit nas variáveis de estado. Ainda precisamos analisar as colunas. Se estivermos no mesmo estado (00) e a entrada estiver em 00, as variáveis de estado indicam que o próximo estado é 10, que é estável, portanto esta mudança irá acontecer. Do estado 00 para 10 só há uma mudança nas variáveis de estado, então não há corrida. Se estivermos no estado 00 e a entrada for 01 ou 11, o estado já é estável, então não há mudança alguma nas variáveis de estado. No caso da entrada 10, o novo estado será 01, que é estável e só muda um bit da variável de estado. Prossegue-se com a análise para o restante da tabela e conclui-se que não há corrida alguma. Após a análise de corridas, pode-se montar a tabela de fluxo (com saídas), mostrada do lado direito da figura. Para facilitar, adotou-se a codificação de estados como &lt;span class="math"&gt;\(S_i\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(i\)&lt;/span&gt; é o número decimal que representa as variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt;. É preferível fazer a análise de corrida na tabela de transição em binário, pois é mais fácil perceber as mudanças.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/er0001_diagrama.png' align="right" width="35%" style="padding-left:5%" /&gt;
Por último, montamos o diagrama de transição de estados, que fica conforme a figura ao lado.&lt;/p&gt;
&lt;p&gt;A análise de comportamento é opcional, mas é relativamente fácil perceber que se trata de um &lt;em&gt;flip-flop&lt;/em&gt; tipo T sensível a borda de descida. A análise pode ser feita da seguinte forma: começa-se no estado &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; (pode ser qualquer estado) e analisa-se o comportamento das entradas. Percebe-se que, a única maneira de sair desse estado é se a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; for zero, de onde conclui-se que o circuito é algo que espera esta entrada virar zero. Nota-se ainda que, quando isso acontece, a saída muda caso a entrada &lt;span class="math"&gt;\(T\)&lt;/span&gt; seja um, caso contrário não muda. Todos os estados "seguram" a borda da entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt;, ou seja, independentemente se formos para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; ou &lt;span class="math"&gt;\(S_2\)&lt;/span&gt; a partir do &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; não altera mais o comportamento da máquina exceto se for para um e depois para zero novamente. Poderíamos dizer que os estados tem estas funções:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_0\)&lt;/span&gt;: saída zero, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;: saída um, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;: saída zero, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_3\)&lt;/span&gt;: saída um, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Repare que o efeito &lt;em&gt;toggle&lt;/em&gt; só acontece nas arestas horizontais, de &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; e de &lt;span class="math"&gt;\(S_3\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://balbertini.github.io/extra/sd/er/20181009_projFfT.circ"&gt;Download do circuito no LogiSim&lt;/a&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="exercícios resolvidos"></category><category term="análise"></category><category term="circuitos realimentados"></category></entry><entry><title>Simplificação de FSM</title><link href="https://balbertini.github.io/fsmstatereduction-pt_BR.html" rel="alternate"></link><published>2018-09-25T14:22:00-03:00</published><updated>2018-09-26T22:49:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-25:/fsmstatereduction-pt_BR.html</id><summary type="html">&lt;p&gt;Como fazer simplificação de estados em máquinas de estados finitas.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A máquina de estados finita em sistemas digitais, quando realizada na forma de um circuito digital, utiliza recursos computacionais (e.g. &lt;em&gt;flip-flops&lt;/em&gt;, memórias, portas lógicas, etc.) que são caros do ponto de vista de área e consumo de energia, principalmente se a máquina possuir muitos estados. Por este motivo, é importante minimizar o número de estados da máquina para que, na implementação, utilizemos somente os recursos mínimos necessários para aquela máquina. Além disso, quando estamos projetando uma máquina de estados para resolver um problema, é mais confortável não pensar em otimizações mas sim na funcionalidade da máquina, para só depois pensar na otimização. De fato, a maioria dos projetistas comerciais não pensa na otimização quando estão modelando o problema pois isso nem sempre é possível (i.e. o projetista não tem visão da máquina toda mas sim da parte cabível a ele, a máquina é muito grande tornando impossível pensar em tudo, a máquina é particionada, etc).&lt;/p&gt;
&lt;p&gt;Na prática, com os sintetizadores modernos, você pode especificar sua máquina usando a linguagem de descrição de hardware de sua preferência e deixar o sintetizador otimizá-la para você. Os resultados da otimização automática são bons quando comparados aos métodos manuais [1,2]. Contudo, é necessário conhecer o mínimo do funcionamento dos algoritmos de minimização pois, quando for descrever sua máquina, você conhecerá ao menos o básico do que acontecerá quando sintetizá-la. Neste artigo, explicarei os métodos de minimização por identificação direta na tabela de transição de estados e por tabela de implicação. Em ambos os casos, o objetivo principal é encontrar estados equivalentes, ou seja, que &lt;strong&gt;para a mesma entrada, produzem a mesma saída e transicionam para os mesmos estados.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Minimização através da tabela de transição&lt;/h2&gt;
&lt;p&gt;Em muitos casos, é fácil identificar os estados equivalentes na tabela de transição de estados, por isso este método também é chamado de &lt;strong&gt;observação direta&lt;/strong&gt; ou &lt;strong&gt;casamento de linhas&lt;/strong&gt;. O algoritmo é simples:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Elimine todos os estados inalcançáveis (estados onde não chega nenhuma aresta partindo de outro estado alcançável).&lt;/li&gt;
&lt;li&gt;Identifique dois estados A e B que, para a mesma entrada, produzam exatamente a mesma saída e realizem a mesma transição (transicionem para o mesmo estado).&lt;/li&gt;
&lt;li&gt;Elimine um dos estados (e.g. B) apagando a linha correspondente a este estado e substitua todas as ocorrências de B por A (i.e. todos as transições para B agora devem apontar para A).&lt;/li&gt;
&lt;li&gt;Repita até que nenhum par de estados atenda (2).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;Uma forma muito comum de projetar máquinas de estados é modelando-a como árvore, onde cada ramificação é uma tomada de decisão. Tomemos a máquina abstrata a seguir que foi montada partindo de uma árvore binária canônica e modificada para reconhecer as sequencias 0011 e 1001:&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;Em vermelho está destacado o caminho que esta máquina irá seguir para reconhecer as duas sequencias. Note que esta é uma máquina de Mealy e não leva em consideração nenhuma sobreposição entre as sequencias detectadas, ou seja, ela só funciona para entradas de 4 bits agrupados a partir do &lt;em&gt;reset&lt;/em&gt; (e.g. detecta duas vezes se a entrada for 0011 1001 mas não detecta a segunda vez se a entrada for 0011 001).&lt;/p&gt;
&lt;p&gt;A tabela de transição de estados fica como na Tabela 1 a seguir.&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0px;margin-right:10px;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-3r9o{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-4m7p{background-color:#9aff99;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-uuae{background-color:#67fd9a;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-fcno{background-color:#fcff2f;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-bolj{background-color:#ffccc9;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-mfhl{background-color:#ffffc7;border-color:inherit;text-align:center;vertical-align:top}
&lt;/style&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela 1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S7/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S9/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S10/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S12/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S6&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S13/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S14/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S7&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S8&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S9&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S10&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S11&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S12&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S13&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S14&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S4&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S6&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S8&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S11&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 3&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sc&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A coluna &lt;strong&gt;E.A.&lt;/strong&gt; mostra o estado atual, e a coluna &lt;strong&gt;P.E.&lt;/strong&gt; o próximo estado. Esta última é bipartida para as entradas igual a &lt;strong&gt;0&lt;/strong&gt; e igual a &lt;strong&gt;1&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A Tabela 1 possui todas as transições da árvore como vista na figura. Esta máquina não tem nenhum estado inalcançável, então não há o que eliminar no passo 1.&lt;/p&gt;
&lt;p&gt;No passo 2, devemos procurar as equivalências. É fácil perceber que há estados que produzem exatamente o mesmo resultado (transição e saída) para determinada entrada. Tomemos por exemplo os estados S7, S9, S10, S12, S13 e S14: todos transicionam para S0 e produzem saída 0 para qualquer entrada, portanto são equivalentes. Podemos reduzir a tabela substituindo todos estes estados por um estado Sa, o que podemos ver na Tabela 2, destacado em verde.&lt;/p&gt;
&lt;p&gt;Se fizermos a busca novamente, os estados S4 e S6 agora são equivalentes pois ambos transicionam para Sa e produzem saída 0, independententemente da entrada. Criamos o estado Sb, em vermelho, para substituir estes estados. Similarmente os estados S8 e S11 são equivalentes, mas note que eles tem saídas diferentes para entradas diferentes. Para este conjunto de estados, criamos Sc, em amarelo. Não há mais estados equivalentes e o resultado final pode ser visto na Tabela 3.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="35%" align="right" style="padding-left:5%" /&gt;
&lt;br/&gt;
O diagrama de transição de estados minimizado pode ser visto na figura ao lado. Os estados S7, S9, S10, S12, S13 e S14 são representados pelo Sa, S4 e S6 pelo Sb e S8 e S11 pelo Sc.&lt;/p&gt;
&lt;p&gt;O método de análise da tabela de transição de estados se baseia na busca exaustiva por estados equivalentes. É fácil perceber que, conforme a tabela cresce, ficará mais difícil visualizar os estados equivalentes. Além disso, o método não garante a menor quantidade de estados possível pois é baseado em estados e não em grupos de estados (veja o primeiro exemplo da próxima seção).&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;O método de minimização por tabela de implicação&lt;/h2&gt;
&lt;p&gt;Nem sempre é tão fácil perceber a equivalência de estados através da tabela de transição de estados, especialmente para máquinas grandes ou com muitas entradas. No entanto, os projetistas desenvolveram um método chamado de tabela de implicação. Este método é equivalente à análise através da tabela de transição de estados, porém é algorítmico e está organizado em forma de uma matriz, o que minimiza erros por parte do projetista. Além disso, apesar de ambos os métodos serem exaustivos, há uma diferença primordial: enquanto o método de análise da tabela de transição de estados procura exaustivamente estados equivalentes, o método da tabela de implicação procura exaustivamente os estados que &lt;strong&gt;não são equivalentes&lt;/strong&gt;. Parte-se da premissa de que todos os estados são equivalentes entre si e, a cada iteração, elimina-se os estados que não podem ser equivalentes. Os estados que sobrarem são equivalentes.&lt;/p&gt;
&lt;p&gt;Há dois momentos no método da tabela de implicação: a construção da tabela e a análise.&lt;/p&gt;
&lt;h3&gt;Construção da matriz (tabela)&lt;/h3&gt;
&lt;p&gt;A matriz pode ser construída como uma matriz &lt;span class="math"&gt;\(n\)&lt;/span&gt; por &lt;span class="math"&gt;\(n\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(n\)&lt;/span&gt; é o número de estados (se você começar no &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, o último estado será &lt;span class="math"&gt;\(S_{n-1}\)&lt;/span&gt;). Cada linha &lt;span class="math"&gt;\(i\)&lt;/span&gt; da matriz representa um estado e cada coluna &lt;span class="math"&gt;\(j\)&lt;/span&gt; também.&lt;/p&gt;
&lt;p&gt;Não faz sentido analisar a equivalência de um estado com ele mesmo, pois um estado sempre é equivalente a ele mesmo. Por este motivo, eliminamos a diagonal da matriz, onde &lt;span class="math"&gt;\(i=j\)&lt;/span&gt;. As metades diagonais superiores e inferiores significam a mesma coisa pois se uma célula &lt;span class="math"&gt;\(X_{ij}\)&lt;/span&gt; mostra equivalência entre o estado &lt;span class="math"&gt;\(S_i\)&lt;/span&gt; e o estado &lt;span class="math"&gt;\(S_j\)&lt;/span&gt;, a célula &lt;span class="math"&gt;\(X_{ji}\)&lt;/span&gt; também deve mostrar a mesma equivalência. Por este motivo, eliminamos também uma das metades diagonais. Por convenção, elimina-se a diagonal superior, mas o resultado é o mesmo se você eliminar a metade diagonal inferior.&lt;/p&gt;
&lt;p&gt;Quando estiver confortável com a construção da matriz, você poderá desenhá-la já sem a diagonal e sem a metade diagonal superior. A esse desenho contendo somente a metade diagonal inferior da tabela, chamamos de &lt;strong&gt;tabela de implicação&lt;/strong&gt;. Na figura abaixo mostramos a matriz inteira, a matriz destacando a linha diagonal (vermelha) e a metade diagonal superior (laranja), e finalmente a tabela de implicação.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Construção da tabela de implicação." src="https://balbertini.github.io/images/sd/sdfsmoptconsttab.png"&gt;&lt;/p&gt;
&lt;p&gt;Após obter a tabela de implicação, devemos preencher as células. Cada célula terá &lt;span class="math"&gt;\(2^b\)&lt;/span&gt; linhas, onde &lt;span class="math"&gt;\(b\)&lt;/span&gt; é o número de bits da entrada. E.g. se a entrada for de 1 bit, cada célula tem 2 linhas; se a entrada for de 2 bits, cada célula tem 4 linhas. Cada linha da entrada corresponde às transições daqueles estados para aquela entrada.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptconstcel.png' width="45%" align="right" style="padding-left:5%" /&gt;
Na figura podemos ver o exemplo do preenchimento para duas células, ambas na linha do S3 e coluna do S4. Para simplificar o preenchimento, usamos somente o número do estado, mas você pode escrever o nome completo do estado (especialmente útil se os nomes dos estados não forem numerados).&lt;/p&gt;
&lt;p&gt;Na célula na esquerda na figura, a entrada tem 1 bit, portanto temos duas linhas, uma para a entrada 0 e outra para a entrada 1. Nesta célula, a máquina é de Mealy com saída de 1 bit, que pode ser vista representada nas transições.&lt;/p&gt;
&lt;p&gt;Já na célula a direita na figura, a entrada tem 2 bits, portanto temos 4 linhas para as entradas 00, 01, 10 e 11. A máquina representada é de Moore e também tem um bit só de saída, que nesse caso é representado no estado e não na transição.&lt;/p&gt;
&lt;p&gt;Os números em cada linha correspondem a transição que o estado fará para cada entrada (e à saída referente àquela transição no caso de uma máquina de Mealy). No exemplo a esquerda na figura, podemos assumir que, para uma determinada entrada e estando em S3 ou em S4, a máquina transicionará para o estado S0/0 ou S1/0 (note que em ambas as transições a saída é 0). Na mesma situação mas para a outra entrada, a máquina transicionará para o estado S2/0 ou S3/1. Mas como eu sei qual entrada? Não é preciso saber para qual entrada, apenas que as transições da mesma linha, separadas por &lt;code&gt;-&lt;/code&gt;, são para a mesma entrada. De fato, alguns projetistas preferem ordenar as transições em ordem crescente para facilitar a busca por estados equivalentes. E.g. (linha superior / linha inferior) 3-2/1-2 é o mesmo que 1-2/2-3, mas ordenado. Fica a seu critério decidir a melhor forma de organizar sua tabela de implicação, mas lembre-se que cada linha corresponde a exatamente dois estados separados por &lt;code&gt;-&lt;/code&gt;, para os quais a máquina de estados transicionará quando houver a mesma entrada.&lt;/p&gt;
&lt;p&gt;É de praxe também assinalar os estados que produzem saídas diferentes, pois eles não podem ser equivalentes. Neste caso, coloque uma &lt;code&gt;/&lt;/code&gt; no índice de coluna e linha (caso a máquina for de Moore) ou na transição dentro da célula (caso a máquina for de Mealy). Isto ficará mais claro no exemplo.&lt;/p&gt;
&lt;h2&gt;Procurando estados equivalentes&lt;/h2&gt;
&lt;p&gt;Com a tabela de implicação construída, devemos procurar os estados equivalentes. Isto é feito de forma exaustiva, analisando todas as células da tabela.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Risque todas as transições que vão para o mesmo estado e produzem a mesma saída (tipo s-s), pois elas são naturalmente equivalentes. E.g. se você tem uma transição 0-0, risque-a pois não é preciso analisá-la.&lt;/li&gt;
&lt;li&gt;Elimine as células com estados (Moore) ou transições (Mealy) que produzem saídas diferentes. Estes estados nunca poderão ser equivalentes.&lt;/li&gt;
&lt;li&gt;Analise uma célula qualquer que não tenha todas as transições riscadas e que não tenha sido eliminada anteriormente. Esta célula é uma candidata a equivalência.&lt;ul&gt;
&lt;li&gt;Olhe todas as linhas da célula que não foram riscadas no passo (1). Para cada uma, analise a célula alvo. E.g. se a transição marca 1-2, você deve analisar a célula correspondente aos estados S1 e S2.&lt;/li&gt;
&lt;li&gt;Se a célula alvo estiver eliminada, você deve eliminar esta célula também.&lt;/li&gt;
&lt;li&gt;Se você analisou todas as linhas e não eliminou a célula, não faça nada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Repita o (3) até que todas as células tenham sido analisadas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note que este processo é exaustivo. Para não correr o risco de analisar a mesma célula várias vezes, aconselho começar pela célula mais a direita inferior e depois passar para a segunda mais a direita inferior, e assim por diante. Não faz diferença a ordem em que você analisa as células, mas você deve se organizar para não repetir células.&lt;/p&gt;
&lt;p&gt;Durante a análise, pode acontecer de você eliminar uma linha inteira ou uma coluna inteira. Isso significa que o estado daquela linha ou coluna não é equivalente a nenhum outro estado, portanto você deve eliminar todas as células que tem alguma linha referenciando aquele estado. E.g. se você eliminou a linha toda do S3, você deve eliminar todas as células que possuam ao menos um 3 em alguma linha (x-3 ou 3-x).&lt;/p&gt;
&lt;p&gt;Você não precisa analisar células onde todas as linhas tenham sido riscadas no passo 1. Se você riscar todas as linhas de uma célula, os estados desta célula (linha-coluna) são automaticamente equivalentes. Você não precisa tomar nenhuma ação em relação a isso, apenas pule a análise da célula.&lt;/p&gt;
&lt;p&gt;Quando você terminar este processo, as células que você não eliminou representam &lt;strong&gt;classes de equivalência&lt;/strong&gt;. Uma classe de equivalência é um grupo de estados que são equivalentes e, consequentemente, podem ser representados por um único estado. E.g. se a célula da linha 3 coluna 4 não foi eliminada, os estados S3 e S4 são equivalentes.&lt;/p&gt;
&lt;h2&gt;Exemplo 1/3 - Moore simples&lt;/h2&gt;
&lt;p&gt;Este exemplo é de uma máquina de Moore que detecta uma paridade ímpar considerando todas as entradas que já passaram pela máquina. O diagrama e a tabela de transição de estados podem ser vistos abaixo:&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela E1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;A/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;A&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;B/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;C/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diag.png' width="13%" align="left" style="padding-left:5%; padding-right:5%"/&gt;
Tente minimizar esta máquina usando o método de análise da tabela de transição. É possível encontrar algum estado equivalente? Perceba que os estados A e C são equivalentes, mas não é possível perceber isto apenas com a tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1a.png' width="55%" align="right" style="padding-left:5%"/&gt;
Vamos construir a tabela de implicação para verificar. Na figura ao lado, podemos ver: (esquerda) a tabela de implicação construída e com os estados (note que é uma máquina de Moore, então as saídas são representadas nos estados); (meio) a tabela de implicação com as linhas de acordo com a tabela de transição de estados; e (direita) a versão com a linha B-B já riscada, pois para esta entrada, a máquina transiciona para o mesmo estado independententemente de qual estado esteja. Isto equivale à construção da tabela de implicação e à execução do primeiro passo do algoritmo.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1b.png' width="45%" align="left" style="padding-right:5%"/&gt;
No segundo passo eliminamos os estados que produzem saída diferentes, pois nunca poderão ser equivalentes. Isto pode ser visto à esquerda na figura ao lado (os estados eliminados foram destacados em cinza). Sobra a única célula a ser verificada, correspondente aos estados C/0-A/0. Esta célula tem uma linha riscada (que não precisa ser analisada) e uma linha que referencia A-C. A referência A-C aponta para a mesma célula que estamos analisando, a célula C/0-A/0. Como esta célula ainda não foi eliminada, nada resta a fazer e devemos continuar o algoritmo. Porém, não há mais células a serem analisadas, portanto o algoritmo terminou. Isso significa que a única célula que não foi eliminada será a nossa classe de equivalência, destacada em vermelho na tabela de implicação da figura.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diagmin.png' width="13%" align="left" style="padding-right:5%"/&gt;
A célula indica que a classe de equivalência contém somente dois estados, o C/0 e o A/0. Para finalizar, montamos um novo diagrama de transição de estados com um estado chamado AC/0, em vermelho, representando a classe de equivalência encontrada. As transições são transportadas dos estados da classe de equivalência e, obviamente, são esperadas que sejam as mesmas pois os estados são equivalentes. Esta máquina tem a mesma funcionalidade que a anterior, porém tem um estado a menos. Este tipo de minimização não é possível usando a análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 2/3 - Moore com entrada de 2 bits&lt;/h2&gt;
&lt;p&gt;A Tabela E2 é a tabela de transição de estados de uma máquina de Moore, com entrada de dois bits. Sua funcionalidade ou diagrama de transição de estados não importam neste momento, mas o diagrama equivalente pode ser visto na figura.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diag.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo podemos ver a tabela construída e com o passo 1 executado (esquerda) e após o passo 2 executado (direita). Note que, para minimizar o esforço em preencher a tabela e evitar poluí-la, eu eliminei o "S" e utilizei somente os índices dos estados.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2a.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2b.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo, podemos ver a tabela de implicação após o passo 3 executado a exaustão (esquerda) e com as classes de equivalência construídas (direita). Na tabela da esquerda, as linhas que provocaram a exclusão da tabela foram realçadas com um cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2c.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2d.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Pela tabela, podemos inferir que os estados S4 e S0 (Sa) são equivalentes entre si, assim como os estados S5 e S3 (Sb). A tabela de transição de estados minimizada e o diagrama de transição de estados minimizado podem ser vistos abaixo. A máquina original possuía 6 estados, o que exige 3 &lt;em&gt;flip-flops&lt;/em&gt; para sua implementação, mas a minimizada tem 4 estados, o que exige 2 &lt;em&gt;flip-flops&lt;/em&gt;, portanto economizamos um &lt;em&gt;flip-flop&lt;/em&gt; apenas minimizando a máquina.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2 min&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sa/1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sb/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diagmin.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 3/3 - Mealy com 15 estados&lt;/h2&gt;
&lt;p&gt;Suponha a mesma máquina de estados usada como exemplo no método de análise da tabela de transição de estados, mostrada na figura. Trata-se de uma máquina de Mealy que reconhece 0011 ou 1001 sem sobreposição.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;A máquina tem 15 estados, portanto temos uma matriz 15x15. A tabela de implicação, já com os valores das transições preenchidos e com as transições s-s riscadas, pode ser vista na figura abaixo. Note que esta é uma máquina de Mealy, então coloquei a saída na transição (e.g. nos estados S8 e S11, que são os que produzem saída, há transições na forma 0/1, indicando que esta transição produz saída 1). Isto corresponde à construção da tabela de implicação e à execução do passo 1 do algoritmo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 1" src="https://balbertini.github.io/images/sd/sdfsmoptex3a.png"&gt;&lt;/p&gt;
&lt;p&gt;No passo 2, devemos eliminar as transições que produzem saídas diferentes, ou seja, devemos eliminar todas as células que contém uma transição s-t onde a saída de s é diferente da saída de t. Exemplo: a célula S14-S11 possui a segunda linha como 0/1-0, o que significa que, apesar de irem para o mesmo estado, uma produz saída 1 (0/1) e outra produz saída 0 (0/0), portanto devemos eliminar esta célula toda. Isto pode ser visto na figura abaixo, onde todas as células eliminadas por este motivo foram identificadas com fundo cinza e a linha que foi o motivo da eliminação com cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 2" src="https://balbertini.github.io/images/sd/sdfsmoptex3b.png"&gt;&lt;/p&gt;
&lt;p&gt;O passo 2 eliminou os estados que trivialmente não são equivalentes. Podemos então começar o passo 3 analisando cada célula. Eu comecei pela célula mais a direita inferior e continuei analisando para a esquerda. A célula S14-S13 não precisa ser analisada pois tem todas as transições riscadas. Idem para a célula S14-S12. Já a célula S14-S11 foi eliminada anteriormente e também não precisa ser analisada.&lt;/p&gt;
&lt;p&gt;A primeira célula que realmente precisa ser analisada é a S14-S6. Nesta célula, a transição 13-0 aponta para a a célula S13-S0, e a transição 14-0 para a célula S14-S0. Estas células alvo ainda indicam equivalência, então não fiz nada na célula em análise (S14-S6). Idem para S14-S5 e S14-S4.&lt;/p&gt;
&lt;p&gt;Já na célula S14-S3, encontrei uma referência à S8-S0, que já foi eliminado em um passo anterior. Isso significa que eu devo eliminar esta célula. Nesse ponto, percebi que a linha do S8 estava inteira eliminada, então eliminei  todas as células que fazem referência a S8, ou seja, que tem transições 8/x-x/x ou x/x-8/x. O resultado pode ser visto na figura abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 3" src="https://balbertini.github.io/images/sd/sdfsmoptex3c.png"&gt;&lt;/p&gt;
&lt;p&gt;Se está lendo com cuidado, deve ter percebido que a eliminação que acabei de fazer eliminou o estado S3 inteiro. Isto significa que podemos eliminar todas as células que contém transições que referenciam o S3, pois ele não pode ser equivalente a nenhum outro estado. Se você continuar o algoritmo, terminará com a tabela de implicação abaixo, onde as células eliminadas estão em cinza.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 eliminadas" src="https://balbertini.github.io/images/sd/sdfsmoptex3d.png"&gt;&lt;/p&gt;
&lt;p&gt;A única célula que ainda precisa de análise é a célula S6-S4. Esta célula referencia os estados S9-S13 na primeira linha e S10-S14 na segunda linha. Ambas as células S9-S13 e S10-S14 não foram eliminadas pois possuem todas as suas linhas riscadas, então não devemos fazer nada nesta célula. Como não há mais células a serem analisadas, o algoritmo terminou.&lt;/p&gt;
&lt;p&gt;Com o algoritmo finalizado, podemos inferir os estados equivalentes observando as células que não foram eliminadas. A célula S6-S4 indica que estes dois estados são equivalentes. Similarmente, a coluna S7 indica que os estados S7, S9, S10, S12, S13 e S14 são todos equivalentes. Isso pode ser corroborado pelas colunas do S9, S10, S11, S12 e S13, que indicam também esta equivalência. Ainda, a célula S11-S8 indica que estes dois estados são equivalentes entre si (note que ambos produzem saída 1).&lt;/p&gt;
&lt;p&gt;Para facilitar a visualização, a figura abaixo traz as classes de equivalência coloridas. Para a mesma cor, os estados são equivalentes.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 fim" src="https://balbertini.github.io/images/sd/sdfsmoptex3e.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="45%" align="right" style="padding-left:5%" /&gt;
Por último, devemos reconstruir o diagrama de transição de estados. Para cada classe de equivalência, criamos um estado novo. As transições e as saídas podem ser copiadas de qualquer um dos estados da classe, pois eles são equivalentes (para as mesmas entradas, produzem a mesma saída e transicionam para o mesmo estado). Note que este método agrupa os estados em classes, então a transição do Sb (que é composto por S4 e S6) que vai para o S9, por exemplo, deve ir para o estado Sa (que é composto por S7, S9, S10, S12, S13 e S14) pois esta é a classe de equivalência que contém o S9. O diagrama desta tabela é idêntico ao obtido usando o método de análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h1&gt;Referências&lt;/h1&gt;
&lt;p&gt;&lt;p/&gt;
[1] DE VRIES, A. Finite automata: Behavior and synthesis. Elsevier, 2014.&lt;br&gt;
[2] KAM, Timothy et al. Synthesis of finite state machines: functional optimization. Springer Science &amp;amp;
Business Media, 2013.&lt;/p&gt;
&lt;p&gt;Algumas partes dos exemplos foram adaptados de apresentações do &lt;a href="http://www-inst.eecs.berkeley.edu/~cs150/sp00/classnotes/katz-ch9-mod.pdf"&gt;Prof. Randy H. Katz&lt;/a&gt; e da disciplina &lt;a href="https://courses.cs.washington.edu/courses/cse370/09wi/LectureSlides/22-Minimization.pdf"&gt;CSE370, Lecture 22&lt;/a&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="fsm"></category><category term="simplificação"></category><category term="otimização"></category></entry></feed>