<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>B.Albertini's site - sistemas digitais</title><link href="https://balbertini.github.io/" rel="alternate"></link><link href="https://balbertini.github.io/feeds/sistemas-digitais.atom.xml" rel="self"></link><id>https://balbertini.github.io/</id><updated>2018-09-25T14:22:00-03:00</updated><entry><title>Simplificação de FSM</title><link href="https://balbertini.github.io/fsmstatereduction-pt_BR.html" rel="alternate"></link><published>2018-09-25T14:22:00-03:00</published><updated>2018-09-25T14:22:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-25:/fsmstatereduction-pt_BR.html</id><summary type="html">&lt;p&gt;Como fazer simplificação de estados em máquinas de estados finitas.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A máquina de estados finita em sistemas digitais, quando realizada, utiliza recursos computacionais que podem ser caros (e.g. &lt;em&gt;flip-flops&lt;/em&gt;) do ponto de vista de área e consumo de energia, principalmente se a máquina for grande. Por este motivo, é importante minimizar o número de estados da máquina para que, na implementação, não utilizemos recursos desnecessários. Além disso, quando estamos projetando uma máquina de estados para resolver um problema, é mais confortável não pensar em otimizações mas sim na funcionalidade da máquina, para só depois pensar na otimização. De fato, a maioria dos projetistas comerciais não pensa na otimização quando estão modelando o problema pois isso nem sempre é possível (i.e. o projetista não tem visão da máquina toda mas sim da parte cabível a ele, a máquina é muito grande tornando impossível pensar em tudo, a máquina é particionada, etc).&lt;/p&gt;
&lt;p&gt;Na prática, com os sintetizadores modernos, você pode especificar sua máquina usando a linguagem de descrição de hardware de sua preferência e deixar o sintetizador otimizá-la para você. Os resultados serão tão bons quanto se usar os métodos manuais [1,2]. Contudo, é necessário conhecer o mínimo do funcionamento dos algoritmos de minimização pois, quando for descrever sua máquina, você conhecerá ao menos o básico do que acontecerá quando sintetizá-la. Neste artigo, explicarei os métodos de minimização por identificação direta na tabela de transição de estados e por tabela de implicação. Em ambos os casos, o objetivo principal é encontrar estados equivalentes, ou seja, que &lt;strong&gt;para a mesma entrada, produzem a mesma saída e transicionam para os mesmos estados.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Minimização através da tabela de transição&lt;/h2&gt;
&lt;p&gt;Em muitos casos, é fácil identificar os estados equivalentes na tabela de transição de estados, por isso este método também é chamado de &lt;strong&gt;observação direta&lt;/strong&gt; ou &lt;strong&gt;casamento de linhas&lt;/strong&gt;. O algoritmo é simples:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Elimine todos os estados inalcançáveis (estados onde não chega nenhuma aresta partindo de outro estado alcançável).&lt;/li&gt;
&lt;li&gt;Identifique dois estados &lt;span class="math"&gt;\(A\)&lt;/span&gt; e &lt;span class="math"&gt;\(B\)&lt;/span&gt; que, para a mesma entrada, produzam exatamente a mesma saída e realizem a mesma transição (transicionem para o mesmo estado).&lt;/li&gt;
&lt;li&gt;Elimine um dos estados (e.g. &lt;span class="math"&gt;\(B\)&lt;/span&gt;) apagando a linha correspondente a este estado e substitua todas as ocorrências de &lt;span class="math"&gt;\(B\)&lt;/span&gt; por &lt;span class="math"&gt;\(A\)&lt;/span&gt; (i.e. todos as transições para &lt;span class="math"&gt;\(B\)&lt;/span&gt; agora devem apontar para &lt;span class="math"&gt;\(A\)&lt;/span&gt;).&lt;/li&gt;
&lt;li&gt;Repita até que nenhum par de estados atenda (2).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;Uma forma muito comum de projetar máquinas de estados é modelando-a como árvore, onde cada ramificação é uma tomada de decisão. Tomemos a máquina abstrata a seguir que foi montada partindo de uma árvore binária canônica e modificada para reconhecer as sequencias 0011 e 1001:&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;Em vermelho está destacado o caminho que esta máquina irá seguir para reconhecer as duas sequencias. Note que esta é uma máquina de Mealy e não leva em consideração nenhuma sobreposição entre as sequencias detectadas, sou seja, ela só funciona para entradas de 4 bits agrupados a partir do &lt;em&gt;reset&lt;/em&gt; (e.g. detecta duas vezes se a entrada for 0011 1001 mas não detecta a segunda vez se a entrada for 0011 001).&lt;/p&gt;
&lt;p&gt;A tabela de transição de estados fica como na Tabela 1 a seguir.&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0px;margin-right:10px;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-3r9o{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-4m7p{background-color:#9aff99;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-uuae{background-color:#67fd9a;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-fcno{background-color:#fcff2f;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-bolj{background-color:#ffccc9;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-mfhl{background-color:#ffffc7;border-color:inherit;text-align:center;vertical-align:top}
&lt;/style&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela 1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S7/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S9/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S10/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S12/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S6&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S13/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S14/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S7&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S8&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S9&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S10&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S11&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S12&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S13&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S14&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S4&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S6&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S8&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S11&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 3&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sc&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A coluna &lt;strong&gt;E.A.&lt;/strong&gt; mostra o estado atual, e a coluna &lt;strong&gt;P.E.&lt;/strong&gt; o próximo estado. Esta última é bipartida para as entradas igual a &lt;strong&gt;0&lt;/strong&gt; e igual a &lt;strong&gt;1&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A Tabela 1 possui todas as transições da árvore como vista na figura. Esta máquina não tem nenhum estado inalcançável, então podemos pular o passo 1, mas é fácil de ver que há estados que produzem exatamente a mesma coisa (transição e saída) para determinada entrada. Tomemos por exemplo os estados S7, S9, S10, S12, S13 e S14: todos transicionam para S0 e produzem saída 0 para qualquer entrada, portanto são equivalentes. Podemos reduzir a tabela substituindo todos estes estados por um estado Sa, o que podemos ver na Tabela 2, destacado em verde.&lt;/p&gt;
&lt;p&gt;Se aplicarmos o algoritmo novamente, os estados S4 e S6 agora são equivalentes pois ambos transicionam para Sa e produzem saída 0, independententemente da entrada (chamaremos de Sb, em vermelho). Similarmente os estados S8 e S11 são equivalentes, mas note que eles tem saídas diferentes para entradas diferentes (chamaremos de Sc, em amarelo). O resultado está na Tabela 3.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="45%" align="right" style="padding-left:5%" /&gt;
O diagrama de transição de estados minimizado pode ser visto na figura ao lado. Os estados S7, S9, S10, S12, S13 e S14 são representados pelo Sa, S4 e S6 a Sb e S8 e S11 a Sc.
&lt;!-- &lt;img alt="Diagrama de transiçao de estados minimizado" src="https://balbertini.github.io/images/sd/sdfsmopt3.png"&gt; --&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;O método de minimização por tabela de implicação&lt;/h2&gt;
&lt;p&gt;Nem sempre é tão fácil perceber a equivalência de estados através da tabela de transição de estados, especialmente para máquinas grandes. No entanto, os projetistas desenvolveram um método chamado de tabela de implicação. Este método é equivalente à análise através da tabela de transição de estados, porém é algorítmico e está organizado em forma de uma matriz, o que minimiza erros por parte do projetista.&lt;/p&gt;
&lt;h3&gt;Construção da matriz&lt;/h3&gt;
&lt;p&gt;A matriz pode ser construída como uma matriz &lt;span class="math"&gt;\(n\)&lt;/span&gt; por &lt;span class="math"&gt;\(n\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(n\)&lt;/span&gt; é o número de estados (se você começar no &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, o último estado será &lt;span class="math"&gt;\(S_{n-1}\)&lt;/span&gt;). Cada linha &lt;span class="math"&gt;\(i\)&lt;/span&gt; da matriz representa um estado e cada coluna &lt;span class="math"&gt;\(j\)&lt;/span&gt; também. Não faz sentido analisar a equivalência de um estado com ele mesmo, por isso eliminamos a diagonal da matriz. As metades diagonais superiores e inferiores significam a mesma coisa pois se uma célula &lt;span class="math"&gt;\(X_{ij}\)&lt;/span&gt; mostra equivalência entre o estado &lt;span class="math"&gt;\(S_i\)&lt;/span&gt; e o estado &lt;span class="math"&gt;\(S_j\)&lt;/span&gt;, a célula &lt;span class="math"&gt;\(X_{ji}\)&lt;/span&gt; também deve mostrar a mesma equivalência. Por este motivo, eliminamos também uma das metades diagonais. Por convenção, elimina-se a diagonal superior, mas o resultado é o mesmo. Quando estiver confortável com a matriz, você poderá desenhá-la já sem a diagonal e sem a metade diagonal superior. A esse desenho contendo somente a metade diagonal inferior da tabela, chamamos de &lt;strong&gt;tabela de implicação&lt;/strong&gt;. Na figura abaixo mostramos a matriz inteira, a matriz destacando a linha diagonal (vermelha) e a metade diagonal superior (laranja), e finalmente a tabela de implicação.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Construção da tabela de implicação." src="https://balbertini.github.io/images/sd/sdfsmoptconsttab.png"&gt;&lt;/p&gt;
&lt;p&gt;Após obter a tabela de implicação, devemos preencher as células. Cada célula terá &lt;span class="math"&gt;\(2^b\)&lt;/span&gt; linhas, onde &lt;span class="math"&gt;\(b\)&lt;/span&gt; é o número de bits da entrada. E.g. se a entrada for de 1 bit, cada célula tem 2 linhas; se a entrada for de 2 bits, cada célula tem 4 linhas. Cada linha da entrada corresponde às transições daqueles estados para aquela entrada.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptconstcel.png' width="45%" align="right" style="padding-left:5%" /&gt;
Na figura podemos ver o exemplo do preenchimento para duas células, ambas na linha do &lt;span class="math"&gt;\(S_3\)&lt;/span&gt; e coluna do &lt;span class="math"&gt;\(S_4\)&lt;/span&gt;. Para simplificar o preenchimento, usamos somente o número do estado, mas sinta-se a vontade para escrever o nome completo (especialmente útil se os nomes dos estados não forem numerados). Na célula na esquerda na figura, a entrada tem 1 bit, portanto temos duas linhas, uma para a entrada 0 e outra para a entrada 1. Já na célula a direita na figura, a entrada tem 2 bits, portanto temos 4 linhas, para as entradas 00, 01, 10 e 11.&lt;/p&gt;
&lt;p&gt;Os números em cada linha correspondem a transição que o estado fará para cada entrada. No exemplo a esquerda na figura, podemos assumir que, para uma determinada entrada e estando em &lt;span class="math"&gt;\(S_3\)&lt;/span&gt; ou em &lt;span class="math"&gt;\(S_4\)&lt;/span&gt;, a máquina transicionará para o estado &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; ou &lt;span class="math"&gt;\(S_1\)&lt;/span&gt;. Na mesma situação mas para a outra entrada, a máquina transicionará para o estado &lt;span class="math"&gt;\(S_2\)&lt;/span&gt; ou &lt;span class="math"&gt;\(S_3\)&lt;/span&gt;. Mas como eu sei qual entrada? Não é preciso saber para qual entrada, apenas que as transições da mesma linha, separadas por &lt;code&gt;-&lt;/code&gt;, são para a mesma entrada. De fato, alguns projetistas preferem ordenar as transições em ordem crescente para facilitar a busca por estados equivalentes. E.g. (linha superior / linha inferior) 3-2/1-2 é o mesmo que 1-2/2-3, mas ordenado. Fica a seu critério decidir a melhor forma de organizar sua tabela de implicação, mas lembre-se que cada linha corresponde a exatamente dois estados separados por &lt;code&gt;-&lt;/code&gt;, para os quais a máquina de estados transicionará quando houver a mesma entrada.&lt;/p&gt;
&lt;p&gt;É de praxe também assinalar os estados que produzem saídas diferentes, pois eles não podem ser equivalentes. Neste caso, coloque uma &lt;code&gt;/&lt;/code&gt; no índice de coluna e linha (caso a máquina for de Moore) ou na transição dentro da célula (caso a máquina for de Mealy). Isto ficará mais claro no exemplo.&lt;/p&gt;
&lt;h2&gt;Procurando estados equivalentes&lt;/h2&gt;
&lt;p&gt;Com a tabela de implicação construída, devemos procurar os estados equivalentes. Isto é feito de forma exaustiva, analisando todas as células da tabela.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Risque todas as transições que vão para o mesmo estado e produzem a mesma saída (tipo s-s), pois elas são naturalmente equivalentes. E.g. se você tem uma transição 0-0, risque-a pois não é preciso analisá-la.&lt;/li&gt;
&lt;li&gt;Elimine as células com estados (Moore) ou transições (Mealy) que produzem saídas diferentes. Estes estados nunca poderão ser equivalentes.&lt;/li&gt;
&lt;li&gt;Analise uma célula qualquer que não tenha todas as transições riscadas e que não tenha sido eliminada anteriormente. Esta célula é uma candidata a equivalência.&lt;ul&gt;
&lt;li&gt;Olhe todas as linhas da célula e analise a célula alvo. E.g. se a transição marca 1-2, você deve analisar a célula correspondente aos estados S1 e S2.&lt;/li&gt;
&lt;li&gt;Se a célula alvo estiver eliminada, você deve eliminar esta célula também.&lt;/li&gt;
&lt;li&gt;Se você analisou todas as linhas e não eliminou a célula, não faça nada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Repita o (3) até que todas as células tenham sido analisadas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note que este processo é exaustivo. Para não correr o risco de analisar a mesma célula várias vezes, aconselho começar pela célula mais a direita inferior e depois passar para a segunda mais a direita inferior, e assim por diante. Não faz diferença a ordem em que você analisa as células, mas você deve se organizar para não repetir células.&lt;/p&gt;
&lt;p&gt;Durante a análise, pode acontecer de você eliminar uma linha inteira ou uma coluna inteira. Isso significa que o estado daquela linha ou coluna não é equivalente a nenhum outro estado, portanto você deve eliminar todas as células que tem alguma linha referenciando aquele estado. E.g. se você eliminou a linha toda do S3, você deve eliminar todas as células que possuam ao menos um 3 em alguma linha (x-3 ou 3-x).&lt;/p&gt;
&lt;p&gt;Note que você não precisa analisar células onde todas as linhas tenham sido riscadas no passo 1. Se você riscar todas as linhas de uma célula, os estados desta célula (linha-coluna) são automaticamente equivalentes. Você não precisa tomar nenhuma ação em relação a isso, apenas pule a análise da célula.&lt;/p&gt;
&lt;p&gt;Quando você terminar este processo, as células que você não eliminou representam &lt;strong&gt;classes de equivalência&lt;/strong&gt;. Uma classe de equivalência é um grupo de estados que são equivalentes e, consequentemente, podem ser representados por um único estado. E.g. se a célula da linha 3 coluna 4 não foi eliminada, os estados S3 e S4 são equivalentes.&lt;/p&gt;
&lt;h2&gt;Exemplo 1/2&lt;/h2&gt;
&lt;p&gt;Suponha a mesma máquina de estados usada como exemplo no método de análise da tabela de transição de estados, mostrada na figura. Trata-se de uma máquina de Mealy que reconhece 0011 ou 1001 sem sobreposição.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;A máquina tem 15 estados, portanto temos uma matriz 15x15. A tabela de implicação, já com os valores das transições preenchidos e com as transições s-s riscadas, pode ser vista na figura abaixo. Isto corresponde à construção da tabela de implicação e à execução do passo 1 do algoritmo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 1" src="https://balbertini.github.io/images/sd/sdfsmoptex1a.png"&gt;&lt;/p&gt;
&lt;p&gt;No passo dois, eliminamos as transições que produzem saídas diferentes. Note que esta é uma máquina de Mealy, então coloquei a saída na transição (e.g. nos estados S8 e S11, que são os que produzem saída, há transições na forma 0/1, indicando que esta transição produz saída 1). Quando não está especificada, assume-se que a saída é 0. Continuando o passo 2, devemos eliminar todas as células que contém uma transição s-t onde a saída de s é diferente da saída de t. Isto pode ser visto na figura abaixo, onde as células eliminadas foram identificadas com fundo cinza.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 2" src="https://balbertini.github.io/images/sd/sdfsmoptex1b.png"&gt;&lt;/p&gt;
&lt;p&gt;O passo 2 elimina os estados que obviamente não são equivalentes. Podemos então começar o passo 3 analisando cada célula. Eu comecei pela célula mais a direita inferior e continuei analisando para a esquerda. A célula S14-S13 não precisa ser analisada pois tem todas as transições riscadas. Idem para a célula S14-S12. Já a célula S14-S11 foi eliminada anteriormente e também não precisa ser analisada.&lt;/p&gt;
&lt;p&gt;A primeira célula que realmente precisa ser analisada é a S14-S6. Nesta célula, a transição 13-0 aponta para a a célula S13-S0, e a transição 14-0 para a célula S14-S0. Estas células alvo ainda indicam equivalência, então não fiz nada na célula em análise (S14-S6). Idem para S14-S5 e S14-S4.&lt;/p&gt;
&lt;p&gt;Já na célula S14-S3, encontrei uma referência à S8-S0, que já foi eliminado em um passo anterior. Isso significa que eu devo eliminar esta célula. Nesse ponto, percebi que a linha do S8 estava inteira eliminada, então eliminei na tabela todas as células que fazem referência a S8. Na figura abaixo, a célula em análise (S14-S3) está em amarelo, a célula referenciada que foi o motivo da eliminação (S8-S0) está com borda amarela, e as células que eu eliminei estão em amarelo escuro. Apesar de ter usado cores, todas estas células devem ser pintadas de cinza (quando estiver executando o algoritmo no papel, faça um X na célula toda).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 3" src="https://balbertini.github.io/images/sd/sdfsmoptex1c.png"&gt;&lt;/p&gt;
&lt;p&gt;Se está lendo com cuidado, deve ter percebido que a eliminação feita na figura anterior eliminou o estado S3 inteiro. Isto significa que você pode eliminar todas as células que contém transições que referenciam o S3, pois ele não pode ser equivalente a nenhum outro estado. Se você continuar o algoritmo, terminará com a tabela de implicação abaixo, onde as células eliminadas estão em cinza.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 fim" src="https://balbertini.github.io/images/sd/sdfsmoptex1d.png"&gt;&lt;/p&gt;
&lt;p&gt;Com o algoritmo finalizado, podemos inferir os estados equivalentes observando as células que não foram eliminadas. A célula S6-S4 indica que estes dois estados são equivalentes. Similarmente, a coluna S7 indica que os estados S7, S9, S10, S12, S13 e S14 são todos equivalentes. Isso pode ser corroborado pelas colunas do S9, S10, S11, S12 e S13, que indicam também esta equivalência. Ainda, a célula S11-S8 indica que estes estados são equivalentes (note que eles produzem saída 1).&lt;/p&gt;
&lt;p&gt;Para facilitar a visualização, a figura abaixo traz as classes de equivalência coloridas. Para a mesma cor, os estados são equivalentes.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 colorida" src="https://balbertini.github.io/images/sd/sdfsmoptex1e.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="45%" align="right" style="padding-left:5%" /&gt;
Por último, devemos reconstruir o diagrama de transição de estados. Para cada classe de equivalência, criamos um estado novo. As transições e as saídas podem ser copiadas de qualquer um dos estados da classe, pois eles são equivalentes (para as mesmas entradas, produzem a mesma saída e transicionam para o mesmo estado). Note que este método agrupa os estados em classes, então a transição do Sb (que é composto por S4 e S6) que vai para o S9, por exemplo, deve ir para o estado Sa (que é composto por S7, S9, S10, S12, S13 e S14) pois esta é a classe de equivalência que contém o S9. O diagrama desta tabela é idêntico ao obtido usando o método de análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 2/2&lt;/h2&gt;
&lt;p&gt;A Tabela E2 é a tabela de transição de estados de uma máquina de Moore. Sua funcionalidade ou diagrama de transição de estados não importam neste momento, mas o diagrama equivalente pode ser visto na figura.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diag.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo podemos ver a tabela construída e com o passo 1 executado (esquerda) e após o passo 2 executado (direita).&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2a.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2b.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo, podemos ver a tabela de implicação após o passo 3 executado a exaustão (esquerda) e com as classes de equivalência construídas (direita). Na tabela da esquerda, as linhas que provocaram a exclusão da tabela foram realçadas com um cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2c.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2d.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Conclui-se que os estados S4 e S0 (Sa) são equivalentes entre si, assim como os estados S5 e S3 (Sb). A tabela de transiçao de estados minimizada e o diagrama de transição de estados minimizado pode ser podem ser vistos abaixo.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2 min&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa/1&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sb/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diagmin.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;p/&gt;
[1] DE VRIES, A. Finite automata: Behavior and synthesis. Elsevier, 2014.&lt;br&gt;
[2] KAM, Timothy et al. Synthesis of finite state machines: functional optimization. Springer Science &amp;amp; Business Media, 2013.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="fsm"></category><category term="simplificação"></category><category term="otimização"></category></entry></feed>