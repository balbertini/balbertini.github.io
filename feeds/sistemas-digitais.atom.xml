<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>B.Albertini's site - sistemas digitais</title><link href="https://balbertini.github.io/" rel="alternate"></link><link href="https://balbertini.github.io/feeds/sistemas-digitais.atom.xml" rel="self"></link><id>https://balbertini.github.io/</id><updated>2021-05-03T08:55:51-03:00</updated><subtitle>Professor</subtitle><entry><title>Operações Aritméticas em Binário</title><link href="https://balbertini.github.io/binaryarithmetic-pt_BR.html" rel="alternate"></link><published>2020-07-31T08:57:26-03:00</published><updated>2021-05-03T08:55:51-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2020-07-31:/binaryarithmetic-pt_BR.html</id><summary type="html">&lt;p&gt;Operações Aritméticas em Binário&lt;/p&gt;</summary><content type="html">&lt;p&gt;Um computador moderno não é muito diferente de uma calculadora gigante. Pode parecer estranho, mas mesmo os &lt;em&gt;pixels&lt;/em&gt; na sua tela ou este arquivo de texto que está lendo são representados por números em binário (chamamos isto de código, mas deixemos para outro post). O "coração" de um processador é composto por várias unidades de cálculo, a grande maioria operando sobre inteiros em binário. As operações mais comuns são a adição e a subtração, mas neste post veremos todas elas.&lt;/p&gt;
&lt;h1&gt;Representação binária&lt;/h1&gt;
&lt;p&gt;Um número em binário é composto por qualquer quantidade de dígitos 0 e 1. Um único dígito é chamado de &lt;em&gt;bit&lt;/em&gt;, o conjunto de 8 bits é chamado de &lt;em&gt;byte&lt;/em&gt; e o conjunto de 4 bits é chamado de &lt;em&gt;nible&lt;/em&gt;. Os processadores modernos usam números de 64 bits, mas ainda temos muitos processadores usando 32 bits. A quantidade de bits usada para representar um número em um processador está ligada ao tamanho das estruturas de armazenamento usadas internamente para guardar os números (conhecidas como registradores) e a capacidade das unidades de cálculo (i.e. um processador de 64 bits possui registradores e unidades lógicas e aritméticas capazes de armazenar e operar números  de 64 bits).&lt;/p&gt;
&lt;p&gt;A representação binária segue a fórmula geral de representação de bases, cuja conversão para decimal é:&lt;/p&gt;
&lt;div class="math"&gt;$$
\sum_{m}^{n}{a_i.b^{i}}
$$&lt;/div&gt;
&lt;p&gt;Onde o índice &lt;span class="math"&gt;\(i\)&lt;/span&gt; começa em &lt;span class="math"&gt;\(n\)&lt;/span&gt;, passa pelo &lt;span class="math"&gt;\(0\)&lt;/span&gt; e termina em &lt;span class="math"&gt;\(m\)&lt;/span&gt; (&lt;span class="math"&gt;\(m\)&lt;/span&gt; é um número negativo). Um número em binário pode ser representado por:
&lt;/p&gt;
&lt;div class="math"&gt;$$
a_{n}a_{n-1}a_{n-2}\ldots a_{0}.a_{-1}a_{-2}\ldots a_{-m+2}a_{-m+1}a_{-m}
$$&lt;/div&gt;
&lt;p&gt;O dígito &lt;span class="math"&gt;\(a\)&lt;/span&gt; com o maior índice é chamado de &lt;strong&gt;mais significativo&lt;/strong&gt; pois é o multiplicador de maior peso (está ligado a base elevada a maior potência) e o dígito com o menor índice é chamado de &lt;strong&gt;menos significativo&lt;/strong&gt; pelo motivo oposto. Como costumamos escrever os números da esquerda para a direita, o mais significativo fica mais a esquerda e o menos significativo fica mais a direita. É comum usarmos os acrônimos MSB para o mais significativo (do inglês &lt;em&gt;Most Significant Bit&lt;/em&gt;) e LSB para o menos significativo (do inglês &lt;em&gt;Least Significant Bit&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Para converter entre bases, basta usar a fórmula geral aplicando-se a base que deseja. O &lt;span class="math"&gt;\(a\)&lt;/span&gt; corresponde a um dígito na base de origem e para converter substituímos pelo valor deste dígito no sistema alvo. Como os valores binários são 0 e 1 e os valores na base 10 são os mesmos (0 e 1, respectivamente), não há substituição a fazer, bastando usar o próprio dígito na posição &lt;span class="math"&gt;\(i\)&lt;/span&gt;. O &lt;span class="math"&gt;\(b\)&lt;/span&gt; da fórmula é o valor da base de origem na base de destino. No caso de binário para decimal, a base é 2 e o valor em decimal também é 2, então basta fazer &lt;span class="math"&gt;\(b=2\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;O número &lt;span class="math"&gt;\(101010.10101_{2}\)&lt;/span&gt; representa qual número em decimal?&lt;/p&gt;
&lt;p&gt;Vamos expandir o número usando a fórmula geral:
&lt;/p&gt;
&lt;div class="math"&gt;$$
\sum_{m}^{n}{a_i.b^{i}}
$$&lt;/div&gt;
&lt;p&gt;Como temos seis dígitos antes do . e cinco depois, &lt;span class="math"&gt;\(n=5\)&lt;/span&gt; e &lt;span class="math"&gt;\(m=-5\)&lt;/span&gt; (note que há o índice 0 antes do ponto, então o &lt;span class="math"&gt;\(n=5\)&lt;/span&gt;). Vamos expandir o número usando a fórmula geral:
&lt;/p&gt;
&lt;div class="math"&gt;$$
\sum_{5}^{-5}{a_i.b^{i}}
$$&lt;/div&gt;
&lt;p&gt;Ou na versão expandida:
&lt;/p&gt;
&lt;div class="math"&gt;$$
a_{5}.b^{5}+a_{4}.b^{4}+a_{3}.b^{3}+a_{2}.b^{2}+a_{1}.b^{1}+a_{0}.b^{0}+a_{-1}.b^{-1}+a_{-2}.b^{-2}+a_{-3}.b^{-3}+a_{-4}.b^{-4}+a_{-5}.b^{-5}
$$&lt;/div&gt;
&lt;p&gt;Substituindo os números, temos a base 2 (&lt;span class="math"&gt;\(b=2\)&lt;/span&gt;) e os dígitos &lt;span class="math"&gt;\(101010.10101_{2}\)&lt;/span&gt;, então ficamos com:
&lt;/p&gt;
&lt;div class="math"&gt;$$
1.2^{5}+0.2^{4}+1.2^{3}+0.2^{2}+1.2^{1}+0.2^{0}+1.2^{-1}+0.2^{-2}+1.2^{-3}+0.2^{-4}+1.2^{-5}
$$&lt;/div&gt;
&lt;div class="math"&gt;$$
= 1.32+0.16+1.8+0.4+1.2+0.1+1.\frac{1}{2}+0.\frac{1}{4}+1.\frac{1}{8}+0.\frac{1}{16}+1.\frac{1}{32}
$$&lt;/div&gt;
&lt;div class="math"&gt;$$
= 32+8+2+\frac{1}{2}+\frac{1}{8}+\frac{1}{32} = 42 + 0.5 + 0.125 + 0.03125 = 42.65625
$$&lt;/div&gt;
&lt;h2&gt;Conversão direta (tabela)&lt;/h2&gt;
&lt;p&gt;A fórmula geral pode ser usada para conversões entre bases facilmente, mas para conversão entre binário (base 2), octal (base 8) e hexadecimal (base 16), pelas bases serem múltiplas umas das outras, há uma maneira mais simples, usando uma tabela de conversão, que pode ser vista abaixo.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;Decimal&lt;/th&gt;
&lt;th align="center"&gt;Hexadecimal&lt;/th&gt;
&lt;th align="center"&gt;Octal&lt;/th&gt;
&lt;th align="center"&gt;Binário&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;0x0&lt;/td&gt;
&lt;td align="center"&gt;000&lt;/td&gt;
&lt;td align="center"&gt;0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;0x1&lt;/td&gt;
&lt;td align="center"&gt;001&lt;/td&gt;
&lt;td align="center"&gt;0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;2&lt;/td&gt;
&lt;td align="center"&gt;0x2&lt;/td&gt;
&lt;td align="center"&gt;002&lt;/td&gt;
&lt;td align="center"&gt;0010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;3&lt;/td&gt;
&lt;td align="center"&gt;0x3&lt;/td&gt;
&lt;td align="center"&gt;003&lt;/td&gt;
&lt;td align="center"&gt;0011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;4&lt;/td&gt;
&lt;td align="center"&gt;0x4&lt;/td&gt;
&lt;td align="center"&gt;004&lt;/td&gt;
&lt;td align="center"&gt;0100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="center"&gt;0x5&lt;/td&gt;
&lt;td align="center"&gt;005&lt;/td&gt;
&lt;td align="center"&gt;0101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;6&lt;/td&gt;
&lt;td align="center"&gt;0x6&lt;/td&gt;
&lt;td align="center"&gt;006&lt;/td&gt;
&lt;td align="center"&gt;0110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;7&lt;/td&gt;
&lt;td align="center"&gt;0x7&lt;/td&gt;
&lt;td align="center"&gt;007&lt;/td&gt;
&lt;td align="center"&gt;0111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;0x8&lt;/td&gt;
&lt;td align="center"&gt;010&lt;/td&gt;
&lt;td align="center"&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;9&lt;/td&gt;
&lt;td align="center"&gt;0x9&lt;/td&gt;
&lt;td align="center"&gt;011&lt;/td&gt;
&lt;td align="center"&gt;1001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;10&lt;/td&gt;
&lt;td align="center"&gt;0xA&lt;/td&gt;
&lt;td align="center"&gt;012&lt;/td&gt;
&lt;td align="center"&gt;1010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;11&lt;/td&gt;
&lt;td align="center"&gt;0xB&lt;/td&gt;
&lt;td align="center"&gt;013&lt;/td&gt;
&lt;td align="center"&gt;1011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;12&lt;/td&gt;
&lt;td align="center"&gt;0xC&lt;/td&gt;
&lt;td align="center"&gt;014&lt;/td&gt;
&lt;td align="center"&gt;1100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;13&lt;/td&gt;
&lt;td align="center"&gt;0xD&lt;/td&gt;
&lt;td align="center"&gt;015&lt;/td&gt;
&lt;td align="center"&gt;1101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;14&lt;/td&gt;
&lt;td align="center"&gt;0xE&lt;/td&gt;
&lt;td align="center"&gt;016&lt;/td&gt;
&lt;td align="center"&gt;1110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;15&lt;/td&gt;
&lt;td align="center"&gt;0xF&lt;/td&gt;
&lt;td align="center"&gt;017&lt;/td&gt;
&lt;td align="center"&gt;1111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Usar a tabela é bem simples: cada grupo de 3 bits (lembre-se que um bit é um dígito binário) corresponde a um dígito octal e cada grupo de 4 bits é um dígito hexadecimal, e vice-versa. Note também a representação: é comum usarmos o prefixo 0x (ou o sufixo 'h') para hexadecimal e o prefixo 0 (ou 'o') para octal, mas para evitar ambiguidades, aconselho usar a versão formal (com subscrito, e.g. &lt;span class="math"&gt;\(F_{16}=17_{8}=1111_{2}\)&lt;/span&gt;).&lt;/p&gt;
&lt;h3&gt;Exemplos&lt;/h3&gt;
&lt;p&gt;Converter &lt;code&gt;0xBEBAD0&lt;/code&gt; para binário e octal. Cada dígito hexadecimal corresponde a 4 dígitos binário, então usando a tabela temos que &lt;code&gt;0xBEBAD0 = 1011 1110 1011 1010 1101 0000&lt;/code&gt;. Com o binário, basta agruparmos de 3 em 3 e teremos o octal: &lt;code&gt;0xBEBAD0 = 101 111 101 011 101 011 010 000 = 057535320&lt;/code&gt; (o &lt;code&gt;0&lt;/code&gt; no início é só para indicar que é octal).&lt;/p&gt;
&lt;p&gt;Converter &lt;code&gt;1100101011111110&lt;/code&gt; para octal e hexadecimal. Para octal, agrupamos de 3 em 3: &lt;code&gt;1 100 101 011 111 110 = 0145376&lt;/code&gt;, e para hexadecimal de 4 em 4: &lt;code&gt;1100 1010 1111 1110 = 0xCAFE&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Representações Complementares&lt;/h1&gt;
&lt;p&gt;Muito bem, até aqui vimos números (inclusive fracionários), mas como representamos números negativos? As três maneiras mais utilizadas são: sinal-magnitude, complemento de base diminuída e complemento de base.&lt;/p&gt;
&lt;h2&gt;Sinal-Magnitude&lt;/h2&gt;
&lt;p&gt;Esta é a representação que usamos no dia a dia com o sistema decimal. Nela, o dígito mais significativo é especial e contém &lt;code&gt;+&lt;/code&gt; ou &lt;code&gt;-&lt;/code&gt; para indicar se o número é negativo ou não (a ausência implica em um número positivo). Esta representação é muito simples, e é usada em computação para representar números de ponto flutuante, chamados normalmente de &lt;em&gt;float&lt;/em&gt; ou &lt;em&gt;double&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Em binário, usamos um bit extra para isso, onde 1 significa que o número é negativo e 0 que é positivo. Um número binário de &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits pode representar &lt;span class="math"&gt;\(2^{n}\)&lt;/span&gt; números. Porém, na representação sinal-magnitude, há dois fatores importantes. O primeiro é que um dos bits é usado para representar o sinal, então com &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits podemos representar efetivamente &lt;span class="math"&gt;\(2^{n-1}\)&lt;/span&gt; números positivos e a mesma quantidade de números negativos. O segundo é que há duas representações para o zero! Isso significa que dos &lt;span class="math"&gt;\(2^{n-1}\)&lt;/span&gt; números representáveis para os positivos, um é o zero e o mesmo ocorre para os negativos. No final, podemos representar &lt;span class="math"&gt;\(2^{n}-1\)&lt;/span&gt; números, pois o zero é representado duas vezes (o zero positivo e o zero negativo). Os números representáveis estão na faixa &lt;span class="math"&gt;\(-(2^{n-1}-1)\leq x \leq +(2^{n-1}-1)\)&lt;/span&gt;. Exemplo: com 4 bits podemos representar &lt;span class="math"&gt;\(2^{4}=16\)&lt;/span&gt; números, mas usando sinal-magnitude podemos representar de &lt;code&gt;-7 (1111)&lt;/code&gt; até &lt;code&gt;+7 (0111)&lt;/code&gt;, o que nos dá efetivamente 15 números (7 negativos, 7 positivos e o zero).&lt;/p&gt;
&lt;p&gt;A grande vantagem desta representação é que é muito fácil converter um número de positivo para negativo e vice-versa: basta mudar o bit do sinal. As desvantagens são três: (1) há dois zeros, o que complica os circuitos aritméticos pois é uma excessão a tratar; (2) ainda por existirem dois zeros, desperdiçamos um número da capacidade de representação; e (3) os circuitos aritméticos são diferentes para cada operação e portanto o circuito aritmético é um pouco mais complexo que outras representações (ocupam maior área e consomem mais energia). A complexidade desta última desvantagem está ligada ao fato de sermos obrigado a verificar o sinal de ambos os operandos antes de realizar a operação.&lt;/p&gt;
&lt;h3&gt;Operações com sinal-magnitude em binário&lt;/h3&gt;
&lt;p&gt;As operações são diferentes para soma e subtração e seguem as mesmas regras que usamos na aritmética em base decimal. O cálculo do sinal deve ser realizado a parte.&lt;/p&gt;
&lt;h4&gt;Exemplo&lt;/h4&gt;
&lt;p&gt;Calcular &lt;code&gt;(+2)+(+3)&lt;/code&gt;, &lt;code&gt;(+2)-(-3)&lt;/code&gt; e &lt;code&gt;(+3)-(+4)&lt;/code&gt; em binário de 4 bits usando sinal-magnitude.&lt;/p&gt;
&lt;p&gt;Começamos obtendo a representação binária dos números:
&lt;code&gt;(+2)=0010&lt;/code&gt;, &lt;code&gt;(+3)=0011&lt;/code&gt;, &lt;code&gt;(-3)=1011&lt;/code&gt; e &lt;code&gt;(+4)=0100&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Depois observamos o sinais e montamos as operações. Como as duas primeiras operações são idênticas, montamos uma soma. Para a última operação devemos montar uma subtração. Na operação de fato, não usamos o sinal, então operaremos com &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; bits, ou três bits neste exemplo.
&lt;pre&gt;
010 (vai um)  011 (empresta um)
 010 +         100 -
 011           011
 ----          ----
 101           001
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Descrição textual da operação de soma: começamos com o LSB e somamos &lt;code&gt;(0)+0+1=01&lt;/code&gt;, ou seja, o resultado é efetivamente &lt;code&gt;1&lt;/code&gt; e o vai-um para o próximo dígito é &lt;code&gt;0&lt;/code&gt; (observe que o &lt;code&gt;(0)&lt;/code&gt; inicial é o vem-um do primeiro dígito, que assumimos como &lt;code&gt;0&lt;/code&gt; pois não há cálculos anteriores para gerar um vai-um). Depois somamos &lt;code&gt;0+1+1=10&lt;/code&gt;. Note que desta vez devemos gerar um vai-um para o próximo, então efetivamente colocamos &lt;code&gt;0&lt;/code&gt; no resultado e &lt;code&gt;1&lt;/code&gt; no vai-um. A próxima operação é &lt;code&gt;1+0+0=01&lt;/code&gt; e assim terminamos o cálculo. Como é uma soma de dois números positivos, o resultado é positivo então o resultado final com quatro bits é &lt;code&gt;0101=+5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Descrição textual da operação de subtração: começamos ordenando os números para conseguirmos efetuar a operação (neste método, sempre subtraímos o menor do maior). Partindo do LSB fazemos &lt;code&gt;0-1&lt;/code&gt;, porém não é possível realizar esta operação, então devemos emprestar um do próximo bit. Ao emprestarmos, estamos efetivamente fazendo &lt;code&gt;10-1=1&lt;/code&gt;, então colocamos o resultado &lt;code&gt;1&lt;/code&gt; e indicamos que emprestamos &lt;code&gt;1&lt;/code&gt; do bit com significância imediatamente superior. Para o próximo bit, já começamos emprestando &lt;code&gt;1&lt;/code&gt; pois o bit é &lt;code&gt;0&lt;/code&gt;, então não conseguimos realizar o cálculo. Ao emprestar, a operação se torna &lt;code&gt;1-1=0&lt;/code&gt;, e indicamos o empréstimo. A última operação seria &lt;code&gt;1-0&lt;/code&gt;, mas como houve o empréstimo ela se torna &lt;code&gt;0-0=0&lt;/code&gt; e não necessita empréstimo. Para finalizar o cálculo, estamos fazendo uma subtração de um número menor, portanto o resultado é negativo e com quatro bits é &lt;code&gt;1001=-1&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Complemento de base diminuída&lt;/h2&gt;
&lt;p&gt;O complemento de base diminuída é uma maneira de facilitar as operações aritméticas, pois a subtração se transforma em uma soma. É possível usá-lo em qualquer base, mas vamos nos concentrar no binário. Este sistema de numeração é utilizado em sistemas de propósito específicos (e.g. algumas GPUs o utilizam).&lt;/p&gt;
&lt;p&gt;Em binário, como a base é 2, chamamos esta representação de &lt;strong&gt;complemento de um&lt;/strong&gt;. Para converter um número binário de positivo para negativo e vice-versa, basta inverter todos os bits. Exemplo: &lt;code&gt;-7 = inv(7)&lt;/code&gt; que em binário de 4 bits fica &lt;code&gt;inv(0111) = 1000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A capacidade de representação é a mesma do sinal-magnitude e temos o mesmo problema dos dois zeros.&lt;/p&gt;
&lt;p&gt;O primeiro bit continua indicando o sinal (se 1 é negativo), mas a grande vantagem é que os circuitos que realizam as operações são mais simples pois a subtração pode ser realizada usando uma soma. A desvantagem é que ainda temos dois zeros, desperdiçando um número.&lt;/p&gt;
&lt;h3&gt;Operações com complemento de base em binário&lt;/h3&gt;
&lt;p&gt;Calcular &lt;code&gt;3-4&lt;/code&gt; em binário de 4 bits usando complemento de um.&lt;/p&gt;
&lt;p&gt;Isso equivale a fazer &lt;code&gt;3+(-4)&lt;/code&gt;, o que significa converter o 4 para negativo. Em binário de 4 bits usando complemento de um, ficaria &lt;code&gt;0011+inv(0100) = 0011+1011&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;
0011  (vai um)
 0011 +
 1011
 ----
 1110
&lt;/pre&gt;

&lt;p&gt;Descrição textual: primeiro encontramos o negativo do número e montamos a soma equivalente. Depois realizamos a soma normalmente e o resultado já está pronto (não é necessário nem mesmo verificar o sinal).  Para comprovar, podemos verificar que &lt;code&gt;inv(1110)=0001=1&lt;/code&gt;, ou seja, o resultado decimal é -1.&lt;/p&gt;
&lt;h2&gt;Complemento de base&lt;/h2&gt;
&lt;p&gt;O complemento de base é a representação mais utilizada em binário (base 2), onde é conhecido como &lt;strong&gt;complemento de dois&lt;/strong&gt;. Praticamente todos os processadores modernos o utilizam nas unidades lógicas e aritméticas internas para contas com inteiros e com ponto fixo, o que corresponde a maior parte dos cálculos realizados por um computador.&lt;/p&gt;
&lt;p&gt;Para converter um número binário de positivo para negativo, invertemos os bits e somamos 1. Exemplo 1: &lt;code&gt;-7=inv(7)+1&lt;/code&gt;, ou em binário de 4 bits &lt;code&gt;inv(0111)+1=1000+1=1001&lt;/code&gt;. Exemplo 2: &lt;code&gt;-1=inv(1)+1&lt;/code&gt;, em binário de 4 bits &lt;code&gt;inv(0001)+1= 1110+1=1111&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A capacidade de representação agora muda um pouco pois não temos mais dois zeros! A função de somar 1 é justamente deslocar a parte negativa para que o -0 (&lt;code&gt;1000&lt;/code&gt; em sinal magnitude e &lt;code&gt;1111&lt;/code&gt; em complemento de um) represente um número negativo (&lt;code&gt;-1=1111&lt;/code&gt; em complemento de 2). Isso faz que que um número binário &lt;span class="math"&gt;\(x\)&lt;/span&gt; de &lt;span class="math"&gt;\(n\)&lt;/span&gt; bits possa estar na faixa de &lt;span class="math"&gt;\(-(2^{n-1})\leq x \leq +(2^{n-1}-1)\)&lt;/span&gt;, ou seja, há um número negativo a mais! Exemplo: com 4 bits podemos representar &lt;span class="math"&gt;\(2^{4}=16\)&lt;/span&gt; números, e usando complemento de dois podemos representar de &lt;code&gt;-8 (1000)&lt;/code&gt; até &lt;code&gt;+7 (0111)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Apesar de ligeiramente mais complexos que os circuitos para operações em complemento de um devido à conversão exigir uma soma de 1, a representação em complemento de dois é a mais usada pois normalmente os circuitos somadores já possuem uma entrada de vai um para o bit menos significativo. Em condições normais, uma subtração em complemento de dois seria tão complexa quanto no sinal-magnitude (usando circuitos diferentes para soma e subtração) ou seriam três somas se convertermos para negativo e fizermos a soma, pois a conversão exige uma soma de +1. Se considerarmos que na maioria das operações somamos dois números somente, a entrada de vai um para o bit menos significativo não é usada (está sempre em zero), portanto podemos usá-la para implementar o complemento de dois com a mesma complexidade dos circuitos de complemento de um, mantendo a vantagem de usarmos toda a capacidade de representação (não há dois zeros). Sendo assim, o mais comum é usarmos um somador para realizar a subtração, usando a entrada do vai um (e invertendo os bits de um dos números corretamente) para realizar a soma, tornando o complemento de 2 a representação mais eficiente, desde que não usemos o vai=um de entrada.&lt;/p&gt;
&lt;h3&gt;Operações com complemento de base diminuída em binário&lt;/h3&gt;
&lt;p&gt;Realizar &lt;code&gt;3-4&lt;/code&gt; em binário usando complemento de dois.&lt;/p&gt;
&lt;p&gt;Isso equivale a fazer &lt;code&gt;3+(-4)&lt;/code&gt;, o que significa converter o 4 para negativo. Em binário de 4 bits usando complemento de dois, ficaria &lt;code&gt;0011+(inv(0100)+1) = 0011+1011+1&lt;/code&gt;. Usando o truque de inserir o +1 da conversão na entrada inicial do vai um no bit menos significativo, fica assim:&lt;/p&gt;
&lt;pre&gt;
00111 (vai um)
 0011 +
 1011
 ----
 1111
&lt;/pre&gt;

&lt;p&gt;A operação é a mesma que em complemento de um, mas com o vai-um inicial em 1. Note que o &lt;code&gt;1111&lt;/code&gt; é um número negativo  (MSB é 1), então para encontrar o número positivo equivalente, basta negar todos os bits e somar 1: &lt;code&gt;1111 = -(not(1111)+1) = -(0000+1) = -(0001)=-1&lt;/code&gt;, ou seja, o resultado em decimal é -1.&lt;/p&gt;
&lt;h1&gt;&lt;em&gt;Overflow&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;O &lt;em&gt;overflow&lt;/em&gt; acontece quando efetuamos uma operação que excede a capacidade de representação. As possibilidades são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(+A)+(+B) = -C&lt;/li&gt;
&lt;li&gt;(-A)+(-B) = +C&lt;/li&gt;
&lt;li&gt;(+A)-(-B) = -C (equivale a (+A)+(+B) = -C)&lt;/li&gt;
&lt;li&gt;(-A)-(+B) = +C (equivale a (-A)+(-B) = +C)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Onde A, B e C são números binários em qualquer uma das representações. O primeiro item, por exemplo, significa que somamos dois números positivos (primeiro bit é 0) e o resultado foi um número negativo (MSB é 1), o que claramente é um &lt;em&gt;overflow&lt;/em&gt; pois a soma de dois números positivos jamais deveria resultar em um negativo. O segundo item é a soma de dois números negativos resultando em positivo, outra situação incorreta. Já os dois últimos podem ser considerados equivalentes aos anteriores pois usamos a soma com o número negativo para realizar a subtração.&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;Overflow&lt;/em&gt; em complemento de 2&lt;/h2&gt;
&lt;p&gt;Em complemento de dois, podemos observar os vai-uns para determinar se aconteceu &lt;em&gt;overflow&lt;/em&gt;. Observe atentamente as operações a seguir.&lt;/p&gt;
&lt;pre&gt;
00000 (vai um)  01110 (vai um)
 0011 +          0011 +
 0100            0101
 ----            ----
 0111            1000
&lt;/pre&gt;

&lt;p&gt;Acima podemos ver duas somas de números positivos (note que o vai-um do bit menos significativo é zero (soma) e ambos os números começam com 0 (positivos)). No entanto, na operação da esquerda temos &lt;code&gt;3+4=7&lt;/code&gt; (sem &lt;em&gt;overflow&lt;/em&gt;) e na da direita temos &lt;code&gt;3+5=-8&lt;/code&gt; (&lt;code&gt;1000&lt;/code&gt; em complemento de 2 é -8), o que caracteriza &lt;em&gt;overflow&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A subtração é similar:&lt;/p&gt;
&lt;pre&gt;
11111 (vai um)  10011 (vai um)
 1101 +          1101 +
 1010            1000
 ----            ----
 1000            0110
&lt;/pre&gt;

&lt;p&gt;Repare que agora estamos fazendo uma subtração pois, apesar de realizarmos uma soma, estamos usando o vai-um de entrada no LSB em ambos os casos. Na esquerda fizemos &lt;code&gt;-3-5=-3+(-6)+1&lt;/code&gt;. O resultado é &lt;code&gt;1000=-8&lt;/code&gt;, sem &lt;em&gt;overflow&lt;/em&gt;. Na direita temos &lt;code&gt;-3-6=-3+(-7)+1&lt;/code&gt;, mas dessa vez note que o resultado é positivo (&lt;code&gt;0110=+6&lt;/code&gt;) portanto houve &lt;em&gt;overflow&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Agora observe os vai-uns das operações. Sempre que realizamos a soma em complemento de dois com números binários, se o vai-um final for diferente do vai-um do estágio anterior, houve um &lt;em&gt;overflow&lt;/em&gt; e o resultado não está correto. Em circuitos digitais, pode-se fazer simplesmente &lt;span class="math"&gt;\(c_{n}\oplus c_{n-1}\)&lt;/span&gt; e teremos um &lt;em&gt;flag&lt;/em&gt; que indica a presença de um &lt;em&gt;overflow&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;Explicação do da detecção do &lt;em&gt;overflow&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Vamos entender o motivo pelo qual &lt;span class="math"&gt;\(ov=c_{n}\oplus c_{n-1}\)&lt;/span&gt; funciona para binários em complemento de 2.&lt;/p&gt;
&lt;p&gt;Como realizamos somente somas (a subtração é uma soma com a representação do negativo), há somente dois casos possíveis que geram &lt;em&gt;overflow&lt;/em&gt;: (a) dois operandos positivos e resultado negativo ou (b) dois operandos negativos e resultado positivo. A soma de números de sinais opostos nunca gera &lt;em&gt;overflow&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Poderíamos facilmente fazer um comparador de 3 bits e detectar o &lt;em&gt;overflow&lt;/em&gt; usando as regras que acabamos de descrever, mas vamos entender o XOR. Sabemos que o bit de sinal na representação de complemento de dois é o MSB, então chamaremos de &lt;span class="math"&gt;\(a_n\)&lt;/span&gt; e &lt;span class="math"&gt;\(b_n\)&lt;/span&gt; o MSB, que é o bit de sinal dos operandos &lt;span class="math"&gt;\(a\)&lt;/span&gt; e &lt;span class="math"&gt;\(b\)&lt;/span&gt;, respectivamente.&lt;/p&gt;
&lt;p&gt;A última operação que realizamos é somar esta coluna, ou seja &lt;span class="math"&gt;\(a_n+b_n+c_{n-1}\)&lt;/span&gt;. O resultado é o vai-um de saída &lt;span class="math"&gt;\(c_n\)&lt;/span&gt; e o sinal do resultado, que chamaremos de &lt;span class="math"&gt;\(r_n\)&lt;/span&gt;. A última operação que realizamos é então:
&lt;/p&gt;
&lt;div class="math"&gt;$$
c_nr_n=a_n+b_n+c_{n-1}
$$&lt;/div&gt;
&lt;p&gt;
Onde &lt;span class="math"&gt;\(c_nr_n\)&lt;/span&gt; representam os dois bits resultantes da soma (e.g. 10=1+1+0).&lt;/p&gt;
&lt;p&gt;No caso (a), sabemos que &lt;span class="math"&gt;\(a_n=b_n=0\)&lt;/span&gt; e &lt;span class="math"&gt;\(r_n=1\)&lt;/span&gt;. A única possibilidade de fecharmos a equação com &lt;em&gt;overflow&lt;/em&gt; é se &lt;span class="math"&gt;\(c_{n-1}=1\)&lt;/span&gt;, quando &lt;span class="math"&gt;\(c_n=0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;No caso (b), sabemos que &lt;span class="math"&gt;\(a_n=b_n=1\)&lt;/span&gt; e &lt;span class="math"&gt;\(r_n=0\)&lt;/span&gt;. A única possibilidade de fecharmos a equação é se &lt;span class="math"&gt;\(c_{n-1}=0\)&lt;/span&gt;, quando &lt;span class="math"&gt;\(c_n=1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Note que ambos os casos, &lt;span class="math"&gt;\(c_n\neq c_{n-1}\)&lt;/span&gt; ou não há nenhuma maneira de cairmos em uma condição de &lt;em&gt;overflow&lt;/em&gt;. A operação &lt;span class="math"&gt;\(c_{n}\oplus c_{n-1}\)&lt;/span&gt; é verdadeira exatamente se &lt;span class="math"&gt;\(c_n\neq c_{n-1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="sistemas digitais"></category><category term="sistemas de numeração"></category></entry><entry><title>Algorithmic State Machines</title><link href="https://balbertini.github.io/asm-pt_BR.html" rel="alternate"></link><published>2018-12-17T15:22:53-02:00</published><updated>2021-05-03T08:55:51-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-12-17:/asm-pt_BR.html</id><summary type="html">&lt;p&gt;ASM (Algorithmic State Machines)&lt;/p&gt;</summary><content type="html">&lt;p&gt;A máquina de estados algorítmica, do inglês &lt;em&gt;Algorithmic State Machine&lt;/em&gt; (ASM), é uma forma gráfica de descrição de um circuito síncrono. Assim como os diagramas de transição de estados, a ASM captura o comportamento do circuito em um nível abstrato, mas sintetizável.&lt;/p&gt;
&lt;h2&gt;Elementos gráficos&lt;/h2&gt;
&lt;h3&gt;Estado&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_estado.png' width="20%" align="right" style="padding-left:5%" /&gt;
Um estado é representado por uma caixa quadrada com arestas orientadas entrando e saindo do estado. As arestas sempre são duas como na figura. A aresta superior pode vir de um outro elemento ASM anterior a este estado na sequencia imposta pela máquina, ou não possuir nenhuma origem, o que implica que este estado é o inicial da máquina (estado após o &lt;em&gt;reset&lt;/em&gt;). Lembre-se que, circuitos digitais, uma máquina de estado possui um e somente um estado inicial. Já a aresta inferior liga este estado ao próximo elemento na sequencia imposta pela máquina e não é opcional: deve existir e ser conectada a algum outro elemento.  &lt;/p&gt;
&lt;p&gt;O nome do estado e o seu código (em binário) são considerados obrigatórios por alguns autores. No entanto, dependendo do método de síntese adotado, a codificação não se faz necessária. Também alguns autores circulam o nome do estado, em alguns casos deixando-o  na lateral esquerda da caixa. Em sistemas digitais usamos a notação sobre a caixa (à esquerda), sem circular o nome do estado, e consideramos a codificação opcional exceto quando solicitado explicitamente.  &lt;/p&gt;
&lt;p&gt;O nome &lt;code&gt;[saídas]&lt;/code&gt; representa exatamente os sinais de saída deste estado. Por convenção, só é necessário listar os sinais ativos neste estado, pois considera-se que todas as saídas da máquina não listadas em um estado assumem o valor desativado. Lembre-se que o valor ativo de um sinal depende da lógica que está utilizando (normalmente o valor ativo é alto, ou 1). Para evitar confusão, liste sempre todos os sinais que assumem o valor 1 pois quando não dizemos nada assume-se implicitamente (convenção) que a lógica é positiva. Sinais não listados que possuam mais de um bit assumem desativado (i.e. zero) para todos os bits.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Decisor&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_decisor.png' width="30%" align="right" style="padding-left:3%" /&gt;
O decisor é o componente que faz a transição condicional entre os estados. Sem ele, toda transição seria incondicional e não dependeria de entrada alguma. É representado graficamente por um losango, com uma aresta orientada de entrada e duas de saída. A aresta de entrada é proveniente de um elemento sequencialmente anterior da máquina de estados e deve obrigatoriamente ter uma origem. As arestas de saída são condicionais, ou seja, caso a condição do decisor seja verdadeira, a máquina segue pelo caminho 1, caso contrário pelo caminho 0. É importante notar que há duas e somente duas arestas de saída, uma para o caso da condição ser falsa e outra verdadeira. Não há condição com múltiplos bits ou múltiplas saídas e as duas saídas devem ser conectadas em outro elemento ASM.&lt;br&gt;
A condição sempre deve ser uma condição resolvível em lógica booleana, retornando sempre verdadeiro ou falso (1 ou 0). É tolerável inverter as saídas de lado para facilitar o diagrama, assim como desenhar uma seta saindo na ponta inferior do losango, mas prefira sempre usar o desenho padrão como no exemplo ao lado (incluindo os lados de saída para verdadeiro e falso) para garantir que está seguindo as boas práticas.   &lt;/p&gt;
&lt;p&gt;Este componente é atemporal, ou seja, não representa tampouco depende do tempo. Isso implica que é um componente puramente combinatório e deve estar inserido em um caminho válido entre dois elementos sequenciais, que em ASM são os estados. É permitido cascatear múltiplos decisores, mas não deve-se retornar para caminhos atemporais (e.g. um decisor voltar para ele mesmo ou para um caminho atemporal; veja no final do artigo os erros mais comuns).  &lt;/p&gt;
&lt;p&gt;Há também um símbolo alternativo representado por um hexágono achatado como na parte inferior da figura ao lado. Este símbolo tem o mesmo significado do losango e, apesar de pouco utilizado, pode ser útil quando a condição tem um nome extenso.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Saída condicional&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_saidaCondicional.png' width="15%" align="right" style="padding-left:5%" /&gt;
As saídas listadas dentro de um estado são as que serão ativadas durante o tempo em que a máquina permanecer naquele estado. Contudo, há casos em que a saída não depende somente do estado mais também da(s) entrada(s) (i.e. máquina de Mealy). Para este tipo de saída, existe a representação de saída condicional, sujo símbolo é um retângulo oblongo com as laterais arrendondadas ao máximo possível (i.e. um semi-círculo). Há uma aresta direcional de entrada e uma de saída. A aresta de saída deve ser conectada a qualquer outro elemento ASM, porém este é um componente atemporal (combinatório, sem dependência temporal, como o decisor) e portanto deve estar em um caminho válido entre dois estados. A entrada de uma saída condicional deve necessariamente originar-se da saída de um ou mais decisores, quando a condição, por consequência, indicará a condição para que esta saída seja ativada. Note que não faz sentido usar uma saída condicional sem nenhum decisor no caminho que a antecede pois nesse caso a saída só depende do estado atual (i.e. máquina de Moore) e portanto deve estar dentro do estado.&lt;/p&gt;
&lt;p&gt;Assim como a lista de saídas em um estado, a lista de saídas de uma saída condicional apresenta a lista de sinais que devem ser ativados quando a máquina estiver com este caminho ativo, ou seja, a condição do grupo de decisores que a antecede for satisfeita. Note que, enquanto a máquina estiver no estado em que os decisores estão ativos, mudar a condição pode levar os decisores a ativar outro caminho, alterando o estado de ativação de uma saída condicional dependente destes decisores.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Junção&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_juncao.png' width="15%" align="right" style="padding-left:5%" /&gt;
A junção é o componente que permite juntar dois caminhos diferentes em direção a outro estado. É composta por um ponto onde chegam duas arestas direcionais e sai somente uma. Este componente deve ser desenhado na forma como está, tolerando-se que as arestas sejam desenhadas em diferentes posições ao redor do ponto, mantidas duas de entrada e uma de saída. Todas as arestas devem ter como origem ou destino um elemento ASM, incluindo outra junção, mas devem estar em um caminho sequencial (entre dois estados) pois, assim como o decisor e a saída condiciona, a junção não possui dependência temporal.  &lt;/p&gt;
&lt;p&gt;Observe que o ponto foi exagerado no exemplo ao lado. Quando desenhar sua máquina, use somente um ponto onde fique clara a convergência de duas arestas de entrada e uma de saída. De fato, em desenhos feito usando auxílio de ferramentas computacionais, é comum omitir a junção, desde que fique clara a convergência. Também é possível uma junção com mais de duas arestas de entrada, mas sempre há somente uma aresta de saída.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;Outros elementos gráficos&lt;/h3&gt;
&lt;p&gt;Alguns autores permitem uma condição em uma aresta, logo após a saída do estado e antes de qualquer outro bloco. Para isto, basta escrever o nome de uma condição booleana ao lado da aresta. Isto implica que o estado irá transicionar para aquela transição caso a condição seja verdadeira, ou não irá transicionar caso seja falsa, permanecendo no mesmo estado. Este tipo de mecanimso está relacionado ao &lt;em&gt;clock enable&lt;/em&gt; presente em &lt;em&gt;flip-flops&lt;/em&gt;. A condição é exatamente o &lt;em&gt;enable&lt;/em&gt;, prevenindo que o &lt;em&gt;flip-flop&lt;/em&gt; transicione caso seja falsa. Contudo, deve-se evitar este tipo de transição, especialmente se você é iniciante, pois: (i) nem todo &lt;em&gt;flip-flop&lt;/em&gt; conta com um &lt;em&gt;clock enable&lt;/em&gt;, e (ii) esta transição não deve permitir que o próximo estado seja acionado, complicando desnecessariamente a síntese. Nem pense em inserir uma porta no caminho do &lt;em&gt;clock&lt;/em&gt; para implementar um &lt;em&gt;clock enable&lt;/em&gt; pois as implicações podem ser bem desastrosas. Em suma: não use este tipo de construção exceto se souber o que está fazendo.&lt;/p&gt;
&lt;h2&gt;Fluxo de um diagrama ASM&lt;/h2&gt;
&lt;p&gt;Um diagrama ASM tem um fluxo simples: sai de um estado ativo e vai para o próximo. O estado ativo inicialmente é sempre aquele que é o destino da única aresta sem origem do diagrama. É possível que entre esta aresta e o estado existam junções, mas nenhum outro componente é permitido entre a aresta que representa o &lt;em&gt;reset&lt;/em&gt; e o estado inicial.&lt;/p&gt;
&lt;p&gt;A partir de um estado inicial, segue-se a analogia de circuitos chaveados: o estado ativo no momento ativa todos os elementos que estão ligados em sua saída. É possível que haja um decisor entre um estado e outro, indicando que esta é uma transição condicional: dependendo da condição ser atendida ou não, a máquina segue para um estado ou para outro. No momento da transição (sinal de &lt;em&gt;clock&lt;/em&gt;), o estado que possuir sua entrada ativa é ativado e o anterior desativado. É permitido um estado ativar-se a si mesmo bastando colocar na sua entrada uma junção,  ligando-se uma das entradas da junção a saída do estado (um laço ou &lt;em&gt;loop&lt;/em&gt;). No entanto, não é permitido que o fluxo ative dois estados. Cada transição sai de um estado e vai para outro de forma determinística e não ambígua. Caso não seja especificado, assume-se que a transição acontece na borda de subida do &lt;em&gt;clock&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Normalmente os diagramas ASM são desenhados na vertical, com o estado inicial acima na página e o final abaixo. Não há limitações em desenhá-lo em outra orientação, mas evite fugir do usual. Jamais mude a orientação do diagrama no meio do desenho (e.g. inicia-se superior e no meio do diagrama parte-se para a direita) para não dar margem a interpretações ambíguas.&lt;/p&gt;
&lt;p&gt;Uma outra maneira de visualizar o diagrama ASM é usando Blocos ASM. Cada bloco é composto por exatamente um estado e a quantidade de decisores, saídas condicionais e junções que forem necessárias para implementar a lógica desejada. O diagrama ASM passa a ser então uma ligação entre blocos ASM, de forma que todos os caminhos de saída de um bloco levam a um estado (que pode ser o estado do mesmo bloco).&lt;/p&gt;
&lt;h3&gt;Exemplo 1: máquina de detectar 1001 com sobreposição (Moore)&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_exemplo1.png' width="30%" align="left" style="padding-right:5%" /&gt;
Esta máquina possui uma entrada &lt;code&gt;e&lt;/code&gt; e uma saída &lt;code&gt;z&lt;/code&gt;. A saída &lt;code&gt;z&lt;/code&gt; é alta quando a sequencia 1001 é detectada na entrada &lt;code&gt;e&lt;/code&gt;, com sobreposição.&lt;/p&gt;
&lt;p&gt;A máquina pode ser vista ao lado, com os estados &lt;code&gt;ini&lt;/code&gt;,&lt;code&gt;S1&lt;/code&gt;,&lt;code&gt;S10&lt;/code&gt;,&lt;code&gt;S100&lt;/code&gt; e &lt;code&gt;S1001&lt;/code&gt;. O estado &lt;code&gt;ini&lt;/code&gt; é o único que possui uma aresta com origem indeterminada, portanto é o estado inicial. Note que entre esta aresta e o estado há somente uma junção, o que é permitido. A única saída da máquina, &lt;code&gt;z&lt;/code&gt;, é ativada somente no estado &lt;code&gt;S1001&lt;/code&gt;, portanto todos os outros estados não possuem lista de saída. Esta máquina não possui nenhuma saída condicional, portanto representa uma máquina de Moore.  &lt;/p&gt;
&lt;p&gt;Enquanto o estado &lt;code&gt;ini&lt;/code&gt; está ativo, sua saída também está, portanto o decisor abaixo deste estado está ativo. Este decisor possui como condição a entrada &lt;code&gt;e&lt;/code&gt;, o que implica que se a entrada for verdadeira (1) a máquina segue para a direita, caso contrário para a esquerda. Se &lt;code&gt;e=0&lt;/code&gt;, o destino do decisor é uma nova junção que acaba ativando o próprio estado &lt;code&gt;ini&lt;/code&gt;, portanto na borda de subida do &lt;em&gt;clock&lt;/em&gt; a máquina transicionará para o mesmo estado, ou seja, não há efeito sobre a máquina. É importante notar que a máquina não deixa de transicionar, apenas transiciona para o mesmo estado. Caso &lt;code&gt;e=1&lt;/code&gt; a máquina transiciona para a direita, ativando o estado &lt;code&gt;S1&lt;/code&gt;. Neste caso, na próxima borda de subida do &lt;em&gt;clock&lt;/em&gt;, o estado passará a ser o &lt;code&gt;S1&lt;/code&gt;, portanto todos os elementos abaixo de &lt;code&gt;ini&lt;/code&gt; serão desativados e os elementos abaixo de &lt;code&gt;S1&lt;/code&gt; serão ativados.&lt;/p&gt;
&lt;p&gt;Com &lt;code&gt;S1&lt;/code&gt; ativo, repete-se a análise, mas desta vez o destino será o &lt;code&gt;S10&lt;/code&gt; se &lt;code&gt;e=0&lt;/code&gt; ou &lt;code&gt;S1&lt;/code&gt; se &lt;code&gt;e=1&lt;/code&gt;. É importante notar que os caminhos ativam-se com a mudança da entrada, portanto se a entrada mudar o decisor também muda o caminho ativo imediatamente. O caminho que vale é o caminho ativo no momento da borda do &lt;em&gt;clock&lt;/em&gt;. Lembre-se que estes componentes (decisores e junções) são combinatórios, com os atrasos inerentes deste tipo de circuito, e os estados são elementos síncronos também com atrasos e ainda susceptíveis a violações nos tempos de &lt;em&gt;setup&lt;/em&gt; e &lt;em&gt;hold&lt;/em&gt;. Mudar a entrada entre duas bordas de &lt;em&gt;clock&lt;/em&gt; não altera o comportamento da máquina e a máquina transicionará para o caminho ativo no momento da borda, mas caso mude-se a entrada muito próximo da borda do &lt;em&gt;clock&lt;/em&gt;, deve-se levar em consideração os tempos envolvidos ou a máquina poderá transicionar erroneamente.&lt;/p&gt;
&lt;p&gt;Se continuarmos a análise, invariavelmente chegaremos no &lt;code&gt;S1001&lt;/code&gt;, que contém a saída &lt;code&gt;z&lt;/code&gt; na sua lista de saídas. isto significa que quanto este estado estiver ativo, a saída também estará. A única maneira de chegarmos neste estado é a entrada assumir os valores &lt;code&gt;1001&lt;/code&gt; antes de cada borda de subida do &lt;em&gt;clock&lt;/em&gt;, portanto o estado &lt;code&gt;S1001&lt;/code&gt; é literalmente o estado onde a máquina detecta que observou o valor correto na entrada. Observe também a transição a partir deste estado: elas não voltam para o estado &lt;code&gt;ini&lt;/code&gt; e sim para os estados correspondentes a sobreposição. E.g. se após detectarmos uma sequencia começarmos outra (&lt;code&gt;1001001&lt;/code&gt;), a máquina produzirá saída &lt;code&gt;z=1&lt;/code&gt; em ambos os &lt;code&gt;1&lt;/code&gt; depois do primeiro.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h3&gt;Exemplo 2: máquina de detectar 1001 com sobreposição (Mealy)&lt;/h3&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/asm_exemplo2.png' width="30%" align="left" style="padding-right:5%" /&gt;
Esta máquina é similar a de Exemplo 1. Há uma única diferença, na geração da saída, que é dependente da entrada, caracterizando a máquina como Mealy.&lt;/p&gt;
&lt;p&gt;Até o estado &lt;code&gt;S100&lt;/code&gt; a máquina tem comportamento idêntico à máquina do Exemplo 1. Neste estado, caso a entrada &lt;code&gt;e=0&lt;/code&gt;, transicionamos para a esquerda (indo para o estado &lt;code&gt;ini&lt;/code&gt; pois detectou-se a sequencia errada &lt;code&gt;1000&lt;/code&gt; na entrada). Mas caso &lt;code&gt;e=1&lt;/code&gt;, o caminho ativado será o da direita. Como neste caminho temos uma saída condicional, a saída &lt;code&gt;z&lt;/code&gt; estará ativa enquanto este caminho estiver ativo, ou seja, enquanto a máquina estiver no estado &lt;code&gt;S100&lt;/code&gt; e a entrada for &lt;code&gt;e=1&lt;/code&gt;. A saída condicional também é um elemento combinatório, portanto a saída &lt;code&gt;z&lt;/code&gt; será &lt;code&gt;1&lt;/code&gt; assim que a entrada mudar para &lt;code&gt;1&lt;/code&gt; (e os atrasos de propagação forem atendidos). Se durante o estado &lt;code&gt;S100&lt;/code&gt;(entre a borda de subida do &lt;em&gt;clock&lt;/em&gt; onde este estado foi ativado e antes da próxima borda de subida) mudarmos o valor da entrada, também mudaremos o valor da saída! Esta é uma característica das máquinas Mealy, onde a saída depende não somente do estado mas também das entradas.&lt;/p&gt;
&lt;p&gt;Mas é possível escrever uma saída também na lista dos estados. Por exemplo: suponha que queiramos uma saída secundária &lt;code&gt;y&lt;/code&gt;, que é alta quando a máquina detectar &lt;code&gt;10&lt;/code&gt; durante a detecção da sequencia principal. Bastaria para isso escrever &lt;code&gt;y&lt;/code&gt; dentro do estado &lt;code&gt;S10&lt;/code&gt;. Ao atingir este estado, a máquina ativa a saída &lt;code&gt;y&lt;/code&gt;. Isto está correto, mas não misturamos uma saída Moore com uma saída Mealy? Há autores que defendem que em ASM pode-se fazer máquinas mistas, ou seja, com saídas dependentes somente do estado e saídas dependentes do estado e da entrada, na mesma máquina. Não se engane: isto é uma falácia pois uma máquina deste tipo é uma máquina Mealy. Se há uma saída qualquer na máquina que dependa de uma entrada, a máquina deve ser classificada como Mealy. Em ASM é possível que uma mesma saída seja escrita em um estado e em uma saída condicional, portanto esta saída será ativa quando atingir-se aquele estado e quando ativar-se aquele caminho. Este poder de expressão não existe em um diagrama de transição de estados e costuma confundir quem está aprendendo, mas não implica em máquina mista e sim numa máquina de Mealy.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;!--
### Síntese de ASM

### Erros comuns
erros na montagem do fluxo
pseudo-código na asm, Confusão com fluxograma

 --&gt;

&lt;hr&gt;
&lt;h2&gt;Quando devo usar ASM?&lt;/h2&gt;
&lt;p&gt;O diagrama ASM foi criado na década de 70 e esquecido desde então pois na maioria das vezes a síntese de uma ASM é feita usando &lt;em&gt;one-hot-encoding&lt;/em&gt;. Naquela época, este tipo de síntese era inaceitável pois um &lt;em&gt;flip-flop&lt;/em&gt; era caro para se desperdiçar em um único estado, então os projetistas digitais preferiam sintetizar a máquina com a melhor otimização possível em relação ao número de &lt;em&gt;flip-flops&lt;/em&gt;, não raramente feita manualmente. No entanto, com o advento dos sintetizadores modernos, você pode expressar-se usando uma ASM e o sintetizador irá gerar um hardware tão otimizado ou até mais otimizado que o feito manualmente. Além disso, se você estiver usando FPGA para prototipar seu hardware, o sintetizador provavelmente irá usar &lt;em&gt;one-hot-encoding&lt;/em&gt; de qualquer forma devido a organização interna destes dispositivos.&lt;/p&gt;
&lt;p&gt;A vantagem de se utilizar ASM é que o diagrama é muito próximo de um pseudo-algoritmo. É muito comum começar um projeto digital com uma prova de conceito em software que resolva o problema. Neste sentido, partir para uma ASM, especialmente quando utiliza-se metodologias de divisão e conquista (e.g. fluxo de dados e unidade de controle), facilita o trabalho do projetista evitando erros e aumentando a legibilidade, sem prejudicar a qualidade do hardware gerado. Por estas razões, a utilização de ASM vem crescendo e é comum vê-las em projetos digitais. VHDL e Verilog, as duas linguagens de descrição de hardware mais comuns, contam com padrões onde é possível expressar uma ASM facilmente. Há diversas ferramentas que suportam ASM (inclusive graficamente) e há até mesmo uma linguagem totalmente dedicada à expressão de diagramas ASM (&lt;a href="http://www.epyme.uva.es/asm++"&gt;ASM++&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Se você tem um pseudo-código ou um algoritmo que resolve o seu problema e precisa transformá-lo em um &lt;em&gt;hardware&lt;/em&gt;, parta para uma ASM.&lt;/p&gt;
&lt;h3&gt;Contribuições&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2/set/2020: Lucas Lopes de Paula Junior detectou um erro (já corrigido no texto) sobre a saída condicional.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- Analogia com redes de petri

Diferença entre FSM , psudo-código na asm--&gt;</content><category term="sistemas digitais"></category><category term="sistemas digitais"></category><category term="asm"></category></entry><entry><title>Exercício: Associação de Contadores</title><link href="https://balbertini.github.io/er0002-pt_BR.html" rel="alternate"></link><published>2018-10-12T12:29:36-03:00</published><updated>2019-02-26T17:24:30-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-12:/er0002-pt_BR.html</id><summary type="html">&lt;p&gt;Exercício resolvido de sistemas digitais: associação de contadores.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Assunto: Associação de contadores&lt;/p&gt;
&lt;h2&gt;Enunciado&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20181012_associacaoContadores.png' align="left" width="50%" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;p&gt;Mostra-se no circuito ao lado uma associação de contadores. Sabe-se que o &lt;em&gt;load&lt;/em&gt; é síncrono e o &lt;em&gt;reset&lt;/em&gt; assíncrono.&lt;br&gt;
Pede-se: (i) o módulo da contagem e (ii) as formas de onda nos pontos A e B.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Solução&lt;/h2&gt;
&lt;p&gt;Os contadores são de módulo 16, ou seja, tem capacidade de contar de 0000 (0) a 1111 (15). O contador A está em um arranjo onde ele se auto-carrega de 0101 (5) quando seu valor atingir 1001 (9), formando um contador de 5 a 9, ou seja, módulo 5. O contador B está em um arranjo onde ele se auto-reseta quando sua contagem for 0011 (3). Contudo, como o &lt;em&gt;reset&lt;/em&gt; é assíncrono, assim que este valor é atingido o contador reseta-se de imediato, portanto os valores de contagem são de 0000 (0) a 0010 (2), ou seja, módulo 3.&lt;/p&gt;
&lt;p&gt;Os contadores ainda estão em cascata, onde o valor de carga do contador A (1001) é usado como &lt;em&gt;enable&lt;/em&gt; para o contador B. Nesse arranjo em cascata, mesmo que o &lt;em&gt;clock&lt;/em&gt; seja comum a ambos, podemos dizer que o contador B conta uma vez para cada ciclo completo de contagem do contador A.&lt;/p&gt;
&lt;p&gt;O módulo da contagem total é 15. O ciclo de contagem em regime será: 0101 0000, 0110 0000, 0111 0000, 1000 0000, 1001 0000, 0101 0001, 0110 0001, 0111 0001, 1000 0001, 1001 0001, 0101 0010, 0110 0010, 0111 0010, 1000 0010, 1001 0010. As formas de onda em A e em B podem ser descritas como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A: é alto quando o contador A estiver na contagem máxima, ou seja, a cada 4 pulsos de &lt;em&gt;clock&lt;/em&gt;, com duração de 1 pulso de &lt;em&gt;clock&lt;/em&gt;. Período do sinal: 5 pulsos de &lt;em&gt;clock&lt;/em&gt;, &lt;em&gt;Duty-cycle&lt;/em&gt;: 20%.&lt;/li&gt;
&lt;li&gt;B: é alto quando o contador B estiver na contagem máxima, ou seja, a cada 10 pulsos de &lt;em&gt;clock&lt;/em&gt;, com duração de 5 pulsos de &lt;em&gt;clock&lt;/em&gt;. Período do sinal: 15 pulsos de &lt;em&gt;clock&lt;/em&gt;. &lt;em&gt;Duty-cycle&lt;/em&gt;: 33%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A figura abaixo mostra os dois sinais, e também as saídas dos contadores. Repare que o primeiro ciclo é diferente pois o contador A começa em zero e não com o valor de carga.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Forma de onda do Exercício" src="/images/sd/er/er0002_onda.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://balbertini.github.io/extra/sd/er/er0002.zip"&gt;Download da descrição em VHDL&lt;/a&gt;&lt;br&gt;
&lt;a href="https://balbertini.github.io/extra/sd/er/20181012_associacaoContadores.circ"&gt;Download do circuito no LogiSim&lt;/a&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;</content><category term="sistemas digitais"></category><category term="sistemas digitais"></category><category term="exercícios resolvidos"></category><category term="associação de contadores"></category></entry><entry><title>Exercício: Análise de Circuitos Realimentados</title><link href="https://balbertini.github.io/er0001-pt_BR.html" rel="alternate"></link><published>2018-10-09T23:38:44-03:00</published><updated>2019-02-26T17:24:30-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-09:/er0001-pt_BR.html</id><summary type="html">&lt;p&gt;Exercício resolvido de sistemas digitais: análise de circuitos realimentados.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Assunto: Análise de circuitos realimentados&lt;/p&gt;
&lt;h2&gt;Enunciado&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTnoReset.png' align="left" width="35%" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;p&gt;O circuito ao lado é um circuito digital sequencial realimentado, com entradas T e C, e saída Q. Analise-o por completo, apresentando:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As equações de excitação e saída;&lt;/li&gt;
&lt;li&gt;A tabela de transição de estados e saída;&lt;/li&gt;
&lt;li&gt;Análise de corridas (e classificação se houve);&lt;/li&gt;
&lt;li&gt;A tabela de fluxo e saída;&lt;/li&gt;
&lt;li&gt;O diagrama de transição de estados da máquina.&lt;/li&gt;
&lt;/ul&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Solução&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTvBuffers.png' align="right" width="35%" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;p&gt;Vamos começar colocando os buffers virtuais, como na figura ao lado. Já aproveitei e nomeei todas as conexões existentes para facilitar o próximo passo: a extração das equações.&lt;/p&gt;
&lt;div class="math"&gt;$$
I=\overline{T.C.Y_2}\\
J=\overline{\overline{T}.\overline{C}.\overline{Y_2}}\\
K=\overline{\overline{T}.\overline{C}.Y_2}\\
L=\overline{T.C.\overline{Y_2}}\\
M=\overline{Y_1.K.L}\\
N=\overline{T.\overline{C}.\overline{Y_1}}\\
O=\overline{T.\overline{C}.Y_1}\\
P=\overline{Y_2.O}
$$&lt;/div&gt;
&lt;p&gt;Resolvendo &lt;span class="math"&gt;\(M\)&lt;/span&gt; e &lt;span class="math"&gt;\(P\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
M=\overline{Y_1.K.L}=\overline{Y_1.\overline{\overline{T}.\overline{C}.Y_2}.\overline{T.C.\overline{Y_2}}}=\overline{Y_1.(T+C+\overline{Y_2}).(\overline{T}+\overline{C}+Y_2)}\\
 =\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}\\
P=\overline{Y_2.O}=\overline{Y_2.\overline{T.\overline{C}.Y_1}}=\overline{Y_2.(\overline{T}+C+\overline{Y_1})}=\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}
$$&lt;/div&gt;
&lt;p&gt;E finalmente resolvendo &lt;span class="math"&gt;\(Y_1^*\)&lt;/span&gt; e &lt;span class="math"&gt;\(Y_2^*\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
Y_1^*=\overline{I.J.M}\\
=\overline{\overline{T.C.Y_2}.\overline{\overline{T}.\overline{C}.\overline{Y_2}}.\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}}\\
=T.C.Y_2+\overline{T}.\overline{C}.\overline{Y_2}+T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}\\
Y_2^*=\overline{N.P}=\overline{\overline{T.\overline{C}.\overline{Y_1}}.\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}}\\
=T.\overline{C}.\overline{Y_1}+\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2\\
$$&lt;/div&gt;
&lt;p&gt;O próximo passo é preencher a tabela de transição de estados e saída. A tabela preenchida pode ser vista abaixo, para &lt;span class="math"&gt;\(Y_1^*Y_2^*\)&lt;/span&gt;. Os estados contornados são estados estáveis, ou seja, não há mudança de estado para aquela entrada. Também podemos ver a tabela de fluxo, com as saídas.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabelas de transição de estados e de fluxo, com saídas" src="https://balbertini.github.io/images/sd/er/er0001_tranTable.png"&gt;&lt;/p&gt;
&lt;p&gt;Na tabela de transição de estados, podemos fazer a análise de corridas. Uma corrida acontece quando &lt;strong&gt;uma única mudança na entrada causa uma mudança em mais de uma variável de estado&lt;/strong&gt;. No nosso caso, uma única mudança em &lt;span class="math"&gt;\(T\)&lt;/span&gt; ou &lt;span class="math"&gt;\(C\)&lt;/span&gt; (tanto de zero para um quanto de um para zero, em qualquer uma das entradas), deve provocar uma mudança das variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt; de mais de um bit, ou seja, de 00 para 11 ou de 10 para 01 (ou vice-versa). Na tabela, podemos verificar que não há corridas. Exemplo: na primeira linha estamos com as variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt; em 00. Nenhuma transição desta linha indica uma transição para 11, as transições possíveis são para 10, 00, 00 e 01, de acordo com as entradas 00, 01, 11 ou 10 respectivamente. Isso significa que, se estivermos no estado 00, uma mudança de um bit não ocasionará uma mudança de mais de um bit nas variáveis de estado. Ainda precisamos analisar as colunas. Se estivermos no mesmo estado (00) e a entrada estiver em 00, as variáveis de estado indicam que o próximo estado é 10, que é estável, portanto esta mudança irá acontecer. Do estado 00 para 10 só há uma mudança nas variáveis de estado, então não há corrida. Se estivermos no estado 00 e a entrada for 01 ou 11, o estado já é estável, então não há mudança alguma nas variáveis de estado. No caso da entrada 10, o novo estado será 01, que é estável e só muda um bit da variável de estado. Prossegue-se com a análise para o restante da tabela e conclui-se que não há corrida alguma. Após a análise de corridas, pode-se montar a tabela de fluxo (com saídas), mostrada do lado direito da figura. Para facilitar, adotou-se a codificação de estados como &lt;span class="math"&gt;\(S_i\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(i\)&lt;/span&gt; é o número decimal que representa as variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt;. É preferível fazer a análise de corrida na tabela de transição em binário, pois é mais fácil perceber as mudanças.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/er0001_diagrama.png' align="right" width="35%" style="padding-left:5%" /&gt;
Por último, montamos o diagrama de transição de estados, que fica conforme a figura ao lado.&lt;/p&gt;
&lt;p&gt;A análise de comportamento é opcional, mas é relativamente fácil perceber que se trata de um &lt;em&gt;flip-flop&lt;/em&gt; tipo T sensível a borda de descida. A análise pode ser feita da seguinte forma: começa-se no estado &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; (pode ser qualquer estado) e analisa-se o comportamento das entradas. Percebe-se que, a única maneira de sair desse estado é se a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; for zero, de onde conclui-se que o circuito é algo que espera esta entrada virar zero. Nota-se ainda que, quando isso acontece, a saída muda caso a entrada &lt;span class="math"&gt;\(T\)&lt;/span&gt; seja um, caso contrário não muda. Todos os estados "seguram" a borda da entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt;, ou seja, independentemente se formos para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; ou &lt;span class="math"&gt;\(S_2\)&lt;/span&gt; a partir do &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; não altera mais o comportamento da máquina exceto se for para um e depois para zero novamente. Poderíamos dizer que os estados tem estas funções:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_0\)&lt;/span&gt;: saída zero, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;: saída um, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;: saída zero, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_3\)&lt;/span&gt;: saída um, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Repare que o efeito &lt;em&gt;toggle&lt;/em&gt; só acontece nas arestas horizontais, de &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; e de &lt;span class="math"&gt;\(S_3\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://balbertini.github.io/extra/sd/er/20181009_projFfT.circ"&gt;Download do circuito no LogiSim&lt;/a&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="sistemas digitais"></category><category term="exercícios resolvidos"></category><category term="análise"></category><category term="circuitos realimentados"></category></entry><entry><title>Máquinas de Estados Finitas</title><link href="https://balbertini.github.io/fsmbasics-pt_BR.html" rel="alternate"></link><published>2018-09-25T17:13:05-03:00</published><updated>2019-08-30T16:26:09-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-25:/fsmbasics-pt_BR.html</id><summary type="html">&lt;p&gt;Introdução a máquinas de estados finitas em sistemas digitais.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Uma máquina de estados é uma representação matemática de um sistema dependente de tempo. É composta por estados e transições. Cada estado representa o sistema em um determinado momento no tempo e não é possível uma máquina de estados estar em dois estados ao mesmo tempo. Quando uma máquina está em um estado, ela aguarda que as condições para uma transição sejam atingidas e, assim que forem, muda para o estado indicado por esta transição, repetindo o ciclo o ciclo. Cada máquina possui um estado inicial, onde a máquina começa, e pode ter um ou mais estados finais (ou de aceitação), indicando que a máquina terminou a tarefa computacional. É um modelo de computação bastante utilizado para modelar circuitos sequenciais.&lt;/p&gt;
&lt;p&gt;Tecnicamente, a máquina de estados finita que estudamos em sistemas digitais é um &lt;strong&gt;transdutor de estados finitos&lt;/strong&gt;. A diferença primária entre uma máquina de estados e o transdutor é que este último não tem um estado de aceitação.&lt;/p&gt;
&lt;p&gt;Uma máquina de estados finita pode ser especificada por uma sêxtupla do tipo:
&lt;/p&gt;
&lt;div class="math"&gt;$$
M=(S, S_0, \Sigma, \Lambda, T, G)
$$&lt;/div&gt;
&lt;p&gt;
Onde &lt;span class="math"&gt;\(S\)&lt;/span&gt; é o conjunto de estados possíveis e &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; é o estado inicial, &lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; e &lt;span class="math"&gt;\(\Lambda\)&lt;/span&gt; denotam os alfabetos da máquina, respectivamente de entrada e de saída, &lt;span class="math"&gt;\(T\)&lt;/span&gt; é a função de transição de estados e &lt;span class="math"&gt;\(G\)&lt;/span&gt; a função de saída.&lt;/p&gt;
&lt;p&gt;As funções de transição de estados e de saída são dadas por &lt;span class="math"&gt;\(T:S\times\Sigma\rightarrow S\)&lt;/span&gt; e &lt;span class="math"&gt;\(G:S\rightarrow\Lambda\)&lt;/span&gt; (Moore) ou &lt;span class="math"&gt;\(G:S\times\Sigma\rightarrow\Lambda\)&lt;/span&gt; (Mealy).&lt;/p&gt;
&lt;p&gt;É importante notar que o alfabeto de entrada e saída em sistemas digitais é sempre &lt;span class="math"&gt;\(\{0,1\}\)&lt;/span&gt; pois, quando o circuito for realizado, todos os sinais da máquina serão binários. Isso significa que &lt;span class="math"&gt;\(\Sigma=\Lambda\)&lt;/span&gt;, então alguns autores simplificam a máquina de estados para uma quíntupla:
&lt;/p&gt;
&lt;div class="math"&gt;$$
M=(S, S_0, \Sigma, T, G)
$$&lt;/div&gt;
&lt;p&gt;Outra diferença notável das máquinas de estado finitas em sistemas digitais em relação ao conceito matemático é o determinismo. Em sistemas digitais, as máquinas podem ter transições aceitando &lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;, ou seja, transições que acontecem independentemente da entrada, mas não podem ter mais de uma transição para a mesma entrada. Isso significa que as implementações de máquinas de estados finitas em sistemas digitais são sempre determinísticas.&lt;/p&gt;
&lt;h2&gt;Conceito de máquina de estados finita em sistemas digitais&lt;/h2&gt;
&lt;p&gt;Já afirmamos que a máquina de estados em sistemas digitais não tem um estado de aceitação. Isso significa que a máquina é infinita, ou seja, executa para sempre. O modelo de estado de aceitação pode ser facilmente implementado colocando uma transição para o próprio estado (laço) e fazendo com que este estado produza uma saída pertinente à tarefa cuja máquina deveria realizar.&lt;/p&gt;
&lt;p&gt;Em sistemas digitais, a máquina de estados representa um circuito sequencial. Quando síncrono, há uma transição de estados em cada borda de &lt;em&gt;clock&lt;/em&gt; (normalmente especifica-se somente uma das bordas, e.g. borda de subida). A transição pode ser para o mesmo estado (laço) ou vazia (incondicional), mas sempre ocorre na borda do &lt;em&gt;clock&lt;/em&gt;. Quando assíncrona, a transição ocorre assim que uma das condições para transição é satisfeita, portanto não é aconselhável especificar transições vazias neste tipo de máquina.&lt;/p&gt;
&lt;p&gt;Como a máquina é determinística, em cada estado deve haver transições contemplando cada combinação possível de entrada.&lt;/p&gt;
&lt;p&gt;Revisitando a quíntupla &lt;span class="math"&gt;\(M=(S, S_0, \Sigma, T, G)\)&lt;/span&gt;, podemos fazer algumas considerações sobre sua aplicação em sistemas digitais. &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; é o estado que a máquina deve assumir inicialmente, portanto deve ser o estado da máquina após um &lt;em&gt;reset&lt;/em&gt;. Normalmente o &lt;em&gt;reset&lt;/em&gt; das máquinas de estados é assíncrono e ativo baixo por motivos históricos ligados a implementação, mas não há impedimentos para adotar-se outras abordagens, desde que possa-se colocar a máquina explicitamente no estado inicial de alguma forma. O alfabeto &lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; já foi dito que é sempre o binário &lt;span class="math"&gt;\({0,1}\)&lt;/span&gt;, mas é possível existir entradas e saídas com mais de um bit. O &lt;span class="math"&gt;\(S\)&lt;/span&gt; representa o conjunto de estados possíveis e na implementação em sistemas digitais, sempre é um elemento de memória. As funções &lt;span class="math"&gt;\(T\)&lt;/span&gt; (função de excitação ou de próximo estado) e &lt;span class="math"&gt;\(S\)&lt;/span&gt; (função de saída) são circuitos combinatórios. A figura abaixo ilustra o modelo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Modelo de FSM" src="https://balbertini.github.io/images/sd/fsmmodel.png"&gt;&lt;/p&gt;
&lt;p&gt;A linha pontilhada é opcional e, quando presente, indica que a máquina é uma máquia de Mealy.&lt;/p&gt;
&lt;h2&gt;Representação Gráfica&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/fsmexemplo2.png' width="15%" align="right" style="padding-left:5%" /&gt;
A representação gráfica de uma máquina de estados finita em sistemas digitais é o diagrama de transição de estados. Cada estado é representado por um círculo e as transições são representadas por setas. Na figura ao lado podemos ver uma máquina de estados com dois estados (&lt;em&gt;A&lt;/em&gt; e &lt;em&gt;B&lt;/em&gt;) e quatro transições. Nas transições estão especificadas que entradas levam a tomada daquela transição.&lt;/p&gt;
&lt;p&gt;No caso ao lado, a máquina é de Mealy, então a transição especifica um par &lt;em&gt;e/s&lt;/em&gt; onde &lt;em&gt;e&lt;/em&gt; é a entrada e &lt;em&gt;s&lt;/em&gt; é a saída. Exemplo: se estivermos no estado &lt;em&gt;B&lt;/em&gt; e a entrada for &lt;em&gt;0&lt;/em&gt;, continuaremos no estado &lt;em&gt;B&lt;/em&gt; e produziremos saída &lt;em&gt;1&lt;/em&gt;; já se estivermos no mesmo estado mas a entrada for &lt;em&gt;1&lt;/em&gt;, iremos para o estado &lt;em&gt;A&lt;/em&gt; e produziremos saída &lt;em&gt;0&lt;/em&gt;. A especificação formal desta máquina é:&lt;/p&gt;
&lt;div class="math"&gt;$$M=(S, S_0, \Sigma, T, G)\\
S=\{A,B\}\quad S_0=A\quad \Sigma=\{1,0\}\\
T=\{(A,0)\rightarrow A,(A,1)\rightarrow B,(B,0)\rightarrow B,(B,1)\rightarrow A\}\\
G=\{(A,0)\rightarrow 0,(A,1)\rightarrow 1,(B,0)\rightarrow 1,(B,1)\rightarrow 0\}$$&lt;/div&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/fsmexemplo1.png' width="15%" align="right" style="padding-left:5%" /&gt;
Uma máquina de Moore pode é representada da mesma forma, porém o círculo representando o estado é cortado ao meio e a saída é especificada na parte inferior, como na figura ao lado. As transições, representadas pelas arestas, possuem somente a entrada &lt;em&gt;e&lt;/em&gt; especificada, pois nesta máquina a saída não depende da entrada e sim somente do estado.&lt;/p&gt;
&lt;p&gt;A especificação formal é similar, porém a função de de saída (&lt;span class="math"&gt;\(G\)&lt;/span&gt;) não possui a entrada:&lt;/p&gt;
&lt;div class="math"&gt;$$M=(S, S_0, \Sigma, T, G)\\
S=\{A,B\}\quad S_0=A\quad \Sigma=\{1,0\}\\
T=\{(A,0)\rightarrow A,(A,1)\rightarrow B,(B,0)\rightarrow B,(B,1)\rightarrow A\}\\
G=\{A\rightarrow 0,B\rightarrow 1\}$$&lt;/div&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Síntese&lt;/h2&gt;
&lt;p&gt;Dado que &lt;span class="math"&gt;\(S\)&lt;/span&gt; é um elemento de memória, podemos usar qualquer um dos elementos de memória disponíveis para implementá-lo. É comum a utilização de &lt;em&gt;flip-flops&lt;/em&gt;, mas até mesmo memórias capacitivas podem ser utilizadas.
Já as funções de transição de estados (também chamada de função de próximo estado ou de excitação) e de saída, por serem circuitos combinatórios, são sintetizadas como tal. Pode-se usar qualquer técnica de síntese de circuitos combinatórios para ajudar, desde álgebra booleana até mapas de Karnaugh. O mais comum é montar uma tabela verdade com os estados e depois sintetizar usando-se minimização por Karnaugh e desenho direto das equações em forma de diagrama esquemático.&lt;/p&gt;
&lt;p&gt;Os passos para a síntese de uma máquina de estados finita em sistemas digitais são:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Entender o problema (enunciado, texto, variáveis de entrada e saída, temporização, etc.);&lt;/li&gt;
&lt;li&gt;Elaborar uma descrição funcional da máquina;  &lt;ul&gt;
&lt;li&gt;Elaborar um diagrama de transição de estados;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Obter a tabela de estados e a tabela de saídas;&lt;ul&gt;
&lt;li&gt;Reduzir as tabelas;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Designação de estados;&lt;/li&gt;
&lt;li&gt;Tabela de excitação;&lt;/li&gt;
&lt;li&gt;Projeto dos circuitos combinatórios (funções &lt;span class="math"&gt;\(T\)&lt;/span&gt; e &lt;span class="math"&gt;\(G\)&lt;/span&gt;);&lt;/li&gt;
&lt;li&gt;Montagem do diagrama lógico (esquemático).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O passo 1 consiste em entender o comportamento do sistema sequencial sendo modelado. Em muitos casos o diagrama esquemático está disponível, simplificando este passo. Em outras palavras, é possível sintetizar uma máquina de estados sem o conhecimento da aplicação, desde que o passo 1 ou o passo 2 estejam disponíveis. Neste passo, você deve identificar todas as entradas e saídas da máquina de estados, assim como o momento exato onde cada saída deve ser gerada. Se for necessário, faça uma carta de tempos do funcionamento da máquina. Neste passo também devemos escolher se usaremos o modelo de Melay ou de Moore.&lt;/p&gt;
&lt;p&gt;No passo 2 devemos identificar o número de estados necessários e anotar os momentos em que as saídas serão produzidas. A forma mais comum é expressar a saída deste passo com um diagrama de transição de estados. Pode ser útil nomear os estados no final do desenho do diagrama, pois este tende a mudar conforme se exercita a máquina. O teste de mesa (exercitar a máquina com entradas), é crucial para termos certeza que o diagrama atende a solução do problema. Também não precisamos nos preocupar com estados excessivos ou redundantes pois a máquina será minimizada posteriormente.&lt;/p&gt;
&lt;p&gt;A tabela de estados e a tabela de saída costumam ser montadas juntas, no passo 3. Esta tabela tem as mesmas informações que o passo 2, porém em forma de tabela. Opcionalmente podemos minimizar as tabelas usando um &lt;a href="https://balbertini.github.io/fsmstatereduction-pt_BR.html"&gt;método de minimização de máquinas de estado&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Com as tabelas minimizadas, o passo 4 visa qualificar e quantificar o elemento de memória a ser usado (&lt;span class="math"&gt;\(S\)&lt;/span&gt;). Normalmente usamos &lt;span class="math"&gt;\(n\)&lt;/span&gt; &lt;em&gt;flip-flops&lt;/em&gt; tipo D, sendo &lt;span class="math"&gt;\(n=\lceil log_2s\rceil\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(s\)&lt;/span&gt; é o número de estados. Caso o número de estados não seja uma potência de 2, deve-se decidir neste passo o que fazer com os estados que sobrarem. As opções possíveis são: (i) nada, assim aumentamos as possibilidades de minimização das funções combinatórias mas caso a máquina alcance um destes estados, a saída pode não ser neutra; (ii) forçar a saída para um valor neutro, diminuindo as possibilidades de minimização da função de saída; ou (iii) idem ao (ii) mas também forçamos a máquina para o estado inicial no próximo ciclo. A opção (i) é a que oferece a maior possibilidade de minimização e a opção (iii) é a mais segura. Com as escolhas feitas, deve-se determinar as variáveis de estado e designar o código de cada estado. Uma boa designação de estados pode implicar em melhor minimização, mas não há uma regra específica. Um truque comum é designarmos os estados usando código de Gray, assim os mapas de Karnaugh podem ser facilmente montados (assumindo que você utilizará esta técnica).&lt;/p&gt;
&lt;p&gt;Caso não tenha escolhido o tipo de &lt;em&gt;flip-flop&lt;/em&gt; no passo 4, você deve escolher antes de começar o passo 5. Neste passo, devemos montar a tabela de excitação levando em consideração as características do elemento de memória escolhido. O nome desta tabela (tabela de excitação) remete às informações da tabela, pois esta não traz o próximo estado e sim o que deve ser colocado nas entradas dos elementos de memória para que suas saídas sejam o próximo estado no momento adequado (i.e. próxima borda do &lt;em&gt;clock&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Temos a tabela de excitação (passo 5) e a tabela de saída (passo 3), com a designação de estados e as variáveis de estado (passo 4). No passo 6 devemos encontrar as funções de chaveamento. A técnica usual é montar os mapas de Karnaugh para a função de excitação (&lt;span class="math"&gt;\(T\)&lt;/span&gt;) e para a função de saída (&lt;span class="math"&gt;\(G\)&lt;/span&gt;), obtendo as equações como produto da aplicação do mapa. No entanto, qualquer técnica de síntese de circuitos combinatórios pode ser utilizada.&lt;/p&gt;
&lt;p&gt;Com as equações prontas, basta desenhar os blocos combinatórios (&lt;span class="math"&gt;\(T\)&lt;/span&gt; e &lt;span class="math"&gt;\(G\)&lt;/span&gt;), posteriormente ligando-os aos elementos de memória e obtendo-se o circuito final, o que é feito no passo 7.&lt;/p&gt;
&lt;h2&gt;Análise&lt;/h2&gt;
&lt;p&gt;A análise de uma máquina de estados finita em sistemas digitais é exatamente o contrário da síntese.&lt;/p&gt;
&lt;p&gt;Parte-se de um diagrama lógico (passo 7 reverso), onde deve-se identificar o elemento de memória (&lt;span class="math"&gt;\(S\)&lt;/span&gt;). É comum o elemento de memória ser composto por um ou mais &lt;em&gt;flip-flops&lt;/em&gt;, então não é difícil encontrá-los no circuito.&lt;/p&gt;
&lt;p&gt;Identificado o elemento de memória, segue-se a identificação das funções de excitação e de saída (passo 6 reverso). Isso pode ser feito usando uma técnica de análise de circuitos combinatórios, partindo da saída do elemento de memória em direção ao que se pretende identificar (e.g. se você está identificando a função de saída, aplique uma técnica de análise da saída do elemento de memória em direção a saída da máquina de estados). É útil ter em mente o modelo clássico de máquinas de estado pois, identificado o elemento de memória, o que sobrou deve ser combinatório e faz parte de uma das funções de excitação ou saída. É muito comum usar cores, circular ou marcar as portas lógicas para separá-las de acordo com a função conforme se faz a análise. Neste ponto da análise já é possível identificar se a máquina segue o modelo de Moore ou de Mealy. Neste passo deve-se também inferir as variáveis de estado (no caso dos &lt;em&gt;flip-flops&lt;/em&gt; as variáveis de estado coincidem com a saída dos mesmos).&lt;/p&gt;
&lt;p&gt;Obtidas as equações &lt;span class="math"&gt;\(T\)&lt;/span&gt; e &lt;span class="math"&gt;\(G\)&lt;/span&gt;, parte-se para as tabelas. A tabela de excitação pode ser obtida exercitando todas as combinações possíveis das variáveis de estado e das entradas (passo 5 reverso). Para cada valor, exercita-se a função de excitação (&lt;span class="math"&gt;\(T\)&lt;/span&gt;) e obtém-se o valor que será aplicado às entradas do elemento de memória (&lt;span class="math"&gt;\(S\)&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;Com a tabela de excitação e conhecendo-se as características do elemento de memória, pode-se atribuir nomes aos estados e construir a tabela de transição de estados (passo 4 reverso). É difícil atribuir nomes significativos para o estado neste momento, então muitos projetistas optam por atribuir nomes alfanuméricos (e.g. A, B, C1, C2, etc).&lt;/p&gt;
&lt;p&gt;Não faz sentido reverter as minimizações, tanto para os métodos de síntese combinatória quanto para as tabelas, portanto das equações montamos diretamente as tabelas, e delas extrairemos diretamente o restante.&lt;/p&gt;
&lt;p&gt;Para completar as tabelas (passo 3 reverso), obtemos a tabela de saída a partir da função de saída (encontrada no passo 6 reverso) da mesma maneira que encontramos a função de excitação: exercitando todos os valores possíveis para as variáveis de estado e para a entrada (a entrada só faz parte da função de saída se a máquina seguir o modelo de Mealy).&lt;/p&gt;
&lt;p&gt;Com as tabelas, é possível montar um diagrama de transição de estados. O diagrama pode ser inferido diretamente das tabelas (passo 2 reverso).&lt;/p&gt;
&lt;p&gt;O passo 1 é o único críptico na análise de máquinas de estado finitas. A razão disso é que o diagrama pode ser considerado a expressão de uma solução para um problema. Extrair o problema de uma solução é uma tarefa subjetiva. Informações extras sobre a aplicação da máquina, o local onde ela funciona, interfaces e até mesmo observar os sistemas ao redor da máquina de estados podem ajudar, porém não há uma técnica para este passo. Em alguns casos pode-se tentar mapear a máquina de estados para uma estrutura formal (e.g. expressões regulares), mas isso pouco ajuda quando não se conhece nem mesmo a natureza do problema que a máquina resolve.&lt;/p&gt;
&lt;h1&gt;Exemplo&lt;/h1&gt;
&lt;p&gt;Este é um exemplo clássico de uma máquina de estados simples, mas que todos reconhecem: o semáforo. Projete o circuito para uma máquina de estados que opere um semáforo de três fases: verde, amarela e vermelha. A entrada é &lt;span class="math"&gt;\(m\)&lt;/span&gt;, proveniente de um temporizador, que caso alta na fase verde causa uma mudança para a fase a amarela e caso alta na fase vermelha causa uma mudança para a fase verde. A mudança da fase amarela para a vermelha é independente da entrada. A saída da máquina de estados é dada por dois bits, &lt;span class="math"&gt;\(c_1c_0\)&lt;/span&gt;, que indicam qual cor está acesa: 10 verde, 11 amarelo e 01 vermelho.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Passo 1:&lt;/strong&gt; Variáveis de entrada: somente &lt;span class="math"&gt;\(m\)&lt;/span&gt; de 1 bit. Variáveis de saída: &lt;span class="math"&gt;\(c_1c_0\)&lt;/span&gt; de 2 bits, 10 verde, 11 amarelo e 01 vermelho (não foi especificado o que acontece em 00). O semáforo trabalha de forma circular acendendo as cores vermelho, amarelo e verde, em sequência repetitiva. O tempo que a máquina permanece na cor amarela é dado pelo período do &lt;em&gt;clock&lt;/em&gt;, pois não há condição para a transição. Já o tempo que a máquina permanece no vermelho e no verde é indicado pelo sinal do temporizador, representado pela entrada &lt;span class="math"&gt;\(m\)&lt;/span&gt;. Quando a entrada for alta (&lt;span class="math"&gt;\(m=1\)&lt;/span&gt;), deve-se trocar de estado na próxima borda do &lt;em&gt;clock&lt;/em&gt;. Convencionaremos o &lt;em&gt;reset&lt;/em&gt; assíncrono ativo baixo e o elemento de memória sensível a borda de subida do &lt;em&gt;clock&lt;/em&gt;. Escolheremos um modelo de Moore, sem nenhuma vantagem ou desvantagem explícita.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/semaforo.png' width="35%" align="right" style="padding-left:5%" /&gt;
&lt;strong&gt;Passo 2:&lt;/strong&gt; A descrição funcional foi feita durante a análise do problema no passo 1. O diagrama de transição de estados pode ser visto na figura ao lado. Note que já demos os nomes para os estados de acordo com a cor: VM vermelha, VD verde e AM amarela. A entrada de 1 bit foi especificada nas transições e a saída de 2 bits na parte inferior do estado, de acordo com o identificado no passo 1.
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Passo 3:&lt;/strong&gt; Já temos o diagrama de transição de estados, então podemos montar as tabelas.&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-88nc{font-weight:bold;border-color:inherit;text-align:center}
.tg .tg-kiyi{font-weight:bold;border-color:inherit;text-align:left}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
&lt;/style&gt;

&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-88nc" rowspan="2"&gt;Estado Atual&lt;/th&gt;
    &lt;th class="tg-88nc" colspan="2"&gt;Próximo Estado&lt;/th&gt;
    &lt;th class="tg-kiyi" rowspan="2"&gt;Saída&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-88nc"&gt;m=0&lt;/td&gt;
    &lt;td class="tg-88nc"&gt;m=1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;VM&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VM&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VD&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;01&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;AM&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VM&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VM&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;VD&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VD&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;AM&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;10&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Note que as tabelas de próximo estado e de saída estão juntas na mesma tabela. A coluna &lt;strong&gt;Estado Atual&lt;/strong&gt; mostra o estado em que a máquina se encontra, e a coluna &lt;strong&gt;Saída&lt;/strong&gt; mostra a saída para aquele estado. A coluna &lt;strong&gt;Próximo Estado&lt;/strong&gt; contém as transições, ou seja, para qual estado a máquina irá no próximo ciclo de &lt;em&gt;clock&lt;/em&gt; caso a entrada &lt;span class="math"&gt;\(m\)&lt;/span&gt; seja 0 ou 1. Esta tabela é pequena, portanto basta uma rápida análise para perceber que não há reduções possíveis.&lt;/p&gt;
&lt;p&gt;Dica: é muito comum representar as duas tabelas em uma só para economizar espaço, pois a coluna de estado atual é idêntica nas duas. Note também que a ordem dos estados já foi colocada de forma a facilitar a utilização do método de minimização gráfica por mapa de Karnaugh.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Passo 4:&lt;/strong&gt; Para nossa implementação, usaremos &lt;em&gt;flip-flops&lt;/em&gt; tipo D sensíveis a borda de subida do &lt;em&gt;clock&lt;/em&gt;. Temos 3 estados, portanto usaremos &lt;span class="math"&gt;\(\lceil log_23\rceil =2\)&lt;/span&gt; &lt;em&gt;flip-flops&lt;/em&gt;. Com dois &lt;em&gt;flip-flops&lt;/em&gt;, podemos representar até &lt;span class="math"&gt;\(2^2=4\)&lt;/span&gt; estados possíveis, portanto há um estado sobrando. A aplicação é crítica pois caso a máquina atinja o estado AM ou VD erroneamente, poderá causar um acidente. Neste sentido, optamos por forçar o estado extra para produzir uma saída vermelha (10) e ir para o estado VM no próximo ciclo, independente da entrada. A designação de estados será: 00 para o estado extra, que chamaremos de EX; 01 para o estado VM, 11 para o estado AM, e 10 para o estado VD. Note que esta designação condiz com a saída para os estados válidos, o que foi proposital para minimizar as funções de saída.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Passo 5:&lt;/strong&gt; A tabela de excitação é exatamente a tabela de próximo estado, porém com os estados substituídos pela sua designação pois usamos &lt;em&gt;flip-flops&lt;/em&gt; tipo D, que copiam a entrada para a saída. Caso o elemento de memória fosse diferente, nesta tabela deveríamos colocar as entradas do elemento de memória adequadas para que o próximo estado seja o ta tabela de transição de estados. Também copiamos a tabela de saída para incluir a saída no caso do estado extra.&lt;/p&gt;
&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-88nc" rowspan="2"&gt;Estado Atual&lt;/th&gt;
    &lt;th class="tg-88nc" colspan="2"&gt;Próximo Estado&lt;/th&gt;
    &lt;th class="tg-kiyi" rowspan="2"&gt;Saída&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-88nc"&gt;m=0&lt;/td&gt;
    &lt;td class="tg-88nc"&gt;m=1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;EX(00)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VM(01)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VM(01)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;01&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;VM(01)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VM(01)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VD(10)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;01&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;AM(11)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VD(01)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VD(01)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;VD(10)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;VD(10)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;AM(11)&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;10&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Mantivemos os nomes dos estados e colocamos a designação entre parênteses para facilitar a leitura (esta prática é comum quando utiliza-se &lt;em&gt;flip-flop&lt;/em&gt; tipo D). Os números entre parênteses representam as variáveis de estado, que chamaremos de &lt;span class="math"&gt;\(q_1q_0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Passo 6:&lt;/strong&gt; Neste passo, devemos encontrar as funções de excitação e de saída. A construção e solução do mapa de Karnaugh foi omitida pois não é assunto deste artigo, porém ambas as equações foram encontradas usando este método. Note que, como usamos &lt;em&gt;flip-flops&lt;/em&gt; tipo D, &lt;span class="math"&gt;\(d_1=q_1^{t+1}\)&lt;/span&gt; e &lt;span class="math"&gt;\(d_0=q_0^{t+1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="math"&gt;$$
q_1^{t+1}=q_1.\overline{q_0}+\overline{q_1}.q_0.m\\
q_0^{t+1}=\overline{q_1}.\overline{q_0}+q_0.\overline{m}+q_1.m\\
\quad\\
c_1=q_1\\
c_0=\overline{q_1}+q_0
$$&lt;/div&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/fsmSemaforo.png' width="35%" align="right" style="padding-left:5%" /&gt;
&lt;strong&gt;Passo 7:&lt;/strong&gt; Com as equações em mãos, basta montar o circuito correspondente. Começamos colocando os elementos de memória na parte central (dois &lt;em&gt;flip-flops&lt;/em&gt;) tipo D e nomeamos como &lt;em&gt;q1&lt;/em&gt; e &lt;em&gt;q0&lt;/em&gt;. As saídas dos &lt;em&gt;flip-flops&lt;/em&gt; correspondem às variáveis de estado homônimas, e as entradas devem ser as saídas das funções de próximo estado. Após colocarmos os elementos de memória, continuamos seguindo as convenções e colocamos a esquerda o circuito combinatório correspondente à função de transição de estados e a direita o correspondente a de saída.
Ainda no circuito vemos a entrada de &lt;em&gt;clock&lt;/em&gt; e de &lt;em&gt;reset&lt;/em&gt;, um botão que emula o sinal vindo do temporizador e uma saída RGB que corresponde ao semáforo.&lt;/p&gt;
&lt;p&gt;Para baixar este circuito no formato do LogiSim &lt;a href="https://balbertini.github.io/extra/sd/fsmSemaforo.circ"&gt;clique aqui&lt;/a&gt;.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="sistemas digitais"></category><category term="fsm"></category><category term="simplificação"></category></entry><entry><title>Simplificação de FSM</title><link href="https://balbertini.github.io/fsmstatereduction-pt_BR.html" rel="alternate"></link><published>2018-09-25T17:13:05-03:00</published><updated>2019-02-26T17:24:30-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-25:/fsmstatereduction-pt_BR.html</id><summary type="html">&lt;p&gt;Como fazer simplificação de estados em máquinas de estados finitas.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A máquina de estados finita em sistemas digitais, quando realizada na forma de um circuito digital, utiliza recursos computacionais (e.g. &lt;em&gt;flip-flops&lt;/em&gt;, memórias, portas lógicas, etc.) que são caros do ponto de vista de área e consumo de energia, principalmente se a máquina possuir muitos estados. Por este motivo, é importante minimizar o número de estados da máquina para que, na implementação, utilizemos somente os recursos mínimos necessários para aquela máquina. Além disso, quando estamos projetando uma máquina de estados para resolver um problema, é mais confortável não pensar em otimizações mas sim na funcionalidade da máquina, para só depois pensar na otimização. De fato, a maioria dos projetistas comerciais não pensa na otimização quando estão modelando o problema pois isso nem sempre é possível (i.e. o projetista não tem visão da máquina toda mas sim da parte cabível a ele, a máquina é muito grande tornando impossível pensar em tudo, a máquina é particionada, etc).&lt;/p&gt;
&lt;p&gt;Na prática, com os sintetizadores modernos, você pode especificar sua máquina usando a linguagem de descrição de hardware de sua preferência e deixar o sintetizador otimizá-la para você. Os resultados da otimização automática são bons quando comparados aos métodos manuais [1,2]. Contudo, é necessário conhecer o mínimo do funcionamento dos algoritmos de minimização pois, quando for descrever sua máquina, você conhecerá ao menos o básico do que acontecerá quando sintetizá-la. Neste artigo, explicarei os métodos de minimização por identificação direta na tabela de transição de estados e por tabela de implicação. Em ambos os casos, o objetivo principal é encontrar estados equivalentes, ou seja, que &lt;strong&gt;para a mesma entrada, produzem a mesma saída e transicionam para os mesmos estados.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Minimização através da tabela de transição&lt;/h2&gt;
&lt;p&gt;Em muitos casos, é fácil identificar os estados equivalentes na tabela de transição de estados, por isso este método também é chamado de &lt;strong&gt;observação direta&lt;/strong&gt; ou &lt;strong&gt;casamento de linhas&lt;/strong&gt;. O algoritmo é simples:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Elimine todos os estados inalcançáveis (estados onde não chega nenhuma aresta partindo de outro estado alcançável).&lt;/li&gt;
&lt;li&gt;Identifique dois estados A e B que, para a mesma entrada, produzam exatamente a mesma saída e realizem a mesma transição (transicionem para o mesmo estado).&lt;/li&gt;
&lt;li&gt;Elimine um dos estados (e.g. B) apagando a linha correspondente a este estado e substitua todas as ocorrências de B por A (i.e. todos as transições para B agora devem apontar para A).&lt;/li&gt;
&lt;li&gt;Repita até que nenhum par de estados atenda (2).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;Uma forma muito comum de projetar máquinas de estados é modelando-a como árvore, onde cada ramificação é uma tomada de decisão. Tomemos a máquina abstrata a seguir que foi montada partindo de uma árvore binária canônica e modificada para reconhecer as sequencias 0011 e 1001:&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;Em vermelho está destacado o caminho que esta máquina irá seguir para reconhecer as duas sequencias. Note que esta é uma máquina de Mealy e não leva em consideração nenhuma sobreposição entre as sequencias detectadas, ou seja, ela só funciona para entradas de 4 bits agrupados a partir do &lt;em&gt;reset&lt;/em&gt; (e.g. detecta duas vezes se a entrada for 0011 1001 mas não detecta a segunda vez se a entrada for 0011 001).&lt;/p&gt;
&lt;p&gt;A tabela de transição de estados fica como na Tabela 1 a seguir.&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0px;margin-right:10px;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-3r9o{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-4m7p{background-color:#9aff99;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-uuae{background-color:#67fd9a;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-fcno{background-color:#fcff2f;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-bolj{background-color:#ffccc9;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-mfhl{background-color:#ffffc7;border-color:inherit;text-align:center;vertical-align:top}
&lt;/style&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela 1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S7/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S9/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S10/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S12/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S6&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S13/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S14/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S7&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S8&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S9&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S10&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S11&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S12&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S13&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S14&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S4&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S6&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S8&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S11&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 3&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sc&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A coluna &lt;strong&gt;E.A.&lt;/strong&gt; mostra o estado atual, e a coluna &lt;strong&gt;P.E.&lt;/strong&gt; o próximo estado. Esta última é bipartida para as entradas igual a &lt;strong&gt;0&lt;/strong&gt; e igual a &lt;strong&gt;1&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A Tabela 1 possui todas as transições da árvore como vista na figura. Esta máquina não tem nenhum estado inalcançável, então não há o que eliminar no passo 1.&lt;/p&gt;
&lt;p&gt;No passo 2, devemos procurar as equivalências. É fácil perceber que há estados que produzem exatamente o mesmo resultado (transição e saída) para determinada entrada. Tomemos por exemplo os estados S7, S9, S10, S12, S13 e S14: todos transicionam para S0 e produzem saída 0 para qualquer entrada, portanto são equivalentes. Podemos reduzir a tabela substituindo todos estes estados por um estado Sa, o que podemos ver na Tabela 2, destacado em verde.&lt;/p&gt;
&lt;p&gt;Se fizermos a busca novamente, os estados S4 e S6 agora são equivalentes pois ambos transicionam para Sa e produzem saída 0, independententemente da entrada. Criamos o estado Sb, em vermelho, para substituir estes estados. Similarmente os estados S8 e S11 são equivalentes, mas note que eles tem saídas diferentes para entradas diferentes. Para este conjunto de estados, criamos Sc, em amarelo. Não há mais estados equivalentes e o resultado final pode ser visto na Tabela 3.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="35%" align="right" style="padding-left:5%" /&gt;
&lt;br/&gt;
O diagrama de transição de estados minimizado pode ser visto na figura ao lado. Os estados S7, S9, S10, S12, S13 e S14 são representados pelo Sa, S4 e S6 pelo Sb e S8 e S11 pelo Sc.&lt;/p&gt;
&lt;p&gt;O método de análise da tabela de transição de estados se baseia na busca exaustiva por estados equivalentes. É fácil perceber que, conforme a tabela cresce, ficará mais difícil visualizar os estados equivalentes. Além disso, o método não garante a menor quantidade de estados possível pois é baseado em estados e não em grupos de estados (veja o primeiro exemplo da próxima seção).&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;O método de minimização por tabela de implicação&lt;/h2&gt;
&lt;p&gt;Nem sempre é tão fácil perceber a equivalência de estados através da tabela de transição de estados, especialmente para máquinas grandes ou com muitas entradas. No entanto, os projetistas desenvolveram um método chamado de tabela de implicação. Este método é equivalente à análise através da tabela de transição de estados, porém é algorítmico e está organizado em forma de uma matriz, o que minimiza erros por parte do projetista. Além disso, apesar de ambos os métodos serem exaustivos, há uma diferença primordial: enquanto o método de análise da tabela de transição de estados procura exaustivamente estados equivalentes, o método da tabela de implicação procura exaustivamente os estados que &lt;strong&gt;não são equivalentes&lt;/strong&gt;. Parte-se da premissa de que todos os estados são equivalentes entre si e, a cada iteração, elimina-se os estados que não podem ser equivalentes. Os estados que sobrarem são equivalentes.&lt;/p&gt;
&lt;p&gt;Há dois momentos no método da tabela de implicação: a construção da tabela e a análise.&lt;/p&gt;
&lt;h3&gt;Construção da matriz (tabela)&lt;/h3&gt;
&lt;p&gt;A matriz pode ser construída como uma matriz &lt;span class="math"&gt;\(n\)&lt;/span&gt; por &lt;span class="math"&gt;\(n\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(n\)&lt;/span&gt; é o número de estados (se você começar no &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, o último estado será &lt;span class="math"&gt;\(S_{n-1}\)&lt;/span&gt;). Cada linha &lt;span class="math"&gt;\(i\)&lt;/span&gt; da matriz representa um estado e cada coluna &lt;span class="math"&gt;\(j\)&lt;/span&gt; também.&lt;/p&gt;
&lt;p&gt;Não faz sentido analisar a equivalência de um estado com ele mesmo, pois um estado sempre é equivalente a ele mesmo. Por este motivo, eliminamos a diagonal da matriz, onde &lt;span class="math"&gt;\(i=j\)&lt;/span&gt;. As metades diagonais superiores e inferiores significam a mesma coisa pois se uma célula &lt;span class="math"&gt;\(X_{ij}\)&lt;/span&gt; mostra equivalência entre o estado &lt;span class="math"&gt;\(S_i\)&lt;/span&gt; e o estado &lt;span class="math"&gt;\(S_j\)&lt;/span&gt;, a célula &lt;span class="math"&gt;\(X_{ji}\)&lt;/span&gt; também deve mostrar a mesma equivalência. Por este motivo, eliminamos também uma das metades diagonais. Por convenção, elimina-se a diagonal superior, mas o resultado é o mesmo se você eliminar a metade diagonal inferior.&lt;/p&gt;
&lt;p&gt;Quando estiver confortável com a construção da matriz, você poderá desenhá-la já sem a diagonal e sem a metade diagonal superior. A esse desenho contendo somente a metade diagonal inferior da tabela, chamamos de &lt;strong&gt;tabela de implicação&lt;/strong&gt;. Na figura abaixo mostramos a matriz inteira, a matriz destacando a linha diagonal (vermelha) e a metade diagonal superior (laranja), e finalmente a tabela de implicação.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Construção da tabela de implicação." src="https://balbertini.github.io/images/sd/sdfsmoptconsttab.png"&gt;&lt;/p&gt;
&lt;p&gt;Após obter a tabela de implicação, devemos preencher as células. Cada célula terá &lt;span class="math"&gt;\(2^b\)&lt;/span&gt; linhas, onde &lt;span class="math"&gt;\(b\)&lt;/span&gt; é o número de bits da entrada. E.g. se a entrada for de 1 bit, cada célula tem 2 linhas; se a entrada for de 2 bits, cada célula tem 4 linhas. Cada linha da entrada corresponde às transições daqueles estados para aquela entrada.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptconstcel.png' width="45%" align="right" style="padding-left:5%" /&gt;
Na figura podemos ver o exemplo do preenchimento para duas células, ambas na linha do S3 e coluna do S4. Para simplificar o preenchimento, usamos somente o número do estado, mas você pode escrever o nome completo do estado (especialmente útil se os nomes dos estados não forem numerados).&lt;/p&gt;
&lt;p&gt;Na célula na esquerda na figura, a entrada tem 1 bit, portanto temos duas linhas, uma para a entrada 0 e outra para a entrada 1. Nesta célula, a máquina é de Mealy com saída de 1 bit, que pode ser vista representada nas transições.&lt;/p&gt;
&lt;p&gt;Já na célula a direita na figura, a entrada tem 2 bits, portanto temos 4 linhas para as entradas 00, 01, 10 e 11. A máquina representada é de Moore e também tem um bit só de saída, que nesse caso é representado no estado e não na transição.&lt;/p&gt;
&lt;p&gt;Os números em cada linha correspondem a transição que o estado fará para cada entrada (e à saída referente àquela transição no caso de uma máquina de Mealy). No exemplo a esquerda na figura, podemos assumir que, para uma determinada entrada e estando em S3 ou em S4, a máquina transicionará para o estado S0/0 ou S1/0 (note que em ambas as transições a saída é 0). Na mesma situação mas para a outra entrada, a máquina transicionará para o estado S2/0 ou S3/1. Mas como eu sei qual entrada? Não é preciso saber para qual entrada, apenas que as transições da mesma linha, separadas por &lt;code&gt;-&lt;/code&gt;, são para a mesma entrada. De fato, alguns projetistas preferem ordenar as transições em ordem crescente para facilitar a busca por estados equivalentes. E.g. (linha superior / linha inferior) 3-2/1-2 é o mesmo que 1-2/2-3, mas ordenado. Fica a seu critério decidir a melhor forma de organizar sua tabela de implicação, mas lembre-se que cada linha corresponde a exatamente dois estados separados por &lt;code&gt;-&lt;/code&gt;, para os quais a máquina de estados transicionará quando houver a mesma entrada.&lt;/p&gt;
&lt;p&gt;É de praxe também assinalar os estados que produzem saídas diferentes, pois eles não podem ser equivalentes. Neste caso, coloque uma &lt;code&gt;/&lt;/code&gt; no índice de coluna e linha (caso a máquina for de Moore) ou na transição dentro da célula (caso a máquina for de Mealy). Isto ficará mais claro no exemplo.&lt;/p&gt;
&lt;h2&gt;Procurando estados equivalentes&lt;/h2&gt;
&lt;p&gt;Com a tabela de implicação construída, devemos procurar os estados equivalentes. Isto é feito de forma exaustiva, analisando todas as células da tabela.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Risque todas as transições que vão para o mesmo estado e produzem a mesma saída (tipo s-s), pois elas são naturalmente equivalentes. E.g. se você tem uma transição 0-0, risque-a pois não é preciso analisá-la.&lt;/li&gt;
&lt;li&gt;Elimine as células com estados (Moore) ou transições (Mealy) que produzem saídas diferentes. Estes estados nunca poderão ser equivalentes.&lt;/li&gt;
&lt;li&gt;Analise uma célula qualquer que não tenha todas as transições riscadas e que não tenha sido eliminada anteriormente. Esta célula é uma candidata a equivalência.&lt;ul&gt;
&lt;li&gt;Olhe todas as linhas da célula que não foram riscadas no passo (1). Para cada uma, analise a célula alvo. E.g. se a transição marca 1-2, você deve analisar a célula correspondente aos estados S1 e S2.&lt;/li&gt;
&lt;li&gt;Se a célula alvo estiver eliminada, você deve eliminar esta célula também.&lt;/li&gt;
&lt;li&gt;Se você analisou todas as linhas e não eliminou a célula, não faça nada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Repita o (3) até que todas as células tenham sido analisadas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note que este processo é exaustivo. Para não correr o risco de analisar a mesma célula várias vezes, aconselho começar pela célula mais a direita inferior e depois passar para a segunda mais a direita inferior, e assim por diante. Não faz diferença a ordem em que você analisa as células, mas você deve se organizar para não repetir células.&lt;/p&gt;
&lt;p&gt;Durante a análise, pode acontecer de você eliminar uma linha inteira ou uma coluna inteira. Isso significa que o estado daquela linha ou coluna não é equivalente a nenhum outro estado, portanto você deve eliminar todas as células que tem alguma linha referenciando aquele estado. E.g. se você eliminou a linha toda do S3, você deve eliminar todas as células que possuam ao menos um 3 em alguma linha (x-3 ou 3-x).&lt;/p&gt;
&lt;p&gt;Você não precisa analisar células onde todas as linhas tenham sido riscadas no passo 1. Se você riscar todas as linhas de uma célula, os estados desta célula (linha-coluna) são automaticamente equivalentes. Você não precisa tomar nenhuma ação em relação a isso, apenas pule a análise da célula.&lt;/p&gt;
&lt;p&gt;Quando você terminar este processo, as células que você não eliminou representam &lt;strong&gt;classes de equivalência&lt;/strong&gt;. Uma classe de equivalência é um grupo de estados que são equivalentes e, consequentemente, podem ser representados por um único estado. E.g. se a célula da linha 3 coluna 4 não foi eliminada, os estados S3 e S4 são equivalentes.&lt;/p&gt;
&lt;h2&gt;Exemplo 1/3 - Moore simples&lt;/h2&gt;
&lt;p&gt;Este exemplo é de uma máquina de Moore que detecta uma paridade ímpar considerando todas as entradas que já passaram pela máquina. O diagrama e a tabela de transição de estados podem ser vistos abaixo:&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela E1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;A/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;A&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;B/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;C/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diag.png' width="13%" align="left" style="padding-left:5%; padding-right:5%"/&gt;
Tente minimizar esta máquina usando o método de análise da tabela de transição. É possível encontrar algum estado equivalente? Perceba que os estados A e C são equivalentes, mas não é possível perceber isto apenas com a tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1a.png' width="55%" align="right" style="padding-left:5%"/&gt;
Vamos construir a tabela de implicação para verificar. Na figura ao lado, podemos ver: (esquerda) a tabela de implicação construída e com os estados (note que é uma máquina de Moore, então as saídas são representadas nos estados); (meio) a tabela de implicação com as linhas de acordo com a tabela de transição de estados; e (direita) a versão com a linha B-B já riscada, pois para esta entrada, a máquina transiciona para o mesmo estado independententemente de qual estado esteja. Isto equivale à construção da tabela de implicação e à execução do primeiro passo do algoritmo.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1b.png' width="45%" align="left" style="padding-right:5%"/&gt;
No segundo passo eliminamos os estados que produzem saída diferentes, pois nunca poderão ser equivalentes. Isto pode ser visto à esquerda na figura ao lado (os estados eliminados foram destacados em cinza). Sobra a única célula a ser verificada, correspondente aos estados C/0-A/0. Esta célula tem uma linha riscada (que não precisa ser analisada) e uma linha que referencia A-C. A referência A-C aponta para a mesma célula que estamos analisando, a célula C/0-A/0. Como esta célula ainda não foi eliminada, nada resta a fazer e devemos continuar o algoritmo. Porém, não há mais células a serem analisadas, portanto o algoritmo terminou. Isso significa que a única célula que não foi eliminada será a nossa classe de equivalência, destacada em vermelho na tabela de implicação da figura.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diagmin.png' width="13%" align="left" style="padding-right:5%"/&gt;
A célula indica que a classe de equivalência contém somente dois estados, o C/0 e o A/0. Para finalizar, montamos um novo diagrama de transição de estados com um estado chamado AC/0, em vermelho, representando a classe de equivalência encontrada. As transições são transportadas dos estados da classe de equivalência e, obviamente, são esperadas que sejam as mesmas pois os estados são equivalentes. Esta máquina tem a mesma funcionalidade que a anterior, porém tem um estado a menos. Este tipo de minimização não é possível usando a análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 2/3 - Moore com entrada de 2 bits&lt;/h2&gt;
&lt;p&gt;A Tabela E2 é a tabela de transição de estados de uma máquina de Moore, com entrada de dois bits. Sua funcionalidade ou diagrama de transição de estados não importam neste momento, mas o diagrama equivalente pode ser visto na figura.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diag.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo podemos ver a tabela construída e com o passo 1 executado (esquerda) e após o passo 2 executado (direita). Note que, para minimizar o esforço em preencher a tabela e evitar poluí-la, eu eliminei o "S" e utilizei somente os índices dos estados.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2a.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2b.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo, podemos ver a tabela de implicação após o passo 3 executado a exaustão (esquerda) e com as classes de equivalência construídas (direita). Na tabela da esquerda, as linhas que provocaram a exclusão da tabela foram realçadas com um cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2c.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2d.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Pela tabela, podemos inferir que os estados S4 e S0 (Sa) são equivalentes entre si, assim como os estados S5 e S3 (Sb). A tabela de transição de estados minimizada e o diagrama de transição de estados minimizado podem ser vistos abaixo. A máquina original possuía 6 estados, o que exige 3 &lt;em&gt;flip-flops&lt;/em&gt; para sua implementação, mas a minimizada tem 4 estados, o que exige 2 &lt;em&gt;flip-flops&lt;/em&gt;, portanto economizamos um &lt;em&gt;flip-flop&lt;/em&gt; apenas minimizando a máquina.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2 min&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sa/1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sb/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diagmin.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 3/3 - Mealy com 15 estados&lt;/h2&gt;
&lt;p&gt;Suponha a mesma máquina de estados usada como exemplo no método de análise da tabela de transição de estados, mostrada na figura. Trata-se de uma máquina de Mealy que reconhece 0011 ou 1001 sem sobreposição.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;A máquina tem 15 estados, portanto temos uma matriz 15x15. A tabela de implicação, já com os valores das transições preenchidos e com as transições s-s riscadas, pode ser vista na figura abaixo. Note que esta é uma máquina de Mealy, então coloquei a saída na transição (e.g. nos estados S8 e S11, que são os que produzem saída, há transições na forma 0/1, indicando que esta transição produz saída 1). Isto corresponde à construção da tabela de implicação e à execução do passo 1 do algoritmo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 1" src="https://balbertini.github.io/images/sd/sdfsmoptex3a.png"&gt;&lt;/p&gt;
&lt;p&gt;No passo 2, devemos eliminar as transições que produzem saídas diferentes, ou seja, devemos eliminar todas as células que contém uma transição s-t onde a saída de s é diferente da saída de t. Exemplo: a célula S14-S11 possui a segunda linha como 0/1-0, o que significa que, apesar de irem para o mesmo estado, uma produz saída 1 (0/1) e outra produz saída 0 (0/0), portanto devemos eliminar esta célula toda. Isto pode ser visto na figura abaixo, onde todas as células eliminadas por este motivo foram identificadas com fundo cinza e a linha que foi o motivo da eliminação com cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 2" src="https://balbertini.github.io/images/sd/sdfsmoptex3b.png"&gt;&lt;/p&gt;
&lt;p&gt;O passo 2 eliminou os estados que trivialmente não são equivalentes. Podemos então começar o passo 3 analisando cada célula. Eu comecei pela célula mais a direita inferior e continuei analisando para a esquerda. A célula S14-S13 não precisa ser analisada pois tem todas as transições riscadas. Idem para a célula S14-S12. Já a célula S14-S11 foi eliminada anteriormente e também não precisa ser analisada.&lt;/p&gt;
&lt;p&gt;A primeira célula que realmente precisa ser analisada é a S14-S6. Nesta célula, a transição 13-0 aponta para a a célula S13-S0, e a transição 14-0 para a célula S14-S0. Estas células alvo ainda indicam equivalência, então não fiz nada na célula em análise (S14-S6). Idem para S14-S5 e S14-S4.&lt;/p&gt;
&lt;p&gt;Já na célula S14-S3, encontrei uma referência à S8-S0, que já foi eliminado em um passo anterior. Isso significa que eu devo eliminar esta célula. Nesse ponto, percebi que a linha do S8 estava inteira eliminada, então eliminei  todas as células que fazem referência a S8, ou seja, que tem transições 8/x-x/x ou x/x-8/x. O resultado pode ser visto na figura abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 3" src="https://balbertini.github.io/images/sd/sdfsmoptex3c.png"&gt;&lt;/p&gt;
&lt;p&gt;Se está lendo com cuidado, deve ter percebido que a eliminação que acabei de fazer eliminou o estado S3 inteiro. Isto significa que podemos eliminar todas as células que contém transições que referenciam o S3, pois ele não pode ser equivalente a nenhum outro estado. Se você continuar o algoritmo, terminará com a tabela de implicação abaixo, onde as células eliminadas estão em cinza.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 eliminadas" src="https://balbertini.github.io/images/sd/sdfsmoptex3d.png"&gt;&lt;/p&gt;
&lt;p&gt;A única célula que ainda precisa de análise é a célula S6-S4. Esta célula referencia os estados S9-S13 na primeira linha e S10-S14 na segunda linha. Ambas as células S9-S13 e S10-S14 não foram eliminadas pois possuem todas as suas linhas riscadas, então não devemos fazer nada nesta célula. Como não há mais células a serem analisadas, o algoritmo terminou.&lt;/p&gt;
&lt;p&gt;Com o algoritmo finalizado, podemos inferir os estados equivalentes observando as células que não foram eliminadas. A célula S6-S4 indica que estes dois estados são equivalentes. Similarmente, a coluna S7 indica que os estados S7, S9, S10, S12, S13 e S14 são todos equivalentes. Isso pode ser corroborado pelas colunas do S9, S10, S11, S12 e S13, que indicam também esta equivalência. Ainda, a célula S11-S8 indica que estes dois estados são equivalentes entre si (note que ambos produzem saída 1).&lt;/p&gt;
&lt;p&gt;Para facilitar a visualização, a figura abaixo traz as classes de equivalência coloridas. Para a mesma cor, os estados são equivalentes.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 fim" src="https://balbertini.github.io/images/sd/sdfsmoptex3e.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="45%" align="right" style="padding-left:5%" /&gt;
Por último, devemos reconstruir o diagrama de transição de estados. Para cada classe de equivalência, criamos um estado novo. As transições e as saídas podem ser copiadas de qualquer um dos estados da classe, pois eles são equivalentes (para as mesmas entradas, produzem a mesma saída e transicionam para o mesmo estado). Note que este método agrupa os estados em classes, então a transição do Sb (que é composto por S4 e S6) que vai para o S9, por exemplo, deve ir para o estado Sa (que é composto por S7, S9, S10, S12, S13 e S14) pois esta é a classe de equivalência que contém o S9. O diagrama desta tabela é idêntico ao obtido usando o método de análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h1&gt;Referências&lt;/h1&gt;
&lt;p&gt;&lt;p/&gt;
[1] DE VRIES, A. Finite automata: Behavior and synthesis. Elsevier, 2014.&lt;br&gt;
[2] KAM, Timothy et al. Synthesis of finite state machines: functional optimization. Springer Science &amp;amp;
Business Media, 2013.&lt;/p&gt;
&lt;p&gt;Algumas partes dos exemplos foram adaptados de apresentações do &lt;a href="http://www-inst.eecs.berkeley.edu/~cs150/sp00/classnotes/katz-ch9-mod.pdf"&gt;Prof. Randy H. Katz&lt;/a&gt; e da disciplina &lt;a href="https://courses.cs.washington.edu/courses/cse370/09wi/LectureSlides/22-Minimization.pdf"&gt;CSE370, Lecture 22&lt;/a&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="sistemas digitais"></category><category term="fsm"></category><category term="simplificação"></category><category term="otimização"></category></entry></feed>