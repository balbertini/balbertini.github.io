<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>B.Albertini's site - sistemas digitais</title><link href="https://balbertini.github.io/" rel="alternate"></link><link href="https://balbertini.github.io/feeds/sistemas-digitais.atom.xml" rel="self"></link><id>https://balbertini.github.io/</id><updated>2018-10-12T12:28:00-03:00</updated><entry><title>Exercício: Associação de Contadores</title><link href="https://balbertini.github.io/er0002-pt_BR.html" rel="alternate"></link><published>2018-10-12T12:28:00-03:00</published><updated>2018-10-12T12:28:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-12:/er0002-pt_BR.html</id><summary type="html">&lt;p&gt;Exercício resolvido de sistemas digitais: associação de contadores.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Assunto: Associação de contadores&lt;/p&gt;
&lt;h2&gt;Enunciado&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20181012_associacaoContadores.png' align="left" width="50%" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;p&gt;Mostra-se no circuito ao lado uma associação de contadores. Sabe-se que o &lt;em&gt;load&lt;/em&gt; é síncrono e o &lt;em&gt;reset&lt;/em&gt; assíncrono.&lt;br&gt;
Pede-se: (i) o módulo da contagem e (ii) as formas de onda nos pontos A e B.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Solução&lt;/h2&gt;
&lt;p&gt;Os contadores são de módulo 16, ou seja, tem capacidade de contar de 0000 (0) a 1111 (15). O contador A está em um arranjo onde ele se auto-carrega de 0101 (5) quando seu valor atingir 1001 (9), formando um contador de 5 a 9, ou seja, módulo 5. O contador B está em um arranjo onde ele se auto-reseta quando sua contagem for 0011 (3). Contudo, como o &lt;em&gt;reset&lt;/em&gt; é assíncrono, assim que este valor é atingido o contador reseta-se de imediato, portanto os valores de contagem são de 0000 (0) a 0010 (2), ou seja, módulo 3.&lt;/p&gt;
&lt;p&gt;Os contadores ainda estão em cascata, onde o valor de carga do contador A (1001) é usado como &lt;em&gt;enable&lt;/em&gt; para o contador B. Nesse arranjo em cascata, mesmo que o &lt;em&gt;clock&lt;/em&gt; seja comum a ambos, podemos dizer que o contador B conta uma vez para cada ciclo completo de contagem do contador A.&lt;/p&gt;
&lt;p&gt;O módulo da contagem total é 15. O ciclo de contagem em regime será: 0101 0000, 0110 0000, 0111 0000, 1000 0000, 1001 0000, 0101 0001, 0110 0001, 0111 0001, 1000 0001, 1001 0001, 0101 0010, 0110 0010, 0111 0010, 1000 0010, 1001 0010. As formas de onda em A e em B podem ser descritas como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A: é alto quando o contador A estiver na contagem máxima, ou seja, a cada 4 pulsos de &lt;em&gt;clock&lt;/em&gt;, com duração de 1 pulso de &lt;em&gt;clock&lt;/em&gt;. Período do sinal: 5 pulsos de &lt;em&gt;clock&lt;/em&gt;, &lt;em&gt;Duty-cycle&lt;/em&gt;: 20%.&lt;/li&gt;
&lt;li&gt;B: é alto quando o contador B estiver na contagem máxima, ou seja, a cada 10 pulsos de &lt;em&gt;clock&lt;/em&gt;, com duração de 5 pulsos de &lt;em&gt;clock&lt;/em&gt;. Período do sinal: 15 pulsos de &lt;em&gt;clock&lt;/em&gt;. &lt;em&gt;Duty-cycle&lt;/em&gt;: 33%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A figura abaixo mostra os dois sinais, e também as saídas dos contadores. Repare que o primeiro ciclo é diferente pois o contador A começa em zero e não com o valor de carga.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Forma de onda do Exercício" src="/images/sd/er/er0002_onda.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://balbertini.github.io/extra/sd/er/er0002.zip"&gt;Download da descrição em VHDL&lt;/a&gt;&lt;br&gt;
&lt;a href="https://balbertini.github.io/extra/sd/er/20181012_associacaoContadores.circ"&gt;Download do circuito no LogiSim&lt;/a&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;</content><category term="sistemas digitais"></category><category term="exercícios resolvidos"></category><category term="associação de contadores"></category></entry><entry><title>Exercício: Análise de Circuitos Realimentados</title><link href="https://balbertini.github.io/er0001-pt_BR.html" rel="alternate"></link><published>2018-10-09T14:38:00-03:00</published><updated>2018-10-10T09:40:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-10-09:/er0001-pt_BR.html</id><summary type="html">&lt;p&gt;Exercício resolvido de sistemas digitais: análise de circuitos realimentados.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Assunto: Análise de circuitos realimentados&lt;/p&gt;
&lt;h2&gt;Enunciado&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTnoReset.png' align="left" width="35%" style="padding-right:5%" /&gt;&lt;/p&gt;
&lt;p&gt;O circuito ao lado é um circuito digital sequencial realimentado, com entradas T e C, e saída Q. Analise-o por completo, apresentando:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As equações de excitação e saída;&lt;/li&gt;
&lt;li&gt;A tabela de transição de estados e saída;&lt;/li&gt;
&lt;li&gt;Análise de corridas (e classificação se houve);&lt;/li&gt;
&lt;li&gt;A tabela de fluxo e saída;&lt;/li&gt;
&lt;li&gt;O diagrama de transição de estados da máquina.&lt;/li&gt;
&lt;/ul&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Solução&lt;/h2&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/20180810_projFfTvBuffers.png' align="right" width="35%" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;p&gt;Vamos começar colocando os buffers virtuais, como na figura ao lado. Já aproveitei e nomeei todas as conexões existentes para facilitar o próximo passo: a extração das equações.&lt;/p&gt;
&lt;div class="math"&gt;$$
I=\overline{T.C.Y_2}\\
J=\overline{\overline{T}.\overline{C}.\overline{Y_2}}\\
K=\overline{\overline{T}.\overline{C}.Y_2}\\
L=\overline{T.C.\overline{Y_2}}\\
M=\overline{Y_1.K.L}\\
N=\overline{T.\overline{C}.\overline{Y_1}}\\
O=\overline{T.\overline{C}.Y_1}\\
P=\overline{Y_2.O}
$$&lt;/div&gt;
&lt;p&gt;Resolvendo &lt;span class="math"&gt;\(M\)&lt;/span&gt; e &lt;span class="math"&gt;\(P\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
M=\overline{Y_1.K.L}=\overline{Y_1.\overline{\overline{T}.\overline{C}.Y_2}.\overline{T.C.\overline{Y_2}}}=\overline{Y_1.(T+C+\overline{Y_2}).(\overline{T}+\overline{C}+Y_2)}\\
 =\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}\\
P=\overline{Y_2.O}=\overline{Y_2.\overline{T.\overline{C}.Y_1}}=\overline{Y_2.(\overline{T}+C+\overline{Y_1})}=\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}
$$&lt;/div&gt;
&lt;p&gt;E finalmente resolvendo &lt;span class="math"&gt;\(Y_1^*\)&lt;/span&gt; e &lt;span class="math"&gt;\(Y_2^*\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;$$
Y_1^*=\overline{I.J.M}\\
=\overline{\overline{T.C.Y_2}.\overline{\overline{T}.\overline{C}.\overline{Y_2}}.\overline{T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}}}\\
=T.C.Y_2+\overline{T}.\overline{C}.\overline{Y_2}+T.\overline{C}.Y_1+T.Y_1.Y_2+\overline{T}.C.Y_1+C.Y_1.Y_2+\overline{T}.Y_1.\overline{Y_2}+\overline{C}.Y_1.\overline{Y_2}\\
Y_2^*=\overline{N.P}=\overline{\overline{T.\overline{C}.\overline{Y_1}}.\overline{\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2}}\\
=T.\overline{C}.\overline{Y_1}+\overline{T}.Y_2+C.Y_2+\overline{Y_1}.Y_2\\
$$&lt;/div&gt;
&lt;p&gt;O próximo passo é preencher a tabela de transição de estados e saída. A tabela preenchida pode ser vista abaixo, para &lt;span class="math"&gt;\(Y_1^*Y_2^*\)&lt;/span&gt;. Os estados contornados são estados estáveis, ou seja, não há mudança de estado para aquela entrada. Também podemos ver a tabela de fluxo, com as saídas.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabelas de transição de estados e de fluxo, com saídas" src="https://balbertini.github.io/images/sd/er/er0001_tranTable.png"&gt;&lt;/p&gt;
&lt;p&gt;Na tabela de transição de estados, podemos fazer a análise de corridas. Uma corrida acontece quando &lt;strong&gt;uma única mudança na entrada causa uma mudança em mais de uma variável de estado&lt;/strong&gt;. No nosso caso, uma única mudança em &lt;span class="math"&gt;\(T\)&lt;/span&gt; ou &lt;span class="math"&gt;\(C\)&lt;/span&gt; (tanto de zero para um quanto de um para zero, em qualquer uma das entradas), deve provocar uma mudança das variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt; de mais de um bit, ou seja, de 00 para 11 ou de 10 para 01 (ou vice-versa). Na tabela, podemos verificar que não há corridas. Exemplo: na primeira linha estamos com as variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt; em 00. Nenhuma transição desta linha indica uma transição para 11, as transições possíveis são para 10, 00, 00 e 01, de acordo com as entradas 00, 01, 11 ou 10 respectivamente. Isso significa que, se estivermos no estado 00, uma mudança de um bit não ocasionará uma mudança de mais de um bit nas variáveis de estado. Ainda precisamos analisar as colunas. Se estivermos no mesmo estado (00) e a entrada estiver em 00, as variáveis de estado indicam que o próximo estado é 10, que é estável, portanto esta mudança irá acontecer. Do estado 00 para 10 só há uma mudança nas variáveis de estado, então não há corrida. Se estivermos no estado 00 e a entrada for 01 ou 11, o estado já é estável, então não há mudança alguma nas variáveis de estado. No caso da entrada 10, o novo estado será 01, que é estável e só muda um bit da variável de estado. Prossegue-se com a análise para o restante da tabela e conclui-se que não há corrida alguma. Após a análise de corridas, pode-se montar a tabela de fluxo (com saídas), mostrada do lado direito da figura. Para facilitar, adotou-se a codificação de estados como &lt;span class="math"&gt;\(S_i\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(i\)&lt;/span&gt; é o número decimal que representa as variáveis de estado &lt;span class="math"&gt;\(Y_1Y_2\)&lt;/span&gt;. É preferível fazer a análise de corrida na tabela de transição em binário, pois é mais fácil perceber as mudanças.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/er/er0001_diagrama.png' align="right" width="35%" style="padding-left:5%" /&gt;
Por último, montamos o diagrama de transição de estados, que fica conforme a figura ao lado.&lt;/p&gt;
&lt;p&gt;A análise de comportamento é opcional, mas é relativamente fácil perceber que se trata de um &lt;em&gt;flip-flop&lt;/em&gt; tipo T sensível a borda de descida. A análise pode ser feita da seguinte forma: começa-se no estado &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; (pode ser qualquer estado) e analisa-se o comportamento das entradas. Percebe-se que, a única maneira de sair desse estado é se a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; for zero, de onde conclui-se que o circuito é algo que espera esta entrada virar zero. Nota-se ainda que, quando isso acontece, a saída muda caso a entrada &lt;span class="math"&gt;\(T\)&lt;/span&gt; seja um, caso contrário não muda. Todos os estados "seguram" a borda da entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt;, ou seja, independentemente se formos para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; ou &lt;span class="math"&gt;\(S_2\)&lt;/span&gt; a partir do &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, a entrada &lt;span class="math"&gt;\(C\)&lt;/span&gt; não altera mais o comportamento da máquina exceto se for para um e depois para zero novamente. Poderíamos dizer que os estados tem estas funções:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_0\)&lt;/span&gt;: saída zero, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;: saída um, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;: saída zero, não deve-se inverter a saída, aguarda que &lt;span class="math"&gt;\(C=1\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(S_3\)&lt;/span&gt;: saída um, aguarda &lt;span class="math"&gt;\(C=0\)&lt;/span&gt; e inverte a saída se &lt;span class="math"&gt;\(T=1\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Repare que o efeito &lt;em&gt;toggle&lt;/em&gt; só acontece nas arestas horizontais, de &lt;span class="math"&gt;\(S_0\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_1\)&lt;/span&gt; e de &lt;span class="math"&gt;\(S_3\)&lt;/span&gt; para &lt;span class="math"&gt;\(S_2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://balbertini.github.io/extra/sd/er/20181009_projFfT.circ"&gt;Download do circuito no LogiSim&lt;/a&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="exercícios resolvidos"></category><category term="análise"></category><category term="circuitos realimentados"></category></entry><entry><title>Simplificação de FSM</title><link href="https://balbertini.github.io/fsmstatereduction-pt_BR.html" rel="alternate"></link><published>2018-09-25T14:22:00-03:00</published><updated>2018-09-26T22:49:00-03:00</updated><author><name>Bruno Albertini</name></author><id>tag:balbertini.github.io,2018-09-25:/fsmstatereduction-pt_BR.html</id><summary type="html">&lt;p&gt;Como fazer simplificação de estados em máquinas de estados finitas.&lt;/p&gt;</summary><content type="html">&lt;p&gt;A máquina de estados finita em sistemas digitais, quando realizada na forma de um circuito digital, utiliza recursos computacionais (e.g. &lt;em&gt;flip-flops&lt;/em&gt;, memórias, portas lógicas, etc.) que são caros do ponto de vista de área e consumo de energia, principalmente se a máquina possuir muitos estados. Por este motivo, é importante minimizar o número de estados da máquina para que, na implementação, utilizemos somente os recursos mínimos necessários para aquela máquina. Além disso, quando estamos projetando uma máquina de estados para resolver um problema, é mais confortável não pensar em otimizações mas sim na funcionalidade da máquina, para só depois pensar na otimização. De fato, a maioria dos projetistas comerciais não pensa na otimização quando estão modelando o problema pois isso nem sempre é possível (i.e. o projetista não tem visão da máquina toda mas sim da parte cabível a ele, a máquina é muito grande tornando impossível pensar em tudo, a máquina é particionada, etc).&lt;/p&gt;
&lt;p&gt;Na prática, com os sintetizadores modernos, você pode especificar sua máquina usando a linguagem de descrição de hardware de sua preferência e deixar o sintetizador otimizá-la para você. Os resultados da otimização automática são bons quando comparados aos métodos manuais [1,2]. Contudo, é necessário conhecer o mínimo do funcionamento dos algoritmos de minimização pois, quando for descrever sua máquina, você conhecerá ao menos o básico do que acontecerá quando sintetizá-la. Neste artigo, explicarei os métodos de minimização por identificação direta na tabela de transição de estados e por tabela de implicação. Em ambos os casos, o objetivo principal é encontrar estados equivalentes, ou seja, que &lt;strong&gt;para a mesma entrada, produzem a mesma saída e transicionam para os mesmos estados.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Minimização através da tabela de transição&lt;/h2&gt;
&lt;p&gt;Em muitos casos, é fácil identificar os estados equivalentes na tabela de transição de estados, por isso este método também é chamado de &lt;strong&gt;observação direta&lt;/strong&gt; ou &lt;strong&gt;casamento de linhas&lt;/strong&gt;. O algoritmo é simples:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Elimine todos os estados inalcançáveis (estados onde não chega nenhuma aresta partindo de outro estado alcançável).&lt;/li&gt;
&lt;li&gt;Identifique dois estados A e B que, para a mesma entrada, produzam exatamente a mesma saída e realizem a mesma transição (transicionem para o mesmo estado).&lt;/li&gt;
&lt;li&gt;Elimine um dos estados (e.g. B) apagando a linha correspondente a este estado e substitua todas as ocorrências de B por A (i.e. todos as transições para B agora devem apontar para A).&lt;/li&gt;
&lt;li&gt;Repita até que nenhum par de estados atenda (2).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Exemplo&lt;/h3&gt;
&lt;p&gt;Uma forma muito comum de projetar máquinas de estados é modelando-a como árvore, onde cada ramificação é uma tomada de decisão. Tomemos a máquina abstrata a seguir que foi montada partindo de uma árvore binária canônica e modificada para reconhecer as sequencias 0011 e 1001:&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;Em vermelho está destacado o caminho que esta máquina irá seguir para reconhecer as duas sequencias. Note que esta é uma máquina de Mealy e não leva em consideração nenhuma sobreposição entre as sequencias detectadas, ou seja, ela só funciona para entradas de 4 bits agrupados a partir do &lt;em&gt;reset&lt;/em&gt; (e.g. detecta duas vezes se a entrada for 0011 1001 mas não detecta a segunda vez se a entrada for 0011 001).&lt;/p&gt;
&lt;p&gt;A tabela de transição de estados fica como na Tabela 1 a seguir.&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0px;margin-right:10px;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-3r9o{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-4m7p{background-color:#9aff99;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-uuae{background-color:#67fd9a;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-vswx{background-color:#fd6864;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-fcno{background-color:#fcff2f;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-bolj{background-color:#ffccc9;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-mfhl{background-color:#ffffc7;border-color:inherit;text-align:center;vertical-align:top}
&lt;/style&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela 1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S7/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S9/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S10/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S12/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S6&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S13/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S14/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S7&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S8&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S9&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S10&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S11&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S12&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S13&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S14&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S4/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S6/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S8/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S4&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S11/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S6&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S8&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S11&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;!-- ------------------------------------------------------- --&gt;

&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-c3ow" colspan="3"&gt;Tabela 3&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-3r9o" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="2"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S2/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S1&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S2&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sb/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S3&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-c3ow"&gt;S5&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sc/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
    &lt;td class="tg-4m7p"&gt;Sa/0&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sc&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-uuae"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
    &lt;td class="tg-c3ow"&gt;S0/0&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A coluna &lt;strong&gt;E.A.&lt;/strong&gt; mostra o estado atual, e a coluna &lt;strong&gt;P.E.&lt;/strong&gt; o próximo estado. Esta última é bipartida para as entradas igual a &lt;strong&gt;0&lt;/strong&gt; e igual a &lt;strong&gt;1&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A Tabela 1 possui todas as transições da árvore como vista na figura. Esta máquina não tem nenhum estado inalcançável, então não há o que eliminar no passo 1.&lt;/p&gt;
&lt;p&gt;No passo 2, devemos procurar as equivalências. É fácil perceber que há estados que produzem exatamente o mesmo resultado (transição e saída) para determinada entrada. Tomemos por exemplo os estados S7, S9, S10, S12, S13 e S14: todos transicionam para S0 e produzem saída 0 para qualquer entrada, portanto são equivalentes. Podemos reduzir a tabela substituindo todos estes estados por um estado Sa, o que podemos ver na Tabela 2, destacado em verde.&lt;/p&gt;
&lt;p&gt;Se fizermos a busca novamente, os estados S4 e S6 agora são equivalentes pois ambos transicionam para Sa e produzem saída 0, independententemente da entrada. Criamos o estado Sb, em vermelho, para substituir estes estados. Similarmente os estados S8 e S11 são equivalentes, mas note que eles tem saídas diferentes para entradas diferentes. Para este conjunto de estados, criamos Sc, em amarelo. Não há mais estados equivalentes e o resultado final pode ser visto na Tabela 3.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="35%" align="right" style="padding-left:5%" /&gt;
&lt;br/&gt;
O diagrama de transição de estados minimizado pode ser visto na figura ao lado. Os estados S7, S9, S10, S12, S13 e S14 são representados pelo Sa, S4 e S6 pelo Sb e S8 e S11 pelo Sc.&lt;/p&gt;
&lt;p&gt;O método de análise da tabela de transição de estados se baseia na busca exaustiva por estados equivalentes. É fácil perceber que, conforme a tabela cresce, ficará mais difícil visualizar os estados equivalentes. Além disso, o método não garante a menor quantidade de estados possível pois é baseado em estados e não em grupos de estados (veja o primeiro exemplo da próxima seção).&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;O método de minimização por tabela de implicação&lt;/h2&gt;
&lt;p&gt;Nem sempre é tão fácil perceber a equivalência de estados através da tabela de transição de estados, especialmente para máquinas grandes ou com muitas entradas. No entanto, os projetistas desenvolveram um método chamado de tabela de implicação. Este método é equivalente à análise através da tabela de transição de estados, porém é algorítmico e está organizado em forma de uma matriz, o que minimiza erros por parte do projetista. Além disso, apesar de ambos os métodos serem exaustivos, há uma diferença primordial: enquanto o método de análise da tabela de transição de estados procura exaustivamente estados equivalentes, o método da tabela de implicação procura exaustivamente os estados que &lt;strong&gt;não são equivalentes&lt;/strong&gt;. Parte-se da premissa de que todos os estados são equivalentes entre si e, a cada iteração, elimina-se os estados que não podem ser equivalentes. Os estados que sobrarem são equivalentes.&lt;/p&gt;
&lt;p&gt;Há dois momentos no método da tabela de implicação: a construção da tabela e a análise.&lt;/p&gt;
&lt;h3&gt;Construção da matriz (tabela)&lt;/h3&gt;
&lt;p&gt;A matriz pode ser construída como uma matriz &lt;span class="math"&gt;\(n\)&lt;/span&gt; por &lt;span class="math"&gt;\(n\)&lt;/span&gt;, onde &lt;span class="math"&gt;\(n\)&lt;/span&gt; é o número de estados (se você começar no &lt;span class="math"&gt;\(S_0\)&lt;/span&gt;, o último estado será &lt;span class="math"&gt;\(S_{n-1}\)&lt;/span&gt;). Cada linha &lt;span class="math"&gt;\(i\)&lt;/span&gt; da matriz representa um estado e cada coluna &lt;span class="math"&gt;\(j\)&lt;/span&gt; também.&lt;/p&gt;
&lt;p&gt;Não faz sentido analisar a equivalência de um estado com ele mesmo, pois um estado sempre é equivalente a ele mesmo. Por este motivo, eliminamos a diagonal da matriz, onde &lt;span class="math"&gt;\(i=j\)&lt;/span&gt;. As metades diagonais superiores e inferiores significam a mesma coisa pois se uma célula &lt;span class="math"&gt;\(X_{ij}\)&lt;/span&gt; mostra equivalência entre o estado &lt;span class="math"&gt;\(S_i\)&lt;/span&gt; e o estado &lt;span class="math"&gt;\(S_j\)&lt;/span&gt;, a célula &lt;span class="math"&gt;\(X_{ji}\)&lt;/span&gt; também deve mostrar a mesma equivalência. Por este motivo, eliminamos também uma das metades diagonais. Por convenção, elimina-se a diagonal superior, mas o resultado é o mesmo se você eliminar a metade diagonal inferior.&lt;/p&gt;
&lt;p&gt;Quando estiver confortável com a construção da matriz, você poderá desenhá-la já sem a diagonal e sem a metade diagonal superior. A esse desenho contendo somente a metade diagonal inferior da tabela, chamamos de &lt;strong&gt;tabela de implicação&lt;/strong&gt;. Na figura abaixo mostramos a matriz inteira, a matriz destacando a linha diagonal (vermelha) e a metade diagonal superior (laranja), e finalmente a tabela de implicação.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Construção da tabela de implicação." src="https://balbertini.github.io/images/sd/sdfsmoptconsttab.png"&gt;&lt;/p&gt;
&lt;p&gt;Após obter a tabela de implicação, devemos preencher as células. Cada célula terá &lt;span class="math"&gt;\(2^b\)&lt;/span&gt; linhas, onde &lt;span class="math"&gt;\(b\)&lt;/span&gt; é o número de bits da entrada. E.g. se a entrada for de 1 bit, cada célula tem 2 linhas; se a entrada for de 2 bits, cada célula tem 4 linhas. Cada linha da entrada corresponde às transições daqueles estados para aquela entrada.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptconstcel.png' width="45%" align="right" style="padding-left:5%" /&gt;
Na figura podemos ver o exemplo do preenchimento para duas células, ambas na linha do S3 e coluna do S4. Para simplificar o preenchimento, usamos somente o número do estado, mas você pode escrever o nome completo do estado (especialmente útil se os nomes dos estados não forem numerados).&lt;/p&gt;
&lt;p&gt;Na célula na esquerda na figura, a entrada tem 1 bit, portanto temos duas linhas, uma para a entrada 0 e outra para a entrada 1. Nesta célula, a máquina é de Mealy com saída de 1 bit, que pode ser vista representada nas transições.&lt;/p&gt;
&lt;p&gt;Já na célula a direita na figura, a entrada tem 2 bits, portanto temos 4 linhas para as entradas 00, 01, 10 e 11. A máquina representada é de Moore e também tem um bit só de saída, que nesse caso é representado no estado e não na transição.&lt;/p&gt;
&lt;p&gt;Os números em cada linha correspondem a transição que o estado fará para cada entrada (e à saída referente àquela transição no caso de uma máquina de Mealy). No exemplo a esquerda na figura, podemos assumir que, para uma determinada entrada e estando em S3 ou em S4, a máquina transicionará para o estado S0/0 ou S1/0 (note que em ambas as transições a saída é 0). Na mesma situação mas para a outra entrada, a máquina transicionará para o estado S2/0 ou S3/1. Mas como eu sei qual entrada? Não é preciso saber para qual entrada, apenas que as transições da mesma linha, separadas por &lt;code&gt;-&lt;/code&gt;, são para a mesma entrada. De fato, alguns projetistas preferem ordenar as transições em ordem crescente para facilitar a busca por estados equivalentes. E.g. (linha superior / linha inferior) 3-2/1-2 é o mesmo que 1-2/2-3, mas ordenado. Fica a seu critério decidir a melhor forma de organizar sua tabela de implicação, mas lembre-se que cada linha corresponde a exatamente dois estados separados por &lt;code&gt;-&lt;/code&gt;, para os quais a máquina de estados transicionará quando houver a mesma entrada.&lt;/p&gt;
&lt;p&gt;É de praxe também assinalar os estados que produzem saídas diferentes, pois eles não podem ser equivalentes. Neste caso, coloque uma &lt;code&gt;/&lt;/code&gt; no índice de coluna e linha (caso a máquina for de Moore) ou na transição dentro da célula (caso a máquina for de Mealy). Isto ficará mais claro no exemplo.&lt;/p&gt;
&lt;h2&gt;Procurando estados equivalentes&lt;/h2&gt;
&lt;p&gt;Com a tabela de implicação construída, devemos procurar os estados equivalentes. Isto é feito de forma exaustiva, analisando todas as células da tabela.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Risque todas as transições que vão para o mesmo estado e produzem a mesma saída (tipo s-s), pois elas são naturalmente equivalentes. E.g. se você tem uma transição 0-0, risque-a pois não é preciso analisá-la.&lt;/li&gt;
&lt;li&gt;Elimine as células com estados (Moore) ou transições (Mealy) que produzem saídas diferentes. Estes estados nunca poderão ser equivalentes.&lt;/li&gt;
&lt;li&gt;Analise uma célula qualquer que não tenha todas as transições riscadas e que não tenha sido eliminada anteriormente. Esta célula é uma candidata a equivalência.&lt;ul&gt;
&lt;li&gt;Olhe todas as linhas da célula que não foram riscadas no passo (1). Para cada uma, analise a célula alvo. E.g. se a transição marca 1-2, você deve analisar a célula correspondente aos estados S1 e S2.&lt;/li&gt;
&lt;li&gt;Se a célula alvo estiver eliminada, você deve eliminar esta célula também.&lt;/li&gt;
&lt;li&gt;Se você analisou todas as linhas e não eliminou a célula, não faça nada.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Repita o (3) até que todas as células tenham sido analisadas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note que este processo é exaustivo. Para não correr o risco de analisar a mesma célula várias vezes, aconselho começar pela célula mais a direita inferior e depois passar para a segunda mais a direita inferior, e assim por diante. Não faz diferença a ordem em que você analisa as células, mas você deve se organizar para não repetir células.&lt;/p&gt;
&lt;p&gt;Durante a análise, pode acontecer de você eliminar uma linha inteira ou uma coluna inteira. Isso significa que o estado daquela linha ou coluna não é equivalente a nenhum outro estado, portanto você deve eliminar todas as células que tem alguma linha referenciando aquele estado. E.g. se você eliminou a linha toda do S3, você deve eliminar todas as células que possuam ao menos um 3 em alguma linha (x-3 ou 3-x).&lt;/p&gt;
&lt;p&gt;Você não precisa analisar células onde todas as linhas tenham sido riscadas no passo 1. Se você riscar todas as linhas de uma célula, os estados desta célula (linha-coluna) são automaticamente equivalentes. Você não precisa tomar nenhuma ação em relação a isso, apenas pule a análise da célula.&lt;/p&gt;
&lt;p&gt;Quando você terminar este processo, as células que você não eliminou representam &lt;strong&gt;classes de equivalência&lt;/strong&gt;. Uma classe de equivalência é um grupo de estados que são equivalentes e, consequentemente, podem ser representados por um único estado. E.g. se a célula da linha 3 coluna 4 não foi eliminada, os estados S3 e S4 são equivalentes.&lt;/p&gt;
&lt;h2&gt;Exemplo 1/3 - Moore simples&lt;/h2&gt;
&lt;p&gt;Este exemplo é de uma máquina de Moore que detecta uma paridade ímpar considerando todas as entradas que já passaram pela máquina. O diagrama e a tabela de transição de estados podem ser vistos abaixo:&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="3"&gt;Tabela E1&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;0&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;A/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;A&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;B/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;C/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;C&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;B&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diag.png' width="13%" align="left" style="padding-left:5%; padding-right:5%"/&gt;
Tente minimizar esta máquina usando o método de análise da tabela de transição. É possível encontrar algum estado equivalente? Perceba que os estados A e C são equivalentes, mas não é possível perceber isto apenas com a tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1a.png' width="55%" align="right" style="padding-left:5%"/&gt;
Vamos construir a tabela de implicação para verificar. Na figura ao lado, podemos ver: (esquerda) a tabela de implicação construída e com os estados (note que é uma máquina de Moore, então as saídas são representadas nos estados); (meio) a tabela de implicação com as linhas de acordo com a tabela de transição de estados; e (direita) a versão com a linha B-B já riscada, pois para esta entrada, a máquina transiciona para o mesmo estado independententemente de qual estado esteja. Isto equivale à construção da tabela de implicação e à execução do primeiro passo do algoritmo.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1b.png' width="45%" align="left" style="padding-right:5%"/&gt;
No segundo passo eliminamos os estados que produzem saída diferentes, pois nunca poderão ser equivalentes. Isto pode ser visto à esquerda na figura ao lado (os estados eliminados foram destacados em cinza). Sobra a única célula a ser verificada, correspondente aos estados C/0-A/0. Esta célula tem uma linha riscada (que não precisa ser analisada) e uma linha que referencia A-C. A referência A-C aponta para a mesma célula que estamos analisando, a célula C/0-A/0. Como esta célula ainda não foi eliminada, nada resta a fazer e devemos continuar o algoritmo. Porém, não há mais células a serem analisadas, portanto o algoritmo terminou. Isso significa que a única célula que não foi eliminada será a nossa classe de equivalência, destacada em vermelho na tabela de implicação da figura.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex1diagmin.png' width="13%" align="left" style="padding-right:5%"/&gt;
A célula indica que a classe de equivalência contém somente dois estados, o C/0 e o A/0. Para finalizar, montamos um novo diagrama de transição de estados com um estado chamado AC/0, em vermelho, representando a classe de equivalência encontrada. As transições são transportadas dos estados da classe de equivalência e, obviamente, são esperadas que sejam as mesmas pois os estados são equivalentes. Esta máquina tem a mesma funcionalidade que a anterior, porém tem um estado a menos. Este tipo de minimização não é possível usando a análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 2/3 - Moore com entrada de 2 bits&lt;/h2&gt;
&lt;p&gt;A Tabela E2 é a tabela de transição de estados de uma máquina de Moore, com entrada de dois bits. Sua funcionalidade ou diagrama de transição de estados não importam neste momento, mas o diagrama equivalente pode ser visto na figura.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S0/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S3&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S3/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S4/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S5/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S4&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S5&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diag.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo podemos ver a tabela construída e com o passo 1 executado (esquerda) e após o passo 2 executado (direita). Note que, para minimizar o esforço em preencher a tabela e evitar poluí-la, eu eliminei o "S" e utilizei somente os índices dos estados.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2a.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2b.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Nas tabelas abaixo, podemos ver a tabela de implicação após o passo 3 executado a exaustão (esquerda) e com as classes de equivalência construídas (direita). Na tabela da esquerda, as linhas que provocaram a exclusão da tabela foram realçadas com um cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2c.png' width="50%" align="left" /&gt;
&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2d.png' width="50%" align="right"/&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;p&gt;Pela tabela, podemos inferir que os estados S4 e S0 (Sa) são equivalentes entre si, assim como os estados S5 e S3 (Sb). A tabela de transição de estados minimizada e o diagrama de transição de estados minimizado podem ser vistos abaixo. A máquina original possuía 6 estados, o que exige 3 &lt;em&gt;flip-flops&lt;/em&gt; para sua implementação, mas a minimizada tem 4 estados, o que exige 2 &lt;em&gt;flip-flops&lt;/em&gt;, portanto economizamos um &lt;em&gt;flip-flop&lt;/em&gt; apenas minimizando a máquina.&lt;/p&gt;
&lt;table class="tg" align="left"&gt;
  &lt;tr&gt;
    &lt;th class="tg-baqh" colspan="5"&gt;Tabela E2 min&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz" rowspan="2"&gt;E.A.&lt;/td&gt;
    &lt;td class="tg-zlqz" colspan="4"&gt;P.E.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-zlqz"&gt;00&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;01&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;10&lt;/td&gt;
    &lt;td class="tg-zlqz"&gt;11&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-vswx"&gt;Sa/1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S1/0&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-baqh"&gt;S2/1&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S2&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-fcno"&gt;Sb/0&lt;/td&gt;
    &lt;td class="tg-baqh"&gt;S1&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-bolj"&gt;Sa&lt;/td&gt;
    &lt;td class="tg-mfhl"&gt;Sb&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmoptex2diagmin.png' width="45%" align="right" style="padding-left:5%" /&gt;&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h2&gt;Exemplo 3/3 - Mealy com 15 estados&lt;/h2&gt;
&lt;p&gt;Suponha a mesma máquina de estados usada como exemplo no método de análise da tabela de transição de estados, mostrada na figura. Trata-se de uma máquina de Mealy que reconhece 0011 ou 1001 sem sobreposição.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FSM em forma de árvore" src="https://balbertini.github.io/images/sd/sdfsmopt2.png"&gt;&lt;/p&gt;
&lt;p&gt;A máquina tem 15 estados, portanto temos uma matriz 15x15. A tabela de implicação, já com os valores das transições preenchidos e com as transições s-s riscadas, pode ser vista na figura abaixo. Note que esta é uma máquina de Mealy, então coloquei a saída na transição (e.g. nos estados S8 e S11, que são os que produzem saída, há transições na forma 0/1, indicando que esta transição produz saída 1). Isto corresponde à construção da tabela de implicação e à execução do passo 1 do algoritmo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 1" src="https://balbertini.github.io/images/sd/sdfsmoptex3a.png"&gt;&lt;/p&gt;
&lt;p&gt;No passo 2, devemos eliminar as transições que produzem saídas diferentes, ou seja, devemos eliminar todas as células que contém uma transição s-t onde a saída de s é diferente da saída de t. Exemplo: a célula S14-S11 possui a segunda linha como 0/1-0, o que significa que, apesar de irem para o mesmo estado, uma produz saída 1 (0/1) e outra produz saída 0 (0/0), portanto devemos eliminar esta célula toda. Isto pode ser visto na figura abaixo, onde todas as células eliminadas por este motivo foram identificadas com fundo cinza e a linha que foi o motivo da eliminação com cinza escuro.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 2" src="https://balbertini.github.io/images/sd/sdfsmoptex3b.png"&gt;&lt;/p&gt;
&lt;p&gt;O passo 2 eliminou os estados que trivialmente não são equivalentes. Podemos então começar o passo 3 analisando cada célula. Eu comecei pela célula mais a direita inferior e continuei analisando para a esquerda. A célula S14-S13 não precisa ser analisada pois tem todas as transições riscadas. Idem para a célula S14-S12. Já a célula S14-S11 foi eliminada anteriormente e também não precisa ser analisada.&lt;/p&gt;
&lt;p&gt;A primeira célula que realmente precisa ser analisada é a S14-S6. Nesta célula, a transição 13-0 aponta para a a célula S13-S0, e a transição 14-0 para a célula S14-S0. Estas células alvo ainda indicam equivalência, então não fiz nada na célula em análise (S14-S6). Idem para S14-S5 e S14-S4.&lt;/p&gt;
&lt;p&gt;Já na célula S14-S3, encontrei uma referência à S8-S0, que já foi eliminado em um passo anterior. Isso significa que eu devo eliminar esta célula. Nesse ponto, percebi que a linha do S8 estava inteira eliminada, então eliminei  todas as células que fazem referência a S8, ou seja, que tem transições 8/x-x/x ou x/x-8/x. O resultado pode ser visto na figura abaixo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 passo 3" src="https://balbertini.github.io/images/sd/sdfsmoptex3c.png"&gt;&lt;/p&gt;
&lt;p&gt;Se está lendo com cuidado, deve ter percebido que a eliminação que acabei de fazer eliminou o estado S3 inteiro. Isto significa que podemos eliminar todas as células que contém transições que referenciam o S3, pois ele não pode ser equivalente a nenhum outro estado. Se você continuar o algoritmo, terminará com a tabela de implicação abaixo, onde as células eliminadas estão em cinza.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 eliminadas" src="https://balbertini.github.io/images/sd/sdfsmoptex3d.png"&gt;&lt;/p&gt;
&lt;p&gt;A única célula que ainda precisa de análise é a célula S6-S4. Esta célula referencia os estados S9-S13 na primeira linha e S10-S14 na segunda linha. Ambas as células S9-S13 e S10-S14 não foram eliminadas pois possuem todas as suas linhas riscadas, então não devemos fazer nada nesta célula. Como não há mais células a serem analisadas, o algoritmo terminou.&lt;/p&gt;
&lt;p&gt;Com o algoritmo finalizado, podemos inferir os estados equivalentes observando as células que não foram eliminadas. A célula S6-S4 indica que estes dois estados são equivalentes. Similarmente, a coluna S7 indica que os estados S7, S9, S10, S12, S13 e S14 são todos equivalentes. Isso pode ser corroborado pelas colunas do S9, S10, S11, S12 e S13, que indicam também esta equivalência. Ainda, a célula S11-S8 indica que estes dois estados são equivalentes entre si (note que ambos produzem saída 1).&lt;/p&gt;
&lt;p&gt;Para facilitar a visualização, a figura abaixo traz as classes de equivalência coloridas. Para a mesma cor, os estados são equivalentes.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tabela exemplo 1 fim" src="https://balbertini.github.io/images/sd/sdfsmoptex3e.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src='https://balbertini.github.io/images/sd/sdfsmopt3.png' width="45%" align="right" style="padding-left:5%" /&gt;
Por último, devemos reconstruir o diagrama de transição de estados. Para cada classe de equivalência, criamos um estado novo. As transições e as saídas podem ser copiadas de qualquer um dos estados da classe, pois eles são equivalentes (para as mesmas entradas, produzem a mesma saída e transicionam para o mesmo estado). Note que este método agrupa os estados em classes, então a transição do Sb (que é composto por S4 e S6) que vai para o S9, por exemplo, deve ir para o estado Sa (que é composto por S7, S9, S10, S12, S13 e S14) pois esta é a classe de equivalência que contém o S9. O diagrama desta tabela é idêntico ao obtido usando o método de análise da tabela de transição de estados.&lt;/p&gt;
&lt;div style="border: 0px; overflow: auto;width: 100%;"&gt;&lt;/div&gt;

&lt;h1&gt;Referências&lt;/h1&gt;
&lt;p&gt;&lt;p/&gt;
[1] DE VRIES, A. Finite automata: Behavior and synthesis. Elsevier, 2014.&lt;br&gt;
[2] KAM, Timothy et al. Synthesis of finite state machines: functional optimization. Springer Science &amp;amp;
Business Media, 2013.&lt;/p&gt;
&lt;p&gt;Algumas partes dos exemplos foram adaptados de apresentações do &lt;a href="http://www-inst.eecs.berkeley.edu/~cs150/sp00/classnotes/katz-ch9-mod.pdf"&gt;Prof. Randy H. Katz&lt;/a&gt; e da disciplina &lt;a href="https://courses.cs.washington.edu/courses/cse370/09wi/LectureSlides/22-Minimization.pdf"&gt;CSE370, Lecture 22&lt;/a&gt;.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="sistemas digitais"></category><category term="fsm"></category><category term="simplificação"></category><category term="otimização"></category></entry></feed>